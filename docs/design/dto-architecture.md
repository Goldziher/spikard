# Structured DTO Strategy

This document captures the baseline design for structured request/response
types generated by the CLI across languages. The goal is to keep data
marshalling close to the Rust core, minimise runtime conversions, and ensure
generated code satisfies the default linters/formatters for every binding.

## Design Principles

- **Strong defaults:** each language has a canonical DTO technology that we
  emit when no explicit option is provided.
- **Configurable generators:** `spikard-cli generate` / `generate-asyncapi`
  accept parameters (planned CLI flags + YAML config) to switch DTO targets per
  binding. This mirrors the OpenAPI and AsyncAPI flows.
- **Rust-first:** decoding/validation happens in Rust. Host language DTOs are
  thin shells that express structure for editor support and runtime contracts,
  but they should not duplicate validation that already happens in Rust.
- **Fallback to maps only when required:** we emit `dict[str, Any]`,
  `Record<string, unknown>`, or `Hash` only when the source schema allows
  arbitrary key/value (e.g. `additionalProperties: true`). Structured schemas
  always generate typed DTOs.

## Default DTO Targets

| Language | Default | Rationale |
|----------|---------|-----------|
| Python   | `@dataclass` definitions | Standard library, integrates cleanly with type checkers and msgspec. |
| Node.js / TypeScript | Zod schemas + inferred types | Zod provides runtime validation + strong types, keeps generated code lint-clean. |
| Ruby     | Dry::Schema (and Dry::Struct for richer models) | Idiomatic Ruby type enforcement while remaining lightweight. |

### Alternative Targets

We support (or plan to support) additional DTO styles via CLI switches:

- **Python:** `msgspec.Struct`, `typing.TypedDict`, `dataclasses`, `pydantic`
  v2 models, or plain `dict[str, Any]` (fallback).
- **Node.js:** Zod (default), TypeScript interfaces only, `io-ts`, `runtypes`.
- **Ruby:** Dry::Schema (default), Dry::Struct, PORO structs (hash-only).

The generator surfaces these via flags such as:

```
spikard generate --schema api.yaml --lang python \
  --dto-target dataclass            # default
spikard generate --schema api.yaml --lang python \
  --dto-target msgspec
```

Internally, the target is translated into IR so every binding receives the same
structured payload regardless of transport (HTTP, WebSocket, SSE).

## AsyncAPI Test Assets

The AsyncAPI generator follows the same rules:

- Python test apps import the generated dataclasses.
- Node.js apps ship with Zod schemas to parse fixtures (already used in the
  refactored Node output).
- Ruby apps pull Dry schema contracts for fixtures.

When a message payload is untyped (e.g., free-form JSON), the generator emits
`dict[str, Any]` / `Record<string, unknown>` / `Hash[String, Object]`
respectively and annotates the fixture to explain why.

## Future Protocols

This architecture scales to new transports (JSON-RPC, MsgPack, gRPC):

- The central `CodegenEngine` will route schema families to specific DTO
  builders.
- DTO targets remain declarative so new transport generators can reuse them.
- Benchmark/test generators (e2e + AsyncAPI streaming) load the same DTO
  metadata to keep fixtures in sync with host bindings.
