# Rust gRPC Handler

Complete Rust handler implementation for UserService with GetUser and CreateUser methods.

```rust
use bytes::Bytes;
use spikard_http::grpc::{GrpcHandler, GrpcHandlerResult, GrpcRequestData, GrpcResponseData};
use tonic::Status;
use std::sync::Arc;

// Generated protobuf types
mod userservice {
    include!("userservice.rs");  // Generated by prost
}

pub struct UserServiceHandler {
    user_repository: Arc<dyn UserRepository + Send + Sync>,
}

impl UserServiceHandler {
    pub fn new(user_repository: Arc<dyn UserRepository + Send + Sync>) -> Self {
        Self { user_repository }
    }

    async fn get_user(&self, request: GrpcRequestData) -> GrpcHandlerResult {
        // 1. Deserialize request
        use prost::Message;
        let req = userservice::GetUserRequest::decode(request.payload)
            .map_err(|e| Status::invalid_argument(format!("Invalid request: {}", e)))?;

        // 2. Validate input
        if req.id <= 0 {
            return Err(Status::invalid_argument("User ID must be positive"));
        }

        // 3. Business logic
        let user = self.user_repository.find_by_id(req.id).await
            .map_err(|e| Status::internal(format!("Database error: {}", e)))?
            .ok_or_else(|| Status::not_found(format!("User {} not found", req.id)))?;

        // 4. Build response
        let response_user = userservice::User {
            id: user.id,
            name: user.name.clone(),
            email: user.email.clone(),
            created_at: user.created_at.to_rfc3339(),
        };

        // 5. Serialize
        let mut buf = Vec::new();
        response_user.encode(&mut buf)
            .map_err(|e| Status::internal(format!("Encoding error: {}", e)))?;

        // 6. Add metadata
        let mut metadata = tonic::metadata::MetadataMap::new();
        metadata.insert("x-user-found", "true".parse().unwrap());

        Ok(GrpcResponseData {
            payload: Bytes::from(buf),
            metadata,
        })
    }

    async fn create_user(&self, request: GrpcRequestData) -> GrpcHandlerResult {
        // 1. Deserialize request
        use prost::Message;
        let req = userservice::CreateUserRequest::decode(request.payload)
            .map_err(|e| Status::invalid_argument(format!("Invalid request: {}", e)))?;

        // 2. Validate input
        if req.name.is_empty() || req.email.is_empty() {
            return Err(Status::invalid_argument("Name and email are required"));
        }

        // 3. Check authorization from metadata
        let auth_token = request.metadata
            .get("authorization")
            .and_then(|v| v.to_str().ok());

        if auth_token.is_none() {
            return Err(Status::unauthenticated("Authentication required"));
        }

        // 4. Business logic
        let user = self.user_repository.create(&req.name, &req.email).await
            .map_err(|e| Status::internal(format!("Create failed: {}", e)))?;

        // 5. Build response
        let response_user = userservice::User {
            id: user.id,
            name: user.name.clone(),
            email: user.email.clone(),
            created_at: chrono::Utc::now().to_rfc3339(),
        };

        // 6. Serialize
        let mut buf = Vec::new();
        response_user.encode(&mut buf)
            .map_err(|e| Status::internal(format!("Encoding error: {}", e)))?;

        // 7. Add metadata
        let mut metadata = tonic::metadata::MetadataMap::new();
        metadata.insert("x-user-id", user.id.to_string().parse().unwrap());
        metadata.insert("x-created", "true".parse().unwrap());

        Ok(GrpcResponseData {
            payload: Bytes::from(buf),
            metadata,
        })
    }
}

impl GrpcHandler for UserServiceHandler {
    fn call(&self, request: GrpcRequestData) -> Pin<Box<dyn Future<Output = GrpcHandlerResult> + Send>> {
        Box::pin(async move {
            match request.method_name.as_str() {
                "GetUser" => self.get_user(request).await,
                "CreateUser" => self.create_user(request).await,
                _ => Err(Status::unimplemented(format!("Unknown method: {}", request.method_name))),
            }
        })
    }

    fn service_name(&self) -> &'static str {
        "userservice.UserService"
    }
}
```

## Key Patterns

- **Async/await**: Handlers return `Pin<Box<dyn Future>>`
- **prost**: Uses `.decode()` and `.encode()` for protobuf
- **Error handling**: Return `tonic::Status` directly
- **Zero-copy**: Uses `Bytes` for efficient payload handling
- **Type safety**: Full compile-time type checking
- **Arc**: Shared ownership for thread-safe repository access

## Registration

```rust
use spikard_http::grpc::GrpcServiceRegistry;
use std::sync::Arc;

// Create handler
let user_repository = Arc::new(UserRepositoryImpl::new());
let handler = Arc::new(UserServiceHandler::new(user_repository));

// Register with gRPC runtime
let mut registry = GrpcServiceRegistry::new();
registry.register(handler);

// Runtime ready to serve
```
