<?php

declare(strict_types=1);

namespace E2E\Php;

use Spikard\App;
use Spikard\Handlers\HandlerInterface;
use Spikard\Http\Request;
use Spikard\Http\Response;

/**
 * Generated App factory for PHP e2e tests.
 */
final class AppFactory
{
    public static function create_sse_notifications_1(): App
    {
        $app = new App();
        $app = $app->addSse('/notifications', new SseProducer1());
        return $app;
    }

    public static function create_sse_notifications_2(): App
    {
        $app = new App();
        $app = $app->addSse('/notifications', new SseProducer2());
        return $app;
    }

    public static function create_sse_notifications_3(): App
    {
        $app = new App();
        $app = $app->addSse('/notifications', new SseProducer3());
        return $app;
    }

    public static function create_sse_notifications_4(): App
    {
        $app = new App();
        $app = $app->addSse('/notifications', new SseProducer4());
        return $app;
    }

    public static function create_websocket_systemalert_1(): App
    {
        $app = new App();
        $app = $app->addWebSocket('systemAlert', new WebSocketHandler1());
        return $app;
    }

    public static function create_websocket_chat_2(): App
    {
        $app = new App();
        $app = $app->addWebSocket('/chat', new WebSocketHandler2());
        return $app;
    }

    public static function create_websocket_chatack_3(): App
    {
        $app = new App();
        $app = $app->addWebSocket('chatAck', new WebSocketHandler3());
        return $app;
    }

    public static function create_websocket_chat_4(): App
    {
        $app = new App();
        $app = $app->addWebSocket('/chat', new WebSocketHandler4());
        return $app;
    }

    public static function create_websocket_chat_5(): App
    {
        $app = new App();
        $app = $app->addWebSocket('/chat', new WebSocketHandler5());
        return $app;
    }

    public static function create_websocket_usernotification_6(): App
    {
        $app = new App();
        $app = $app->addWebSocket('userNotification', new WebSocketHandler6());
        return $app;
    }

    public static function create_websocket_statusupdate_7(): App
    {
        $app = new App();
        $app = $app->addWebSocket('statusUpdate', new WebSocketHandler7());
        return $app;
    }

    public static function create_auth_api_key_authentication_invalid_key_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerauth_1());
        return $app;
    }

    public static function create_auth_api_key_authentication_missing_header_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerauth_2());
        return $app;
    }

    public static function create_auth_api_key_authentication_valid_key_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerauth_3());
        return $app;
    }

    public static function create_auth_api_key_in_query_parameter_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerauth_4());
        return $app;
    }

    public static function create_auth_api_key_rotation_old_key_still_valid_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerauth_5());
        return $app;
    }

    public static function create_auth_api_key_with_custom_header_name_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerauth_6());
        return $app;
    }

    public static function create_auth_bearer_token_without_prefix_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/protected', new Handlerauth_7());
        return $app;
    }

    public static function create_auth_jwt_authentication_expired_token_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected/user', new Handlerauth_8());
        return $app;
    }

    public static function create_auth_jwt_authentication_invalid_audience_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected/user', new Handlerauth_9());
        return $app;
    }

    public static function create_auth_jwt_authentication_invalid_signature_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected/user', new Handlerauth_10());
        return $app;
    }

    public static function create_auth_jwt_authentication_missing_authorization_header_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected/user', new Handlerauth_11());
        return $app;
    }

    public static function create_auth_jwt_authentication_valid_token_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected/user', new Handlerauth_12());
        return $app;
    }

    public static function create_auth_jwt_invalid_issuer_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/protected', new Handlerauth_13());
        return $app;
    }

    public static function create_auth_jwt_malformed_token_format_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/protected', new Handlerauth_14());
        return $app;
    }

    public static function create_auth_jwt_missing_required_custom_claims_15(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/admin', new Handlerauth_15());
        return $app;
    }

    public static function create_auth_jwt_not_before_claim_in_future_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/protected', new Handlerauth_16());
        return $app;
    }

    public static function create_auth_jwt_with_multiple_audiences_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/protected', new Handlerauth_17());
        return $app;
    }

    public static function create_auth_multiple_authentication_schemes_jwt_precedence_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerauth_18());
        return $app;
    }

    public static function create_background_background_event_logging_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/background/events', new Handlerbackground_1());
        return $app;
    }

    public static function create_background_background_event_logging_second_payload_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/background/events', new Handlerbackground_2());
        return $app;
    }

    public static function create_body_limits_body_over_limit_returns_413_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/body-limit/over', new Handlerbody_limits_1());
        return $app;
    }

    public static function create_body_limits_body_under_limit_succeeds_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/body-limit/under', new Handlerbody_limits_2());
        return $app;
    }

    public static function create_compression_compression_gzip_applied_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/compression/gzip', new Handlercompression_1());
        return $app;
    }

    public static function create_compression_compression_payload_below_min_size_is_not_compressed_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/compression/skip', new Handlercompression_2());
        return $app;
    }

    public static function create_content_types_13_json_with_charset_utf16_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlercontent_types_1());
        return $app;
    }

    public static function create_content_types_14_content_type_case_insensitive_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlercontent_types_2());
        return $app;
    }

    public static function create_content_types_15_multipart_boundary_required_3(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlercontent_types_3());
        return $app;
    }

    public static function create_content_types_16_text_plain_not_accepted_4(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlercontent_types_4());
        return $app;
    }

    public static function create_content_types_17_vendor_json_accepted_5(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/api/v1/resource', new Handlercontent_types_5());
        return $app;
    }

    public static function create_content_types_18_content_type_with_multiple_params_6(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlercontent_types_6());
        return $app;
    }

    public static function create_content_types_19_missing_content_type_default_json_7(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlercontent_types_7());
        return $app;
    }

    public static function create_content_types_20_content_length_mismatch_8(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlercontent_types_8());
        return $app;
    }

    public static function create_content_types_415_unsupported_media_type_9(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlercontent_types_9());
        return $app;
    }

    public static function create_content_types_binary_response_application_octet_stream_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/download/file.bin', new Handlercontent_types_10());
        return $app;
    }

    public static function create_content_types_csv_response_text_csv_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/export/data.csv', new Handlercontent_types_11());
        return $app;
    }

    public static function create_content_types_content_negotiation_accept_header_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/accept-test/1', new Handlercontent_types_12());
        return $app;
    }

    public static function create_content_types_html_response_text_html_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/html', new Handlercontent_types_13());
        return $app;
    }

    public static function create_content_types_jpeg_image_response_image_jpeg_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/images/photo.jpg', new Handlercontent_types_14());
        return $app;
    }

    public static function create_content_types_json_response_application_json_15(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/json', new Handlercontent_types_15());
        return $app;
    }

    public static function create_content_types_json_with_utf_8_charset_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/unicode', new Handlercontent_types_16());
        return $app;
    }

    public static function create_content_types_pdf_response_application_pdf_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/download/document.pdf', new Handlercontent_types_17());
        return $app;
    }

    public static function create_content_types_png_image_response_image_png_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/images/logo.png', new Handlercontent_types_18());
        return $app;
    }

    public static function create_content_types_plain_text_response_text_plain_19(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/text', new Handlercontent_types_19());
        return $app;
    }

    public static function create_content_types_xml_response_application_xml_20(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/xml', new Handlercontent_types_20());
        return $app;
    }

    public static function create_cookies_24_cookie_samesite_strict_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/secure', new Handlercookies_1());
        return $app;
    }

    public static function create_cookies_25_cookie_samesite_lax_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/data', new Handlercookies_2());
        return $app;
    }

    public static function create_cookies_26_cookie_secure_flag_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/secure', new Handlercookies_3());
        return $app;
    }

    public static function create_cookies_27_cookie_httponly_flag_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/secure', new Handlercookies_4());
        return $app;
    }

    public static function create_cookies_apikey_cookie_authentication_missing_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me/auth', new Handlercookies_5());
        return $app;
    }

    public static function create_cookies_apikey_cookie_authentication_success_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlercookies_6());
        return $app;
    }

    public static function create_cookies_cookie_regex_pattern_validation_fail_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/cookies/pattern', new Handlercookies_7());
        return $app;
    }

    public static function create_cookies_cookie_regex_pattern_validation_success_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/cookies/pattern', new Handlercookies_8());
        return $app;
    }

    public static function create_cookies_cookie_validation_max_length_constraint_fail_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/cookies/validated', new Handlercookies_9());
        return $app;
    }

    public static function create_cookies_cookie_validation_min_length_constraint_success_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/cookies/min-length', new Handlercookies_10());
        return $app;
    }

    public static function create_cookies_cookie_validation_min_length_failure_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlercookies_11());
        return $app;
    }

    public static function create_cookies_multiple_cookies_success_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlercookies_12());
        return $app;
    }

    public static function create_cookies_optional_apikey_cookie_missing_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlercookies_13());
        return $app;
    }

    public static function create_cookies_optional_cookie_parameter_missing_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlercookies_14());
        return $app;
    }

    public static function create_cookies_optional_cookie_parameter_success_15(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlercookies_15());
        return $app;
    }

    public static function create_cookies_required_cookie_missing_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/cookies', new Handlercookies_16());
        return $app;
    }

    public static function create_cookies_response_delete_cookie_17(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/delete', new Handlercookies_17());
        return $app;
    }

    public static function create_cookies_response_multiple_cookies_18(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/multiple', new Handlercookies_18());
        return $app;
    }

    public static function create_cookies_response_session_cookie_no_max_age_19(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/session', new Handlercookies_19());
        return $app;
    }

    public static function create_cookies_response_cookie_with_samesite_lax_20(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/samesite-lax', new Handlercookies_20());
        return $app;
    }

    public static function create_cookies_response_cookie_with_samesite_none_21(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/samesite-none', new Handlercookies_21());
        return $app;
    }

    public static function create_cookies_response_cookie_with_samesite_strict_22(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/samesite-strict', new Handlercookies_22());
        return $app;
    }

    public static function create_cookies_response_cookie_with_attributes_23(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/cookie/set', new Handlercookies_23());
        return $app;
    }

    public static function create_cookies_response_cookie_with_domain_attribute_24(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/set-with-domain', new Handlercookies_24());
        return $app;
    }

    public static function create_cookies_response_cookie_with_path_attribute_25(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookies/set-with-path', new Handlercookies_25());
        return $app;
    }

    public static function create_cookies_response_set_cookie_basic_26(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/cookie/', new Handlercookies_26());
        return $app;
    }

    public static function create_cors_06_cors_preflight_method_not_allowed_1(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/api/data', new Handlercors_1());
        return $app;
    }

    public static function create_cors_07_cors_preflight_header_not_allowed_2(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/api/data', new Handlercors_2());
        return $app;
    }

    public static function create_cors_08_cors_max_age_3(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/api/data', new Handlercors_3());
        return $app;
    }

    public static function create_cors_09_cors_expose_headers_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlercors_4());
        return $app;
    }

    public static function create_cors_10_cors_origin_null_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlercors_5());
        return $app;
    }

    public static function create_cors_cors_private_network_access_6(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/api/local-resource', new Handlercors_6());
        return $app;
    }

    public static function create_cors_cors_vary_header_for_proper_caching_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/cached-resource', new Handlercors_7());
        return $app;
    }

    public static function create_cors_cors_multiple_allowed_origins_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlercors_8());
        return $app;
    }

    public static function create_cors_cors_origin_case_sensitivity_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlercors_9());
        return $app;
    }

    public static function create_cors_cors_preflight_for_delete_method_10(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/api/resource/456', new Handlercors_10());
        return $app;
    }

    public static function create_cors_cors_preflight_for_put_method_11(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/api/resource/123', new Handlercors_11());
        return $app;
    }

    public static function create_cors_cors_preflight_request_12(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/items/', new Handlercors_12());
        return $app;
    }

    public static function create_cors_cors_regex_pattern_matching_for_origins_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlercors_13());
        return $app;
    }

    public static function create_cors_cors_request_blocked_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlercors_14());
        return $app;
    }

    public static function create_cors_cors_safelisted_headers_without_preflight_15(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/api/form', new Handlercors_15());
        return $app;
    }

    public static function create_cors_cors_wildcard_origin_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/public/data', new Handlercors_16());
        return $app;
    }

    public static function create_cors_cors_with_credentials_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/user/profile', new Handlercors_17());
        return $app;
    }

    public static function create_cors_simple_cors_request_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlercors_18());
        return $app;
    }

    public static function create_di_async_factory_dependency_success_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/db-status', new Handlerdi_1());
        return $app;
    }

    public static function create_di_circular_dependency_detection_error_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/circular', new Handlerdi_2());
        return $app;
    }

    public static function create_di_dependency_injection_in_lifecycle_hooks_success_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/hook-di-test', new Handlerdi_3());
        return $app;
    }

    public static function create_di_factory_dependency_success_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/timestamp', new Handlerdi_4());
        return $app;
    }

    public static function create_di_missing_dependency_error_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/missing-dep', new Handlerdi_5());
        return $app;
    }

    public static function create_di_mixed_singleton_and_per_request_caching_success_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/mixed-caching', new Handlerdi_6());
        return $app;
    }

    public static function create_di_multiple_dependencies_with_cleanup_success_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/multi-cleanup-test', new Handlerdi_7());
        return $app;
    }

    public static function create_di_nested_dependencies_3_levels_success_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/auth-status', new Handlerdi_8());
        return $app;
    }

    public static function create_di_node_js_object_destructuring_injection_success_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/node-destructure', new Handlerdi_9());
        return $app;
    }

    public static function create_di_per_request_dependency_caching_success_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/request-id', new Handlerdi_10());
        return $app;
    }

    public static function create_di_python_parameter_name_based_injection_success_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/python-name-inject', new Handlerdi_11());
        return $app;
    }

    public static function create_di_python_type_annotation_based_injection_success_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/python-type-inject', new Handlerdi_12());
        return $app;
    }

    public static function create_di_resource_cleanup_after_request_success_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/cleanup-test', new Handlerdi_13());
        return $app;
    }

    public static function create_di_route_level_dependency_override_success_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/override-test', new Handlerdi_14());
        return $app;
    }

    public static function create_di_ruby_keyword_argument_injection_success_15(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/ruby-kwargs', new Handlerdi_15());
        return $app;
    }

    public static function create_di_singleton_dependency_caching_success_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/app-counter', new Handlerdi_16());
        return $app;
    }

    public static function create_di_type_mismatch_in_dependency_resolution_error_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/type-mismatch', new Handlerdi_17());
        return $app;
    }

    public static function create_di_value_dependency_injection_success_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/config', new Handlerdi_18());
        return $app;
    }

    public static function create_edge_cases_11_utf8_query_parameter_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/search', new Handleredge_cases_1());
        return $app;
    }

    public static function create_edge_cases_12_percent_encoded_special_chars_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/search', new Handleredge_cases_2());
        return $app;
    }

    public static function create_edge_cases_13_empty_string_query_param_preserved_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handleredge_cases_3());
        return $app;
    }

    public static function create_edge_cases_14_large_integer_boundary_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handleredge_cases_4());
        return $app;
    }

    public static function create_edge_cases_15_float_precision_preservation_5(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/calculate', new Handleredge_cases_5());
        return $app;
    }

    public static function create_edge_cases_16_negative_zero_handling_6(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handleredge_cases_6());
        return $app;
    }

    public static function create_edge_cases_17_extremely_long_string_7(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/text', new Handleredge_cases_7());
        return $app;
    }

    public static function create_edge_cases_18_unicode_normalization_8(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handleredge_cases_8());
        return $app;
    }

    public static function create_edge_cases_19_emoji_in_strings_9(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/messages', new Handleredge_cases_9());
        return $app;
    }

    public static function create_edge_cases_20_null_byte_in_string_10(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files', new Handleredge_cases_10());
        return $app;
    }

    public static function create_edge_cases_21_scientific_notation_number_11(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/calculate', new Handleredge_cases_11());
        return $app;
    }

    public static function create_edge_cases_22_leading_zeros_integer_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/data', new Handleredge_cases_12());
        return $app;
    }

    public static function create_edge_cases_23_deeply_nested_json_limit_13(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handleredge_cases_13());
        return $app;
    }

    public static function create_edge_cases_24_array_with_holes_14(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items', new Handleredge_cases_14());
        return $app;
    }

    public static function create_edge_cases_deeply_nested_structure_10_levels_15(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/nested/', new Handleredge_cases_15());
        return $app;
    }

    public static function create_edge_cases_empty_and_null_value_handling_16(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/nulls/', new Handleredge_cases_16());
        return $app;
    }

    public static function create_edge_cases_float_precision_and_rounding_17(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/calculations/', new Handleredge_cases_17());
        return $app;
    }

    public static function create_edge_cases_large_integer_boundary_values_18(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/numbers/', new Handleredge_cases_18());
        return $app;
    }

    public static function create_edge_cases_special_string_values_and_escaping_19(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/strings/', new Handleredge_cases_19());
        return $app;
    }

    public static function create_edge_cases_unicode_and_emoji_handling_20(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handleredge_cases_20());
        return $app;
    }

    public static function create_headers_30_bearer_token_format_valid_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected', new Handlerheaders_1());
        return $app;
    }

    public static function create_headers_31_bearer_token_format_invalid_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected', new Handlerheaders_2());
        return $app;
    }

    public static function create_headers_32_bearer_token_missing_prefix_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/protected', new Handlerheaders_3());
        return $app;
    }

    public static function create_headers_33_api_key_header_valid_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerheaders_4());
        return $app;
    }

    public static function create_headers_34_api_key_header_invalid_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/data', new Handlerheaders_5());
        return $app;
    }

    public static function create_headers_accept_header_json_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/accept', new Handlerheaders_6());
        return $app;
    }

    public static function create_headers_accept_encoding_header_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/accept-encoding', new Handlerheaders_7());
        return $app;
    }

    public static function create_headers_accept_language_header_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/accept-language', new Handlerheaders_8());
        return $app;
    }

    public static function create_headers_authorization_header_missing_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerheaders_9());
        return $app;
    }

    public static function create_headers_authorization_header_success_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerheaders_10());
        return $app;
    }

    public static function create_headers_authorization_header_wrong_scheme_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerheaders_11());
        return $app;
    }

    public static function create_headers_basic_authentication_success_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/basic-auth', new Handlerheaders_12());
        return $app;
    }

    public static function create_headers_bearer_token_authentication_missing_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/bearer-auth', new Handlerheaders_13());
        return $app;
    }

    public static function create_headers_bearer_token_authentication_success_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/bearer-auth', new Handlerheaders_14());
        return $app;
    }

    public static function create_headers_content_type_header_application_json_15(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/content-type', new Handlerheaders_15());
        return $app;
    }

    public static function create_headers_header_case_insensitivity_access_16(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/echo', new Handlerheaders_16());
        return $app;
    }

    public static function create_headers_header_regex_validation_fail_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/pattern', new Handlerheaders_17());
        return $app;
    }

    public static function create_headers_header_regex_validation_success_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/pattern', new Handlerheaders_18());
        return $app;
    }

    public static function create_headers_header_validation_max_length_constraint_fail_19(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/max-length', new Handlerheaders_19());
        return $app;
    }

    public static function create_headers_header_validation_min_length_constraint_20(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/validated', new Handlerheaders_20());
        return $app;
    }

    public static function create_headers_header_with_underscore_conversion_explicit_21(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/underscore', new Handlerheaders_21());
        return $app;
    }

    public static function create_headers_host_header_22(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/host', new Handlerheaders_22());
        return $app;
    }

    public static function create_headers_multiple_custom_headers_23(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/multiple', new Handlerheaders_23());
        return $app;
    }

    public static function create_headers_multiple_header_values_x_token_24(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlerheaders_24());
        return $app;
    }

    public static function create_headers_optional_header_with_none_default_missing_25(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlerheaders_25());
        return $app;
    }

    public static function create_headers_origin_header_26(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/origin', new Handlerheaders_26());
        return $app;
    }

    public static function create_headers_referer_header_27(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/headers/referer', new Handlerheaders_27());
        return $app;
    }

    public static function create_headers_user_agent_header_custom_value_28(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlerheaders_28());
        return $app;
    }

    public static function create_headers_user_agent_header_default_value_29(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlerheaders_29());
        return $app;
    }

    public static function create_headers_x_api_key_optional_header_missing_30(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerheaders_30());
        return $app;
    }

    public static function create_headers_x_api_key_optional_header_success_31(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerheaders_31());
        return $app;
    }

    public static function create_headers_x_api_key_required_header_missing_32(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerheaders_32());
        return $app;
    }

    public static function create_headers_x_api_key_required_header_success_33(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerheaders_33());
        return $app;
    }

    public static function create_http_methods_delete_remove_resource_1(): App
    {
        $app = new App();
        $app = $app->addRoute('DELETE', '/items/1', new Handlerhttp_methods_1());
        return $app;
    }

    public static function create_http_methods_delete_resource_not_found_2(): App
    {
        $app = new App();
        $app = $app->addRoute('DELETE', '/items/999', new Handlerhttp_methods_2());
        return $app;
    }

    public static function create_http_methods_delete_with_response_body_3(): App
    {
        $app = new App();
        $app = $app->addRoute('DELETE', '/items/1', new Handlerhttp_methods_3());
        return $app;
    }

    public static function create_http_methods_head_get_metadata_without_body_4(): App
    {
        $app = new App();
        $app = $app->addRoute('HEAD', '/items/1', new Handlerhttp_methods_4());
        return $app;
    }

    public static function create_http_methods_options_cors_preflight_request_5(): App
    {
        $app = new App();
        $app = $app->addRoute('OPTIONS', '/items/', new Handlerhttp_methods_5());
        return $app;
    }

    public static function create_http_methods_patch_partial_update_6(): App
    {
        $app = new App();
        $app = $app->addRoute('PATCH', '/items/1', new Handlerhttp_methods_6());
        return $app;
    }

    public static function create_http_methods_patch_update_multiple_fields_7(): App
    {
        $app = new App();
        $app = $app->addRoute('PATCH', '/items/1', new Handlerhttp_methods_7());
        return $app;
    }

    public static function create_http_methods_put_complete_resource_replacement_8(): App
    {
        $app = new App();
        $app = $app->addRoute('PUT', '/items/1', new Handlerhttp_methods_8());
        return $app;
    }

    public static function create_http_methods_put_create_resource_if_doesn_t_exist_9(): App
    {
        $app = new App();
        $app = $app->addRoute('PUT', '/items/999', new Handlerhttp_methods_9());
        return $app;
    }

    public static function create_http_methods_put_idempotent_operation_10(): App
    {
        $app = new App();
        $app = $app->addRoute('PUT', '/items/1', new Handlerhttp_methods_10());
        return $app;
    }

    public static function create_http_methods_put_missing_required_field_11(): App
    {
        $app = new App();
        $app = $app->addRoute('PUT', '/items/1', new Handlerhttp_methods_11());
        return $app;
    }

    public static function create_http_methods_put_validation_error_12(): App
    {
        $app = new App();
        $app = $app->addRoute('PUT', '/items/1', new Handlerhttp_methods_12());
        return $app;
    }

    public static function create_json_bodies_29_nested_object_validation_success_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlerjson_bodies_1());
        return $app;
    }

    public static function create_json_bodies_30_nested_object_missing_field_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlerjson_bodies_2());
        return $app;
    }

    public static function create_json_bodies_31_nullable_property_null_value_3(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlerjson_bodies_3());
        return $app;
    }

    public static function create_json_bodies_32_schema_ref_definitions_4(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/products', new Handlerjson_bodies_4());
        return $app;
    }

    public static function create_json_bodies_33_allof_schema_composition_5(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items', new Handlerjson_bodies_5());
        return $app;
    }

    public static function create_json_bodies_34_additional_properties_false_6(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlerjson_bodies_6());
        return $app;
    }

    public static function create_json_bodies_35_oneof_schema_success_7(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/payment', new Handlerjson_bodies_7());
        return $app;
    }

    public static function create_json_bodies_36_oneof_schema_multiple_match_failure_8(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/payment', new Handlerjson_bodies_8());
        return $app;
    }

    public static function create_json_bodies_37_oneof_schema_no_match_failure_9(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/payment', new Handlerjson_bodies_9());
        return $app;
    }

    public static function create_json_bodies_38_anyof_schema_success_10(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/contact', new Handlerjson_bodies_10());
        return $app;
    }

    public static function create_json_bodies_39_anyof_schema_multiple_match_success_11(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/contact', new Handlerjson_bodies_11());
        return $app;
    }

    public static function create_json_bodies_40_anyof_schema_failure_12(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/contact', new Handlerjson_bodies_12());
        return $app;
    }

    public static function create_json_bodies_41_not_schema_success_13(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlerjson_bodies_13());
        return $app;
    }

    public static function create_json_bodies_42_not_schema_failure_14(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlerjson_bodies_14());
        return $app;
    }

    public static function create_json_bodies_43_const_validation_success_15(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/api/v1/data', new Handlerjson_bodies_15());
        return $app;
    }

    public static function create_json_bodies_44_const_validation_failure_16(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/api/v1/data', new Handlerjson_bodies_16());
        return $app;
    }

    public static function create_json_bodies_45_minproperties_validation_success_17(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/config', new Handlerjson_bodies_17());
        return $app;
    }

    public static function create_json_bodies_46_minproperties_validation_failure_18(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/config', new Handlerjson_bodies_18());
        return $app;
    }

    public static function create_json_bodies_47_maxproperties_validation_failure_19(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/config', new Handlerjson_bodies_19());
        return $app;
    }

    public static function create_json_bodies_48_dependencies_validation_success_20(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/billing', new Handlerjson_bodies_20());
        return $app;
    }

    public static function create_json_bodies_49_dependencies_validation_failure_21(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/billing', new Handlerjson_bodies_21());
        return $app;
    }

    public static function create_json_bodies_50_deep_nesting_4_levels_22(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlerjson_bodies_22());
        return $app;
    }

    public static function create_json_bodies_array_of_objects_success_23(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/list', new Handlerjson_bodies_23());
        return $app;
    }

    public static function create_json_bodies_array_of_primitive_values_24(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_24());
        return $app;
    }

    public static function create_json_bodies_body_with_query_parameters_25(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_25());
        return $app;
    }

    public static function create_json_bodies_boolean_field_success_26(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_26());
        return $app;
    }

    public static function create_json_bodies_date_field_success_27(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/events/', new Handlerjson_bodies_27());
        return $app;
    }

    public static function create_json_bodies_datetime_field_success_28(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/events/', new Handlerjson_bodies_28());
        return $app;
    }

    public static function create_json_bodies_deeply_nested_objects_29(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/nested', new Handlerjson_bodies_29());
        return $app;
    }

    public static function create_json_bodies_empty_json_object_30(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/optional-all', new Handlerjson_bodies_30());
        return $app;
    }

    public static function create_json_bodies_empty_array_validation_fail_31(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/list-validated', new Handlerjson_bodies_31());
        return $app;
    }

    public static function create_json_bodies_enum_field_invalid_value_32(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_32());
        return $app;
    }

    public static function create_json_bodies_enum_field_success_33(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_33());
        return $app;
    }

    public static function create_json_bodies_extra_fields_ignored_no_additionalproperties_34(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_34());
        return $app;
    }

    public static function create_json_bodies_field_type_validation_invalid_type_35(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_35());
        return $app;
    }

    public static function create_json_bodies_nested_object_success_36(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/nested', new Handlerjson_bodies_36());
        return $app;
    }

    public static function create_json_bodies_null_value_for_optional_field_37(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_37());
        return $app;
    }

    public static function create_json_bodies_numeric_ge_validation_fail_38(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/validated', new Handlerjson_bodies_38());
        return $app;
    }

    public static function create_json_bodies_numeric_le_validation_success_39(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/validated', new Handlerjson_bodies_39());
        return $app;
    }

    public static function create_json_bodies_optional_fields_omitted_40(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_40());
        return $app;
    }

    public static function create_json_bodies_patch_partial_update_41(): App
    {
        $app = new App();
        $app = $app->addRoute('PATCH', '/items/1', new Handlerjson_bodies_41());
        return $app;
    }

    public static function create_json_bodies_required_field_missing_validation_error_42(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_42());
        return $app;
    }

    public static function create_json_bodies_simple_json_object_success_43(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_43());
        return $app;
    }

    public static function create_json_bodies_string_max_length_validation_fail_44(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/validated', new Handlerjson_bodies_44());
        return $app;
    }

    public static function create_json_bodies_string_min_length_validation_fail_45(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/validated', new Handlerjson_bodies_45());
        return $app;
    }

    public static function create_json_bodies_string_pattern_validation_fail_46(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/validated', new Handlerjson_bodies_46());
        return $app;
    }

    public static function create_json_bodies_string_pattern_validation_success_47(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/validated', new Handlerjson_bodies_47());
        return $app;
    }

    public static function create_json_bodies_uuid_field_invalid_format_48(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_48());
        return $app;
    }

    public static function create_json_bodies_uuid_field_success_49(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerjson_bodies_49());
        return $app;
    }

    public static function create_lifecycle_hooks_hook_execution_order_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/test-hook-order', new Handlerlifecycle_hooks_1());
        return $app;
    }

    public static function create_lifecycle_hooks_multiple_hooks_all_phases_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/api/full-lifecycle', new Handlerlifecycle_hooks_2());
        return $app;
    }

    public static function create_lifecycle_hooks_onerror_error_logging_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/test-error', new Handlerlifecycle_hooks_3());
        return $app;
    }

    public static function create_lifecycle_hooks_onrequest_request_logging_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/test-on-request', new Handlerlifecycle_hooks_4());
        return $app;
    }

    public static function create_lifecycle_hooks_onresponse_response_timing_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/test-timing', new Handlerlifecycle_hooks_5());
        return $app;
    }

    public static function create_lifecycle_hooks_onresponse_security_headers_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/test-security-headers', new Handlerlifecycle_hooks_6());
        return $app;
    }

    public static function create_lifecycle_hooks_prehandler_authentication_failed_short_circuit_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/protected-resource-fail', new Handlerlifecycle_hooks_7());
        return $app;
    }

    public static function create_lifecycle_hooks_prehandler_authentication_success_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/protected-resource', new Handlerlifecycle_hooks_8());
        return $app;
    }

    public static function create_lifecycle_hooks_prehandler_authorization_check_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/admin-only', new Handlerlifecycle_hooks_9());
        return $app;
    }

    public static function create_lifecycle_hooks_prehandler_authorization_forbidden_short_circuit_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/admin-only-forbidden', new Handlerlifecycle_hooks_10());
        return $app;
    }

    public static function create_lifecycle_hooks_prevalidation_rate_limit_exceeded_short_circuit_11(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/api/test-rate-limit-exceeded', new Handlerlifecycle_hooks_11());
        return $app;
    }

    public static function create_lifecycle_hooks_prevalidation_rate_limiting_12(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/api/test-rate-limit', new Handlerlifecycle_hooks_12());
        return $app;
    }

    public static function create_multipart_17_file_magic_number_png_success_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlermultipart_1());
        return $app;
    }

    public static function create_multipart_18_file_magic_number_jpeg_success_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlermultipart_2());
        return $app;
    }

    public static function create_multipart_19_file_mime_spoofing_png_as_jpeg_3(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlermultipart_3());
        return $app;
    }

    public static function create_multipart_20_file_mime_spoofing_jpeg_as_png_4(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlermultipart_4());
        return $app;
    }

    public static function create_multipart_21_file_pdf_magic_number_success_5(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlermultipart_5());
        return $app;
    }

    public static function create_multipart_22_file_empty_buffer_6(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlermultipart_6());
        return $app;
    }

    public static function create_multipart_content_type_validation_invalid_type_7(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/images-only', new Handlermultipart_7());
        return $app;
    }

    public static function create_multipart_empty_file_upload_8(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/upload', new Handlermultipart_8());
        return $app;
    }

    public static function create_multipart_file_list_upload_array_of_files_9(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/list', new Handlermultipart_9());
        return $app;
    }

    public static function create_multipart_file_size_validation_too_large_10(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/validated', new Handlermultipart_10());
        return $app;
    }

    public static function create_multipart_file_upload_with_custom_headers_11(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/', new Handlermultipart_11());
        return $app;
    }

    public static function create_multipart_file_upload_without_filename_12(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/', new Handlermultipart_12());
        return $app;
    }

    public static function create_multipart_form_data_without_files_13(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/', new Handlermultipart_13());
        return $app;
    }

    public static function create_multipart_image_file_upload_14(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/image', new Handlermultipart_14());
        return $app;
    }

    public static function create_multipart_mixed_files_and_form_data_15(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/', new Handlermultipart_15());
        return $app;
    }

    public static function create_multipart_multiple_file_uploads_16(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/', new Handlermultipart_16());
        return $app;
    }

    public static function create_multipart_multiple_values_for_same_field_name_17(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/', new Handlermultipart_17());
        return $app;
    }

    public static function create_multipart_optional_file_upload_missing_18(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/optional', new Handlermultipart_18());
        return $app;
    }

    public static function create_multipart_optional_file_upload_provided_19(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/optional', new Handlermultipart_19());
        return $app;
    }

    public static function create_multipart_pdf_file_upload_20(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/document', new Handlermultipart_20());
        return $app;
    }

    public static function create_multipart_required_file_upload_missing_21(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/files/required', new Handlermultipart_21());
        return $app;
    }

    public static function create_multipart_simple_file_upload_22(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/', new Handlermultipart_22());
        return $app;
    }

    public static function create_path_params_20_uuid_v3_path_param_success_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/e8b5a51d-11c8-3310-a6ab-367563f20686', new Handlerpath_params_1());
        return $app;
    }

    public static function create_path_params_21_uuid_v5_path_param_success_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/630eb68f-e0fa-5ecc-887a-7c7a62614681', new Handlerpath_params_2());
        return $app;
    }

    public static function create_path_params_24_date_format_path_param_success_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/events/2025-10-30', new Handlerpath_params_3());
        return $app;
    }

    public static function create_path_params_25_date_format_invalid_failure_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/events/2025-13-45', new Handlerpath_params_4());
        return $app;
    }

    public static function create_path_params_27_datetime_format_path_param_success_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/bookings/2025-10-30T14:30:00Z', new Handlerpath_params_5());
        return $app;
    }

    public static function create_path_params_28_duration_format_path_param_success_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/delays/P1DT2H30M', new Handlerpath_params_6());
        return $app;
    }

    public static function create_path_params_29_decimal_path_param_success_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/prices/19.99', new Handlerpath_params_7());
        return $app;
    }

    public static function create_path_params_30_string_minlength_path_success_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/alice', new Handlerpath_params_8());
        return $app;
    }

    public static function create_path_params_31_string_minlength_path_failure_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/ab', new Handlerpath_params_9());
        return $app;
    }

    public static function create_path_params_32_string_maxlength_path_failure_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/this_username_is_way_too_long_to_be_valid', new Handlerpath_params_10());
        return $app;
    }

    public static function create_path_params_33_string_pattern_path_success_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/repos/spikard-labs/spikard-http', new Handlerpath_params_11());
        return $app;
    }

    public static function create_path_params_34_string_pattern_path_failure_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/repos/invalid@owner', new Handlerpath_params_12());
        return $app;
    }

    public static function create_path_params_35_negative_integer_path_param_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/offset/-100', new Handlerpath_params_13());
        return $app;
    }

    public static function create_path_params_boolean_path_parameter_true_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/bool/True', new Handlerpath_params_14());
        return $app;
    }

    public static function create_path_params_boolean_path_parameter_numeric_1_15(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/bool/1', new Handlerpath_params_15());
        return $app;
    }

    public static function create_path_params_date_path_parameter_success_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/date/2023-07-15', new Handlerpath_params_16());
        return $app;
    }

    public static function create_path_params_enum_path_parameter_invalid_value_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/models/foo', new Handlerpath_params_17());
        return $app;
    }

    public static function create_path_params_enum_path_parameter_success_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/models/alexnet', new Handlerpath_params_18());
        return $app;
    }

    public static function create_path_params_float_path_parameter_success_19(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/float/42.5', new Handlerpath_params_19());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_invalid_string_20(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/int/foobar', new Handlerpath_params_20());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_success_21(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/int/42', new Handlerpath_params_21());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_with_combined_lt_and_gt_constraints_success_22(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-lt-gt/2', new Handlerpath_params_22());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_with_ge_constraint_success_23(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-ge/3', new Handlerpath_params_23());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_with_gt_constraint_failure_24(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-gt/2', new Handlerpath_params_24());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_with_gt_constraint_success_25(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-gt/42', new Handlerpath_params_25());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_with_le_constraint_success_26(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-le/3', new Handlerpath_params_26());
        return $app;
    }

    public static function create_path_params_integer_path_parameter_with_lt_constraint_success_27(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-lt/2', new Handlerpath_params_27());
        return $app;
    }

    public static function create_path_params_multiple_path_parameters_success_28(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/1.0/1/abc/c892496f-b1fd-4b91-bdb8-b46f92df1716', new Handlerpath_params_28());
        return $app;
    }

    public static function create_path_params_path_parameter_type_syntax_invalid_uuid_29(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/type-syntax/items/not-a-uuid', new Handlerpath_params_29());
        return $app;
    }

    public static function create_path_params_path_parameter_type_syntax_with_override_30(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/type-syntax/items-count/50', new Handlerpath_params_30());
        return $app;
    }

    public static function create_path_params_path_parameter_with_type_syntax_uuid_31(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/type-syntax/items/550e8400-e29b-41d4-a716-446655440000', new Handlerpath_params_31());
        return $app;
    }

    public static function create_path_params_path_parameter_with_type_syntax_integer_32(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/type-syntax/users/42', new Handlerpath_params_32());
        return $app;
    }

    public static function create_path_params_path_type_parameter_file_path_33(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/files/home/johndoe/myfile.txt', new Handlerpath_params_33());
        return $app;
    }

    public static function create_path_params_string_path_parameter_success_34(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/str/foobar', new Handlerpath_params_34());
        return $app;
    }

    public static function create_path_params_string_path_parameter_with_max_length_failure_35(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-maxlength/foobar', new Handlerpath_params_35());
        return $app;
    }

    public static function create_path_params_string_path_parameter_with_min_length_failure_36(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/path/param-minlength/fo', new Handlerpath_params_36());
        return $app;
    }

    public static function create_path_params_uuid_path_parameter_success_37(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/ec38df32-ceda-4cfa-9b4a-1aeb94ad551a', new Handlerpath_params_37());
        return $app;
    }

    public static function create_query_params_42_negative_integer_query_param_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/negative', new Handlerquery_params_1());
        return $app;
    }

    public static function create_query_params_43_scientific_notation_float_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/stats', new Handlerquery_params_2());
        return $app;
    }

    public static function create_query_params_44_string_minlength_validation_success_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/search', new Handlerquery_params_3());
        return $app;
    }

    public static function create_query_params_45_string_minlength_validation_failure_4(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/search', new Handlerquery_params_4());
        return $app;
    }

    public static function create_query_params_46_string_maxlength_validation_failure_5(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/search', new Handlerquery_params_5());
        return $app;
    }

    public static function create_query_params_47_pattern_validation_email_success_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/subscribe', new Handlerquery_params_6());
        return $app;
    }

    public static function create_query_params_48_pattern_validation_email_failure_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/subscribe', new Handlerquery_params_7());
        return $app;
    }

    public static function create_query_params_49_integer_gt_constraint_success_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_8());
        return $app;
    }

    public static function create_query_params_50_integer_gt_constraint_failure_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_9());
        return $app;
    }

    public static function create_query_params_51_integer_ge_constraint_boundary_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_10());
        return $app;
    }

    public static function create_query_params_52_integer_le_constraint_boundary_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_11());
        return $app;
    }

    public static function create_query_params_53_integer_le_constraint_failure_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_12());
        return $app;
    }

    public static function create_query_params_54_array_minitems_constraint_success_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_13());
        return $app;
    }

    public static function create_query_params_55_array_minitems_constraint_failure_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_14());
        return $app;
    }

    public static function create_query_params_56_array_maxitems_constraint_failure_15(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_15());
        return $app;
    }

    public static function create_query_params_57_boolean_empty_string_coercion_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_16());
        return $app;
    }

    public static function create_query_params_58_format_email_success_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/subscribe', new Handlerquery_params_17());
        return $app;
    }

    public static function create_query_params_59_format_email_failure_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/subscribe', new Handlerquery_params_18());
        return $app;
    }

    public static function create_query_params_60_format_ipv4_success_19(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/network', new Handlerquery_params_19());
        return $app;
    }

    public static function create_query_params_61_format_ipv4_failure_20(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/network', new Handlerquery_params_20());
        return $app;
    }

    public static function create_query_params_62_format_ipv6_success_21(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/network/ipv6', new Handlerquery_params_21());
        return $app;
    }

    public static function create_query_params_63_format_uri_success_22(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/redirect', new Handlerquery_params_22());
        return $app;
    }

    public static function create_query_params_64_format_uri_failure_23(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/redirect', new Handlerquery_params_23());
        return $app;
    }

    public static function create_query_params_65_format_hostname_success_24(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/dns', new Handlerquery_params_24());
        return $app;
    }

    public static function create_query_params_66_multipleof_constraint_success_25(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_25());
        return $app;
    }

    public static function create_query_params_67_multipleof_constraint_failure_26(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_26());
        return $app;
    }

    public static function create_query_params_68_array_uniqueitems_success_27(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_27());
        return $app;
    }

    public static function create_query_params_69_array_uniqueitems_failure_28(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_28());
        return $app;
    }

    public static function create_query_params_70_array_separator_pipe_29(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_29());
        return $app;
    }

    public static function create_query_params_71_array_separator_semicolon_30(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items', new Handlerquery_params_30());
        return $app;
    }

    public static function create_query_params_72_array_separator_space_31(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/search', new Handlerquery_params_31());
        return $app;
    }

    public static function create_query_params_array_query_parameter_empty_array_32(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/list-default', new Handlerquery_params_32());
        return $app;
    }

    public static function create_query_params_array_query_parameter_single_value_33(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/list-default', new Handlerquery_params_33());
        return $app;
    }

    public static function create_query_params_boolean_query_parameter_numeric_1_34(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/bool', new Handlerquery_params_34());
        return $app;
    }

    public static function create_query_params_boolean_query_parameter_true_35(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/bool', new Handlerquery_params_35());
        return $app;
    }

    public static function create_query_params_date_query_parameter_success_36(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/date', new Handlerquery_params_36());
        return $app;
    }

    public static function create_query_params_datetime_query_parameter_success_37(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/datetime', new Handlerquery_params_37());
        return $app;
    }

    public static function create_query_params_enum_query_parameter_invalid_value_38(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/enum', new Handlerquery_params_38());
        return $app;
    }

    public static function create_query_params_enum_query_parameter_success_39(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/enum', new Handlerquery_params_39());
        return $app;
    }

    public static function create_query_params_float_query_param_with_ge_constraint_success_40(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/float-ge', new Handlerquery_params_40());
        return $app;
    }

    public static function create_query_params_integer_query_param_with_ge_constraint_boundary_41(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int-ge', new Handlerquery_params_41());
        return $app;
    }

    public static function create_query_params_integer_query_param_with_gt_constraint_valid_42(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int-gt', new Handlerquery_params_42());
        return $app;
    }

    public static function create_query_params_integer_query_param_with_le_constraint_boundary_43(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int-le', new Handlerquery_params_43());
        return $app;
    }

    public static function create_query_params_integer_query_param_with_lt_constraint_valid_44(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int-lt', new Handlerquery_params_44());
        return $app;
    }

    public static function create_query_params_integer_with_default_value_not_provided_45(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int/default', new Handlerquery_params_45());
        return $app;
    }

    public static function create_query_params_integer_with_default_value_override_46(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int/default', new Handlerquery_params_46());
        return $app;
    }

    public static function create_query_params_list_of_integers_multiple_values_47(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/list', new Handlerquery_params_47());
        return $app;
    }

    public static function create_query_params_list_of_strings_multiple_values_48(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlerquery_params_48());
        return $app;
    }

    public static function create_query_params_list_query_parameter_required_but_missing_49(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/list', new Handlerquery_params_49());
        return $app;
    }

    public static function create_query_params_list_with_default_empty_array_no_values_provided_50(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/list-default', new Handlerquery_params_50());
        return $app;
    }

    public static function create_query_params_multiple_query_parameters_with_different_types_51(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/multi-type', new Handlerquery_params_51());
        return $app;
    }

    public static function create_query_params_optional_integer_query_parameter_missing_52(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int/optional', new Handlerquery_params_52());
        return $app;
    }

    public static function create_query_params_optional_query_parameter_with_default_value_53(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/optional-default', new Handlerquery_params_53());
        return $app;
    }

    public static function create_query_params_optional_string_query_parameter_missing_54(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/optional', new Handlerquery_params_54());
        return $app;
    }

    public static function create_query_params_optional_string_query_parameter_provided_55(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/optional', new Handlerquery_params_55());
        return $app;
    }

    public static function create_query_params_query_parameter_with_url_encoded_space_56(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/basic', new Handlerquery_params_56());
        return $app;
    }

    public static function create_query_params_query_parameter_with_url_encoded_special_characters_57(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/basic', new Handlerquery_params_57());
        return $app;
    }

    public static function create_query_params_query_parameter_with_special_characters_url_encoding_58(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/test', new Handlerquery_params_58());
        return $app;
    }

    public static function create_query_params_required_integer_query_parameter_float_value_59(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int', new Handlerquery_params_59());
        return $app;
    }

    public static function create_query_params_required_integer_query_parameter_invalid_type_60(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int', new Handlerquery_params_60());
        return $app;
    }

    public static function create_query_params_required_integer_query_parameter_missing_61(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int', new Handlerquery_params_61());
        return $app;
    }

    public static function create_query_params_required_integer_query_parameter_success_62(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/int', new Handlerquery_params_62());
        return $app;
    }

    public static function create_query_params_required_string_query_parameter_missing_63(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query', new Handlerquery_params_63());
        return $app;
    }

    public static function create_query_params_required_string_query_parameter_success_64(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query', new Handlerquery_params_64());
        return $app;
    }

    public static function create_query_params_string_query_param_with_max_length_constraint_fail_65(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/str-max-length', new Handlerquery_params_65());
        return $app;
    }

    public static function create_query_params_string_query_param_with_min_length_constraint_fail_66(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/str-min-length', new Handlerquery_params_66());
        return $app;
    }

    public static function create_query_params_string_query_param_with_regex_pattern_fail_67(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/pattern', new Handlerquery_params_67());
        return $app;
    }

    public static function create_query_params_string_validation_with_regex_failure_68(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlerquery_params_68());
        return $app;
    }

    public static function create_query_params_string_validation_with_regex_success_69(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlerquery_params_69());
        return $app;
    }

    public static function create_query_params_uuid_query_parameter_invalid_format_70(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/uuid', new Handlerquery_params_70());
        return $app;
    }

    public static function create_query_params_uuid_query_parameter_success_71(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/query/uuid', new Handlerquery_params_71());
        return $app;
    }

    public static function create_rate_limit_rate_limit_below_threshold_succeeds_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/rate-limit/basic', new Handlerrate_limit_1());
        return $app;
    }

    public static function create_rate_limit_rate_limit_exceeded_returns_429_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/rate-limit/exceeded', new Handlerrate_limit_2());
        return $app;
    }

    public static function create_request_id_request_id_header_is_preserved_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/request-id/preserved', new Handlerrequest_id_1());
        return $app;
    }

    public static function create_request_id_request_id_is_generated_when_not_provided_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/request-id/generated', new Handlerrequest_id_2());
        return $app;
    }

    public static function create_request_id_request_id_middleware_can_be_disabled_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/request-id/disabled', new Handlerrequest_id_3());
        return $app;
    }

    public static function create_request_timeout_request_completes_before_timeout_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/timeouts/fast', new Handlerrequest_timeout_1());
        return $app;
    }

    public static function create_request_timeout_request_exceeds_timeout_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/timeouts/slow', new Handlerrequest_timeout_2());
        return $app;
    }

    public static function create_static_files_static_file_server_returns_text_file_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/public/hello.txt', new Handlerstatic_files_1());
        return $app;
    }

    public static function create_static_files_static_server_returns_index_html_for_directory_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/app/', new Handlerstatic_files_2());
        return $app;
    }

    public static function create_status_codes_19_413_payload_too_large_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/upload', new Handlerstatus_codes_1());
        return $app;
    }

    public static function create_status_codes_200_ok_success_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/status-test/200', new Handlerstatus_codes_2());
        return $app;
    }

    public static function create_status_codes_201_created_resource_created_3(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerstatus_codes_3());
        return $app;
    }

    public static function create_status_codes_202_accepted_request_accepted_for_processing_4(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/tasks/', new Handlerstatus_codes_4());
        return $app;
    }

    public static function create_status_codes_204_no_content_success_with_no_body_5(): App
    {
        $app = new App();
        $app = $app->addRoute('DELETE', '/status-test/204', new Handlerstatus_codes_5());
        return $app;
    }

    public static function create_status_codes_206_partial_content_6(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/files/document.pdf', new Handlerstatus_codes_6());
        return $app;
    }

    public static function create_status_codes_20_414_uri_too_long_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/data', new Handlerstatus_codes_7());
        return $app;
    }

    public static function create_status_codes_21_431_request_header_fields_too_large_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/data', new Handlerstatus_codes_8());
        return $app;
    }

    public static function create_status_codes_22_501_not_implemented_9(): App
    {
        $app = new App();
        $app = $app->addRoute('TRACE', '/data', new Handlerstatus_codes_9());
        return $app;
    }

    public static function create_status_codes_23_503_service_unavailable_10(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/data', new Handlerstatus_codes_10());
        return $app;
    }

    public static function create_status_codes_301_moved_permanently_permanent_redirect_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/old-path', new Handlerstatus_codes_11());
        return $app;
    }

    public static function create_status_codes_302_found_temporary_redirect_12(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/temp-redirect', new Handlerstatus_codes_12());
        return $app;
    }

    public static function create_status_codes_304_not_modified_cached_content_valid_13(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/status-test/304', new Handlerstatus_codes_13());
        return $app;
    }

    public static function create_status_codes_307_temporary_redirect_method_preserved_14(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/redirect-post', new Handlerstatus_codes_14());
        return $app;
    }

    public static function create_status_codes_400_bad_request_invalid_request_15(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerstatus_codes_15());
        return $app;
    }

    public static function create_status_codes_401_unauthorized_missing_authentication_16(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/users/me', new Handlerstatus_codes_16());
        return $app;
    }

    public static function create_status_codes_403_forbidden_insufficient_permissions_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/admin/users', new Handlerstatus_codes_17());
        return $app;
    }

    public static function create_status_codes_404_not_found_resource_not_found_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/status-test/404', new Handlerstatus_codes_18());
        return $app;
    }

    public static function create_status_codes_408_request_timeout_19(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/slow-endpoint', new Handlerstatus_codes_19());
        return $app;
    }

    public static function create_status_codes_422_unprocessable_entity_validation_error_20(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlerstatus_codes_20());
        return $app;
    }

    public static function create_status_codes_429_too_many_requests_21(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/api/resource', new Handlerstatus_codes_21());
        return $app;
    }

    public static function create_status_codes_500_internal_server_error_server_error_22(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/error', new Handlerstatus_codes_22());
        return $app;
    }

    public static function create_status_codes_503_service_unavailable_server_overload_23(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/health', new Handlerstatus_codes_23());
        return $app;
    }

    public static function create_streaming_binary_log_download_1(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/stream/logfile', new Handlerstreaming_1());
        return $app;
    }

    public static function create_streaming_chunked_csv_export_2(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/stream/csv-report', new Handlerstreaming_2());
        return $app;
    }

    public static function create_streaming_stream_json_lines_3(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/stream/json-lines', new Handlerstreaming_3());
        return $app;
    }

    public static function create_url_encoded_13_array_field_success_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/register', new Handlerurl_encoded_1());
        return $app;
    }

    public static function create_url_encoded_14_nested_object_bracket_notation_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/profile', new Handlerurl_encoded_2());
        return $app;
    }

    public static function create_url_encoded_15_special_characters_field_names_3(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/data', new Handlerurl_encoded_3());
        return $app;
    }

    public static function create_url_encoded_16_minlength_validation_failure_4(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlerurl_encoded_4());
        return $app;
    }

    public static function create_url_encoded_17_pattern_validation_failure_5(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/accounts', new Handlerurl_encoded_5());
        return $app;
    }

    public static function create_url_encoded_18_integer_minimum_validation_failure_6(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/products', new Handlerurl_encoded_6());
        return $app;
    }

    public static function create_url_encoded_19_array_minitems_validation_failure_7(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/tags', new Handlerurl_encoded_7());
        return $app;
    }

    public static function create_url_encoded_20_format_email_validation_failure_8(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/subscribe', new Handlerurl_encoded_8());
        return $app;
    }

    public static function create_url_encoded_21_integer_type_coercion_failure_9(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/products', new Handlerurl_encoded_9());
        return $app;
    }

    public static function create_url_encoded_22_additional_properties_strict_failure_10(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/settings', new Handlerurl_encoded_10());
        return $app;
    }

    public static function create_url_encoded_boolean_field_conversion_11(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/', new Handlerurl_encoded_11());
        return $app;
    }

    public static function create_url_encoded_empty_string_value_12(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/', new Handlerurl_encoded_12());
        return $app;
    }

    public static function create_url_encoded_multiple_values_for_same_field_13(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/tags', new Handlerurl_encoded_13());
        return $app;
    }

    public static function create_url_encoded_numeric_field_type_conversion_14(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/', new Handlerurl_encoded_14());
        return $app;
    }

    public static function create_url_encoded_oauth2_password_grant_flow_15(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/token', new Handlerurl_encoded_15());
        return $app;
    }

    public static function create_url_encoded_optional_field_missing_success_16(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/register/', new Handlerurl_encoded_16());
        return $app;
    }

    public static function create_url_encoded_pattern_validation_fail_17(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/validated', new Handlerurl_encoded_17());
        return $app;
    }

    public static function create_url_encoded_required_field_missing_validation_error_18(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/login/', new Handlerurl_encoded_18());
        return $app;
    }

    public static function create_url_encoded_simple_form_submission_success_19(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/login/', new Handlerurl_encoded_19());
        return $app;
    }

    public static function create_url_encoded_special_characters_encoding_20(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/', new Handlerurl_encoded_20());
        return $app;
    }

    public static function create_url_encoded_string_max_length_validation_fail_21(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/validated', new Handlerurl_encoded_21());
        return $app;
    }

    public static function create_url_encoded_string_min_length_validation_fail_22(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/form/validated', new Handlerurl_encoded_22());
        return $app;
    }

    public static function create_validation_errors_09_multiple_validation_errors_1(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/users', new Handlervalidation_errors_1());
        return $app;
    }

    public static function create_validation_errors_10_nested_error_path_2(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/profiles', new Handlervalidation_errors_2());
        return $app;
    }

    public static function create_validation_errors_array_item_validation_error_3(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_3());
        return $app;
    }

    public static function create_validation_errors_array_max_items_constraint_violation_4(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_4());
        return $app;
    }

    public static function create_validation_errors_array_min_items_constraint_violation_5(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_5());
        return $app;
    }

    public static function create_validation_errors_body_field_type_error_string_for_float_6(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_6());
        return $app;
    }

    public static function create_validation_errors_header_validation_error_7(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_7());
        return $app;
    }

    public static function create_validation_errors_invalid_uuid_format_8(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/not-a-uuid', new Handlervalidation_errors_8());
        return $app;
    }

    public static function create_validation_errors_invalid_boolean_value_9(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_9());
        return $app;
    }

    public static function create_validation_errors_invalid_datetime_format_10(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_10());
        return $app;
    }

    public static function create_validation_errors_invalid_enum_value_11(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/models/invalid_model', new Handlervalidation_errors_11());
        return $app;
    }

    public static function create_validation_errors_malformed_json_body_12(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_12());
        return $app;
    }

    public static function create_validation_errors_missing_required_body_field_13(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_13());
        return $app;
    }

    public static function create_validation_errors_missing_required_query_parameter_14(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_14());
        return $app;
    }

    public static function create_validation_errors_multiple_validation_errors_15(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_15());
        return $app;
    }

    public static function create_validation_errors_nested_object_validation_error_16(): App
    {
        $app = new App();
        $app = $app->addRoute('POST', '/items/', new Handlervalidation_errors_16());
        return $app;
    }

    public static function create_validation_errors_numeric_constraint_violation_gt_greater_than_17(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_17());
        return $app;
    }

    public static function create_validation_errors_numeric_constraint_violation_le_less_than_or_equal_18(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_18());
        return $app;
    }

    public static function create_validation_errors_query_param_type_error_string_provided_for_int_19(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_19());
        return $app;
    }

    public static function create_validation_errors_string_max_length_constraint_violation_20(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_20());
        return $app;
    }

    public static function create_validation_errors_string_min_length_constraint_violation_21(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_21());
        return $app;
    }

    public static function create_validation_errors_string_regex_pattern_mismatch_22(): App
    {
        $app = new App();
        $app = $app->addRoute('GET', '/items/', new Handlervalidation_errors_22());
        return $app;
    }

}

final class SseProducer1 implements \Spikard\Handlers\SseEventProducerInterface {
    public function __invoke(): \Generator {
        foreach ([['level' => 'critical', 'message' => 'Database connection pool exhausted', 'source' => 'database-service', 'timestamp' => '2024-01-15T10:30:00Z', 'type' => 'system_alert']] as $event) {
            yield 'data: ' . json_encode($event) . "\n\n";
        }
    }
}

final class SseProducer2 implements \Spikard\Handlers\SseEventProducerInterface {
    public function __invoke(): \Generator {
        foreach ([[['message' => 'example_message', 'timestamp' => '2024-01-15T10:30:00Z', 'type' => 'example_type'], ['message' => 'example_message', 'timestamp' => '2024-01-15T10:30:00Z', 'type' => 'example_type']]] as $event) {
            yield 'data: ' . json_encode($event) . "\n\n";
        }
    }
}

final class SseProducer3 implements \Spikard\Handlers\SseEventProducerInterface {
    public function __invoke(): \Generator {
        foreach ([['body' => 'You have received a new direct message', 'priority' => 'high', 'timestamp' => '2024-01-15T10:30:00Z', 'title' => 'New message from John', 'type' => 'user_notification', 'userId' => 'user_12345']] as $event) {
            yield 'data: ' . json_encode($event) . "\n\n";
        }
    }
}

final class SseProducer4 implements \Spikard\Handlers\SseEventProducerInterface {
    public function __invoke(): \Generator {
        foreach ([['message' => 'All systems operational', 'metadata' => ['region' => 'us-east-1', 'uptime' => 99.99], 'service' => 'payment-gateway', 'status' => 'operational', 'timestamp' => '2024-01-15T10:30:00Z', 'type' => 'status_update']] as $event) {
            yield 'data: ' . json_encode($event) . "\n\n";
        }
    }
}

final class WebSocketHandler1 implements \Spikard\Handlers\WebSocketHandlerInterface {
    public function onConnect(): void {}
    public function onMessage(string $message): void {}
    public function onClose(int $code, ?string $reason = null): void {}
}

final class WebSocketHandler2 implements \Spikard\Handlers\WebSocketHandlerInterface {
    public function onConnect(): void {}
    public function onMessage(string $message): void {}
    public function onClose(int $code, ?string $reason = null): void {}
}

final class WebSocketHandler3 implements \Spikard\Handlers\WebSocketHandlerInterface {
    public function onConnect(): void {}
    public function onMessage(string $message): void {}
    public function onClose(int $code, ?string $reason = null): void {}
}

final class WebSocketHandler4 implements \Spikard\Handlers\WebSocketHandlerInterface {
    public function onConnect(): void {}
    public function onMessage(string $message): void {}
    public function onClose(int $code, ?string $reason = null): void {}
}

final class WebSocketHandler5 implements \Spikard\Handlers\WebSocketHandlerInterface {
    public function onConnect(): void {}
    public function onMessage(string $message): void {}
    public function onClose(int $code, ?string $reason = null): void {}
}

final class WebSocketHandler6 implements \Spikard\Handlers\WebSocketHandlerInterface {
    public function onConnect(): void {}
    public function onMessage(string $message): void {}
    public function onClose(int $code, ?string $reason = null): void {}
}

final class WebSocketHandler7 implements \Spikard\Handlers\WebSocketHandlerInterface {
    public function onConnect(): void {}
    public function onMessage(string $message): void {}
    public function onClose(int $code, ?string $reason = null): void {}
}

final class Handlerauth_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-api-key' => 'invalid_key_12345'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'The provided API key is not valid', 'status' => 401, 'title' => 'Invalid API key', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Expected \'X-API-Key\' header or \'api_key\' query parameter with valid API key', 'status' => 401, 'title' => 'Missing API key', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-api-key' => 'sk_test_123456'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'sensitive information', 'message' => 'Access granted'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['api_key' => ['sk_test_123456']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'sensitive information', 'message' => 'Access granted'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-api-key' => 'sk_test_old_123456'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'sensitive information', 'message' => 'Access granted'], 200, ['X-API-Key-Deprecated' => 'true']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-api-token' => 'sk_test_123456'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'sensitive information', 'message' => 'Access granted'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNjI2NzgzOTQ2LCJpYXQiOjE3NjI3ODM5NDZ9.8yXqZ9jKCR0BwqJc7pN_QvD3mYLxHfWzUeIaGkTnOsA'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Authorization header must use Bearer scheme: \'Bearer <token>\'', 'status' => 401, 'title' => 'Invalid Authorization header format', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNjAwMDAwMDAwLCJpYXQiOjE1OTAwMDAwMDB9.n4oBw9XuO2aAJWi1e4Bz9Y_m2iEyJHGAODcetNuwYFo'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Token has expired', 'status' => 401, 'title' => 'JWT validation failed', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNTM0MDIzMDA3OTk5LCJpYXQiOjE3MzEyNTIwMDAsImF1ZCI6WyJodHRwczovL3dyb25nLXNlcnZpY2UuY29tIl19.YR2a9fSJjhen7ksYFI2djSBSC7Pc29FDCloBGhkj3kU'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Token audience is invalid', 'status' => 401, 'title' => 'JWT validation failed', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNTM0MDIzMDA3OTksImlhdCI6MTczMTI1MjAwMH0.invalid_signature_here'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Token signature is invalid', 'status' => 401, 'title' => 'JWT validation failed', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Expected \'Authorization: Bearer <token>\'', 'status' => 401, 'title' => 'Missing or invalid Authorization header', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNjI2NzgzOTQ2LCJpYXQiOjE3NjI3ODM5NDYsImF1ZCI6WyJodHRwczovL2FwaS5leGFtcGxlLmNvbSJdLCJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20ifQ.TpRpCJeXROQ12-ehRCVZm6EgN7Dn6QpfoekxJvnzgQg'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Access granted', 'user_id' => 'user123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNjI2NzgzOTQ2LCJpYXQiOjE2MDAwMDAwMDAsImF1ZCI6WyJodHRwczovL2FwaS5leGFtcGxlLmNvbSJdLCJpc3MiOiJodHRwczovL2V2aWwuY29tIn0.mbL5L04_hpaaiz0SPABap6ZWfBLu18aiexBjzwQ1nnA'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Token issuer is invalid, expected \'https://auth.example.com\'', 'status' => 401, 'title' => 'JWT validation failed', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer invalid.token'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Malformed JWT token: expected 3 parts separated by dots, found 2', 'status' => 401, 'title' => 'Malformed JWT token', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNjI2NzgzOTQ2LCJpYXQiOjE3NjI3ODM5NDYsImF1ZCI6WyJodHRwczovL2FwaS5leGFtcGxlLmNvbSJdLCJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20ifQ.TpRpCJeXROQ12-ehRCVZm6EgN7Dn6QpfoekxJvnzgQg'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Required claims \'role\' and \'permissions\' missing from JWT', 'status' => 403, 'title' => 'Forbidden', 'type' => 'https://spikard.dev/errors/forbidden'], 403, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNjI2NzgzOTQ2LCJpYXQiOjE2MDAwMDAwMDAsIm5iZiI6MjYyNjc4Mzk0NiwiYXVkIjpbImh0dHBzOi8vYXBpLmV4YW1wbGUuY29tIl0sImlzcyI6Imh0dHBzOi8vYXV0aC5leGFtcGxlLmNvbSJ9.hG4I76_3kJfsbJ_jmxoP1NSYnkcqdyBFcPpdo-jYU4E'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'JWT not valid yet, not before claim is in the future', 'status' => 401, 'title' => 'JWT validation failed', 'type' => 'https://spikard.dev/errors/unauthorized'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNjI2NzgzOTQ2LCJpYXQiOjE2MDAwMDAwMDAsImF1ZCI6WyJodHRwczovL2FwaS5leGFtcGxlLmNvbSIsImh0dHBzOi8vYWRtaW4uZXhhbXBsZS5jb20iXSwiaXNzIjoiaHR0cHM6Ly9hdXRoLmV4YW1wbGUuY29tIn0.9MBL_XccGXfu9cDUnCpQruDMOl2hHYydzeGn-20dQOs'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Access granted', 'user_id' => 'user123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerauth_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoyNjI2NzgzOTQ2LCJpYXQiOjE3NjI3ODM5NDYsImF1ZCI6WyJodHRwczovL2FwaS5leGFtcGxlLmNvbSJdLCJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20ifQ.TpRpCJeXROQ12-ehRCVZm6EgN7Dn6QpfoekxJvnzgQg', 'x-api-key' => 'sk_test_123456'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['auth_method' => 'jwt', 'message' => 'Access granted', 'user_id' => 'user123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerbackground_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['event' => 'alpha'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 202, ['content-type' => 'application/json']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerbackground_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['event' => 'beta'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 202, ['content-type' => 'application/json']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerbody_limits_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['note' => 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 413, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerbody_limits_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['note' => 'small'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['accepted' => true, 'note' => 'small'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercompression_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['accept-encoding' => 'gzip'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Compressed payload', 'payload' => 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'], 200, ['content-encoding' => 'gzip', 'vary' => 'Accept-Encoding']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercompression_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['accept-encoding' => 'gzip'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Small payload', 'payload' => 'tiny'], 200, ['content-encoding' => '<<absent>>']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json; charset=utf-16'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Unsupported charset \'utf-16\' for JSON. Only UTF-8 is supported.', 'status' => 415, 'title' => 'Unsupported Charset', 'type' => 'https://spikard.dev/errors/unsupported-charset'], 415, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'APPLICATION/JSON'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'test'], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'multipart/form-data'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'multipart/form-data requires \'boundary\' parameter'], 400, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'text/plain'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = '{"data": "value"}';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Unsupported media type', 'status' => 415, 'title' => 'Unsupported Media Type', 'type' => 'https://spikard.dev/errors/unsupported-media-type'], 415, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/vnd.api+json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['data' => 'value'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'value'], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json; charset=utf-8; boundary=something'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 'test'], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'test'], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-length' => '100', 'content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'short'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Content-Length header does not match actual body size'], 400, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/xml'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = '<?xml version="1.0"?><item><name>Item</name></item>';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Unsupported media type'], 415, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('binary_data_placeholder', 200, ['content-disposition' => 'attachment; filename=file.bin', 'content-type' => 'application/octet-stream']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('id,name,price
1,Item A,10.0
2,Item B,20.0', 200, ['content-disposition' => 'attachment; filename=data.csv', 'content-type' => 'text/csv; charset=utf-8']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['accept' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 1, 'name' => 'Item'], 200, ['content-type' => 'application/json']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('<html><body><h1>Hello</h1></body></html>', 200, ['content-type' => 'text/html; charset=utf-8']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('jpeg_binary_data', 200, ['content-type' => 'image/jpeg']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'Item', 'price' => 42.0], 200, ['content-type' => 'application/json']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['emoji' => '', 'name' => 'Caf'], 200, ['content-type' => 'application/json; charset=utf-8']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('pdf_binary_data', 200, ['content-disposition' => 'attachment; filename=document.pdf', 'content-type' => 'application/pdf']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('png_binary_data', 200, ['content-type' => 'image/png']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('Hello, World!', 200, ['content-type' => 'text/plain; charset=utf-8']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercontent_types_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('<?xml version="1.0"?><item><name>Item</name><price>42.0</price></item>', 200, ['content-type' => 'application/xml']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['session_id' => 'abc123xyz789'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['tracking' => 'track123'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['auth_token' => 'secure_token_xyz'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['session' => 'session_abc123'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['cookie', 'key'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['key' => 'secret'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['username' => 'secret'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['tracking_id' => 'invalid-format'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[A-Z0-9]{8}$'], 'input' => 'invalid-format', 'loc' => ['cookie', 'tracking_id'], 'msg' => 'String should match pattern \'^[A-Z0-9]{8}$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['tracking_id' => 'ABC12345'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['tracking_id' => 'ABC12345'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['session_id' => 'this_cookie_value_is_way_too_long'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['max_length' => 20], 'input' => 'this_cookie_value_is_way_too_long', 'loc' => ['cookie', 'session_id'], 'msg' => 'String should have at most 20 characters', 'type' => 'string_too_long']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['token' => 'abc'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['token' => 'abc'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['tracking_id' => 'ab'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => '', 'loc' => ['cookie', 'tracking_id'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['fatebook_tracker' => 'tracker456', 'googall_tracker' => 'ga789', 'session_id' => 'session123'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['fatebook_tracker' => 'tracker456', 'googall_tracker' => 'ga789', 'session_id' => 'session123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['msg' => 'Create an account first'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['ads_id' => null], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['ads_id' => 'abc123'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['ads_id' => 'abc123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['fatebook_tracker' => 'tracker456'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => '', 'loc' => ['cookie', 'session_id'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = ['session' => 'old_session_123'];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Cookie deleted'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['session' => 'session123', 'user' => 'john'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Multiple cookies set'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'session_abc123'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Session cookie set'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'lax_cookie'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Cookie set with SameSite=Lax'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'none_cookie'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Cookie set with SameSite=None'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'strict_cookie'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Cookie set with SameSite=Strict'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_23 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Cookie set'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_24 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'domain_test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Cookie set with domain'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_25 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 'path_test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Cookie set with path'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercookies_26 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Come to the dark side, we have cookies'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-headers' => 'Content-Type', 'access-control-request-method' => 'DELETE', 'origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 403, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-headers' => 'X-Custom-Header', 'access-control-request-method' => 'POST', 'origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 403, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-headers' => 'Content-Type', 'access-control-request-method' => 'POST', 'origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 204, ['Access-Control-Allow-Headers' => 'Content-Type', 'Access-Control-Allow-Methods' => 'POST', 'Access-Control-Allow-Origin' => 'https://example.com', 'Access-Control-Max-Age' => '3600']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, ['Access-Control-Allow-Origin' => 'https://example.com', 'Access-Control-Expose-Headers' => 'X-Total-Count, X-Request-Id', 'X-Request-Id' => 'abc123', 'X-Total-Count' => '42']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'null'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Origin \'null\' is not allowed'], 403, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-method' => 'GET', 'access-control-request-private-network' => 'true', 'origin' => 'https://public.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 204, ['Access-Control-Allow-Methods' => 'GET, POST', 'Access-Control-Allow-Origin' => 'https://public.example.com', 'Access-Control-Allow-Private-Network' => 'true', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['cache-control' => 'max-age=3600', 'origin' => 'https://app.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'cacheable resource'], 200, ['Access-Control-Allow-Origin' => 'https://app.example.com', 'Cache-Control' => 'public, max-age=3600', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://admin.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'resource data'], 200, ['Access-Control-Allow-Origin' => 'https://admin.example.com', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://EXAMPLE.COM'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, ['Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-method' => 'DELETE', 'origin' => 'https://app.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 204, ['Access-Control-Allow-Methods' => 'GET, POST, PUT, PATCH, DELETE', 'Access-Control-Allow-Origin' => 'https://app.example.com', 'Access-Control-Max-Age' => '3600', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-headers' => 'Content-Type, X-Custom-Header', 'access-control-request-method' => 'PUT', 'origin' => 'https://app.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 204, ['Access-Control-Allow-Headers' => 'Content-Type, X-Custom-Header', 'Access-Control-Allow-Methods' => 'GET, POST, PUT, PATCH, DELETE', 'Access-Control-Allow-Origin' => 'https://app.example.com', 'Access-Control-Max-Age' => '3600', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-headers' => 'Content-Type, X-Custom-Header', 'access-control-request-method' => 'POST', 'origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, ['Access-Control-Allow-Headers' => 'Content-Type, X-Custom-Header', 'Access-Control-Allow-Methods' => 'GET, POST, PUT, DELETE, OPTIONS', 'Access-Control-Allow-Origin' => 'https://example.com', 'Access-Control-Max-Age' => '600']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://subdomain.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'resource data'], 200, ['Access-Control-Allow-Origin' => 'https://subdomain.example.com', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://malicious-site.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'CORS request from origin \'https://malicious-site.com\' not allowed'], 403, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['accept' => 'application/json', 'accept-language' => 'en-US', 'content-type' => 'text/plain', 'origin' => 'https://app.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Success'], 200, ['Access-Control-Allow-Origin' => 'https://app.example.com', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://random-site.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['data' => 'public'], 200, ['Access-Control-Allow-Origin' => '*']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['cookie' => 'session=abc123', 'origin' => 'https://app.example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['username' => 'john'], 200, ['Access-Control-Allow-Credentials' => 'true', 'Access-Control-Allow-Origin' => 'https://app.example.com', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlercors_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['items' => []], 200, ['Access-Control-Allow-Origin' => 'https://example.com', 'Vary' => 'Origin']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['max_size' => 10, 'pool_status' => 'connected'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Circular dependency detected', 'errors' => [['cycle' => ['service_a', 'service_b', 'service_a'], 'msg' => 'Circular dependency detected in dependency graph', 'type' => 'circular_dependency']], 'status' => 500, 'title' => 'Dependency Resolution Failed', 'type' => 'https://spikard.dev/errors/dependency-error'], 500, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer valid_token'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['authenticated' => true, 'logged' => true], 200, ['X-Auth-Mode' => 'strict', 'X-Log-Level' => 'debug']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['timestamp' => '<<present>>'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Required dependency not found', 'errors' => [['dependency_key' => 'non_existent_service', 'msg' => 'Dependency \'non_existent_service\' is not registered', 'type' => 'missing_dependency']], 'status' => 500, 'title' => 'Dependency Resolution Failed', 'type' => 'https://spikard.dev/errors/dependency-error'], 500, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['app_name' => 'MyApp', 'context_id' => '<<uuid>>', 'pool_id' => '<<uuid>>'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['session_active' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['auth_enabled' => true, 'has_cache' => true, 'has_db' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['db_name' => 'PostgreSQL', 'log_level' => 'info'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['first_id' => '<<uuid>>', 'second_id' => '<<same_as:first_id>>'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['cache_status' => 'ready', 'db_status' => 'connected'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['cache_type' => 'Redis', 'pool_type' => 'PostgreSQL'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['session_id' => '<<uuid>>', 'status' => 'completed'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['mode' => 'test', 'strict' => false], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['adapter' => 'postgresql', 'user_id' => 42], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['count' => 1, 'counter_id' => '<<uuid>>'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Dependency type mismatch', 'errors' => [['actual_type' => 'string', 'dependency_key' => 'config', 'expected_type' => 'object', 'msg' => 'Dependency \'config\' type mismatch: expected object, got string', 'type' => 'type_mismatch']], 'status' => 500, 'title' => 'Dependency Resolution Failed', 'type' => 'https://spikard.dev/errors/dependency-error'], 500, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerdi_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['app_name' => 'SpikardApp', 'max_connections' => 100, 'version' => '1.0.0'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['term' => ['caf']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['term' => 'caf'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['term' => ['hi there', 'hi there']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['term' => 'hi there'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['filter' => ['', '']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['filter' => ''], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['id' => ['9007199254740991']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 9007199254740991], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 3.141592653589793];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 3.141592653589793], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['offset' => -0.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['offset' => 0], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['content' => 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_length' => 10001, 'max_length' => 10000], 'loc' => ['body', 'content'], 'msg' => 'String length must not exceed 10000', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'caf'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'caf'], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['text' => 'Hello  World '];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['text' => 'Hello  World '], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['filename' => 'file .txt'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['value' => 'file\\u0000.txt'], 'loc' => ['body', 'filename'], 'msg' => 'String contains null byte character', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['value' => 123000.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 123000], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['value' => ['0123']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 123], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['nested' => ['value' => 'deep']]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Request body exceeds maximum nesting depth of 32'], 400, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'items[0]=first&items[2]=third&items[5]=sixth';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['items' => ['first', 'third', 'sixth']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['level1' => ['level2' => ['level3' => ['level4' => ['level5' => ['level6' => ['level7' => ['level8' => ['level9' => ['level10' => ['depth' => 10, 'value' => 'deep']]]]]]]]]]];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['max_depth' => 10, 'message' => 'Processed deeply nested structure', 'value_found' => 'deep'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['empty_array' => [], 'empty_object' => [], 'empty_string' => '', 'explicit_null' => null, 'false_boolean' => false, 'zero_number' => 0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['empty_array_length' => 0, 'empty_object_keys' => 0, 'empty_string_length' => 0, 'explicit_null_is_null' => true, 'false_is_false' => true, 'zero_is_falsy' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['expected_sum' => 0.3, 'precise_value' => 3.141592653589793, 'value1' => 0.1, 'value2' => 0.2, 'very_large' => 1.7976931348623157e308, 'very_small' => 1e-10];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['precise_value' => 3.141592653589793, 'sum' => 0.30000000000000004, 'very_large' => 1.7976931348623157e308, 'very_small' => 1e-10], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['large_int' => 9223372036854775807, 'max_safe_int' => 9007199254740991, 'negative_large' => -9223372036854775808];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['large_int' => 9223372036854775807, 'max_safe_int' => 9007199254740991, 'negative_large' => -9223372036854775808], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['backslashes' => 'C:\\\\Users\\\\Path', 'empty_string' => '', 'quotes' => 'He said "hello" and \'goodbye\'', 'special_chars' => '!@#$%^&*()_+-=[]{}|;\':",./<>?', 'tabs_newlines' => 'line1
	line2
line3', 'unicode_escapes' => '\\u0048\\u0065\\u006c\\u006c\\u006f', 'whitespace' => '   '];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['backslashes' => 'C:\\\\Users\\\\Path', 'empty_string' => '', 'quotes' => 'He said "hello" and \'goodbye\'', 'special_chars' => '!@#$%^&*()_+-=[]{}|;\':",./<>?', 'tabs_newlines' => 'line1
	line2
line3', 'unicode_escapes' => 'Hello', 'whitespace' => '   '], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handleredge_cases_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json; charset=utf-8'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['description' => 'Best caf in Mnchen ', 'emoji_reactions' => '', 'name' => 'Coffee Shop ', 'tags' => ['', '', '']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => 'Best caf in Mnchen ', 'emoji_reactions' => '', 'id' => 1, 'name' => 'Coffee Shop ', 'tags' => ['', '', '']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer invalid token with spaces'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^Bearer [A-Za-z0-9-._~+/]+=*$', 'value' => 'Bearer invalid token with spaces'], 'loc' => ['headers', 'authorization'], 'msg' => 'Invalid Bearer token format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^Bearer [A-Za-z0-9-._~+/]+=*$', 'value' => 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9'], 'loc' => ['headers', 'authorization'], 'msg' => 'Invalid Bearer token format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-api-key' => 'a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-api-key' => 'invalid-key'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[a-f0-9]{32}$', 'value' => 'invalid-key'], 'loc' => ['headers', 'x-api-key'], 'msg' => 'Invalid API key format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['accept' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['accept' => 'application/json'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['accept-encoding' => 'gzip, deflate, br'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['accept_encoding' => 'gzip, deflate, br'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['accept-language' => 'en-US,en;q=0.9'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['accept_language' => 'en-US,en;q=0.9'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['headers', 'authorization'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Digest foobar'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['credentials' => 'foobar', 'scheme' => 'Digest'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Other invalidauthorization'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'Other invalidauthorization', 'loc' => ['headers', 'authorization'], 'msg' => 'String should match pattern \'^Digest .+\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Basic dXNlcm5hbWU6cGFzc3dvcmQ='];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['password' => 'password', 'username' => 'username'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['headers', 'authorization'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer valid_token_123'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['token' => 'valid_token_123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['content_type' => 'application/json'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['test' => 'data'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['content_type_lower' => 'application/json', 'content_type_mixed' => 'application/json', 'content_type_upper' => 'application/json'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-request-id' => 'invalid-format'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[0-9]{3,}$'], 'input' => 'invalid-format', 'loc' => ['headers', 'x-request-id'], 'msg' => 'String should match pattern \'^[0-9]{3,}$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-request-id' => '12345'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['x_request_id' => '12345'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-session-id' => 'this_is_way_too_long_for_validation'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['max_length' => 20], 'input' => 'this_is_way_too_long_for_validation', 'loc' => ['headers', 'x-session-id'], 'msg' => 'String should have at most 20 characters', 'type' => 'string_too_long']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'ab'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'ab', 'loc' => ['headers', 'x-token'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'secret123'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['x_token' => 'secret123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['host' => 'example.com:8080'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['host' => 'example.com:8080'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_23 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-client-version' => '1.2.3', 'x-request-id' => 'req-12345', 'x-trace-id' => 'trace-abc'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['x_client_version' => '1.2.3', 'x_request_id' => 'req-12345', 'x_trace_id' => 'trace-abc'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_24 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'foo, bar'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['X-Token values' => ['foo', 'bar']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_25 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['strange_header' => null], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_26 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['origin' => 'https://example.com'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_27 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['referer' => 'https://example.com/page'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['referer' => 'https://example.com/page'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_28 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['user-agent' => 'Mozilla/5.0 Custom Browser'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['User-Agent' => 'Mozilla/5.0 Custom Browser'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_29 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['User-Agent' => 'testclient'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_30 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['msg' => 'Hello World'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_31 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['key' => 'secret'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['msg' => 'Hello secret'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_32 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['headers', 'x-api-key'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerheaders_33 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['key' => 'secret'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['username' => 'secret'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response([], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response([], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 1, 'message' => 'Item deleted successfully', 'name' => 'Deleted Item'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, ['Content-Length' => '85', 'Content-Type' => 'application/json']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['access-control-request-headers' => 'Content-Type', 'access-control-request-method' => 'POST', 'origin' => 'https://example.com'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 200, ['Access-Control-Allow-Headers' => 'Content-Type', 'Access-Control-Allow-Methods' => 'GET, POST, PUT, DELETE, OPTIONS', 'Access-Control-Allow-Origin' => 'https://example.com', 'Access-Control-Max-Age' => '86400']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['price' => 79.99];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 1, 'in_stock' => true, 'name' => 'Existing Item', 'price' => 79.99], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['in_stock' => false, 'name' => 'Updated Name', 'price' => 89.99];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 1, 'in_stock' => false, 'name' => 'Updated Name', 'price' => 89.99], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['description' => 'Completely replaced', 'id' => 1, 'in_stock' => true, 'name' => 'Updated Item', 'price' => 99.99];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => 'Completely replaced', 'id' => 1, 'in_stock' => true, 'name' => 'Updated Item', 'price' => 99.99], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['id' => 999, 'name' => 'New Item', 'price' => 49.99];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 999, 'name' => 'New Item', 'price' => 49.99], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['id' => 1, 'name' => 'Fixed Name', 'price' => 50.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 1, 'name' => 'Fixed Name', 'price' => 50.0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['id' => 1, 'name' => 'Item Name'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => '1', 'loc' => ['body', 'price'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerhttp_methods_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['id' => 1, 'name' => 'X', 'price' => -10];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '2 validation errors in request', 'errors' => [['input' => 'X', 'loc' => ['body', 'name'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short'], ['input' => -10, 'loc' => ['body', 'price'], 'msg' => 'Input should be greater than 0', 'type' => 'greater_than']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['profile' => ['email' => 'john@example.com', 'name' => 'John Doe']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['profile' => ['name' => 'John Doe']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['required' => true], 'loc' => ['body', 'profile', 'email'], 'msg' => 'Field required', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['description' => null, 'name' => 'Test User'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['product' => ['name' => 'Widget', 'price' => 9.99]];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Product', 'price' => 29.99];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['email' => 'john@example.com', 'extra_field' => 'should fail', 'name' => 'John'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['additional_properties' => false, 'unexpected_field' => 'extra_field'], 'loc' => ['body', 'extra_field'], 'msg' => 'Additional properties are not allowed', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['credit_card' => '1234567812345678'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['credit_card' => '1234567812345678', 'paypal_email' => 'user@example.com'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['matched_schemas' => 2], 'loc' => ['body'], 'msg' => 'Must match exactly one schema (oneOf), but matched 2', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['bitcoin_address' => '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['matched_schemas' => 0], 'loc' => ['body'], 'msg' => 'Must match exactly one schema (oneOf), but matched 0', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['email' => 'john@example.com', 'name' => 'John Doe'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['email' => 'john@example.com', 'name' => 'John Doe', 'phone' => '+1-555-0100'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'John Doe'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['matched_schemas' => 0], 'loc' => ['body'], 'msg' => 'Must match at least one schema (anyOf), but matched 0', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['username' => 'john_doe'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['username' => 'admin'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['prohibited_value' => 'admin'], 'loc' => ['body', 'username'], 'msg' => 'Must not match the schema', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['data' => 'test', 'version' => '1.0'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['data' => 'test', 'version' => '2.0'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['const' => '1.0', 'value' => '2.0'], 'loc' => ['body', 'version'], 'msg' => 'Value must be exactly \'1.0\'', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['host' => 'localhost', 'port' => 8080];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['host' => 'localhost'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_properties' => 1, 'min_properties' => 2], 'loc' => ['body'], 'msg' => 'Object must have at least 2 properties', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['debug' => false, 'host' => 'localhost', 'port' => 8080, 'ssl' => true];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_properties' => 4, 'max_properties' => 3], 'loc' => ['body'], 'msg' => 'Object must have at most 3 properties', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['billing_address' => '123 Main St', 'credit_card' => '1234567812345678', 'name' => 'John Doe'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['credit_card' => '1234567812345678', 'name' => 'John Doe'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['dependency' => 'credit_card', 'required_fields' => ['billing_address']], 'loc' => ['body'], 'msg' => 'When \'credit_card\' is present, \'billing_address\' is required', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['user' => ['profile' => ['contact' => ['address' => ['street' => '123 Main St']]]]];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_23 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['images' => [['name' => 'Front', 'url' => 'https://example.com/img1.jpg'], ['name' => 'Back', 'url' => 'https://example.com/img2.jpg']], 'name' => 'Product Bundle', 'tags' => ['electronics', 'gadget']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['images' => [['name' => 'Front', 'url' => 'https://example.com/img1.jpg'], ['name' => 'Back', 'url' => 'https://example.com/img2.jpg']], 'name' => 'Product Bundle', 'tags' => ['electronics', 'gadget']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_24 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Product', 'ratings' => [4.5, 4.8, 5.0, 4.2], 'tags' => ['electronics', 'gadget', 'new']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'Product', 'ratings' => [4.5, 4.8, 5.0, 4.2], 'tags' => ['electronics', 'gadget', 'new']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_25 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['limit' => ['10', '10']];
        $this->expectedBody = ['name' => 'Item', 'price' => 42.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item' => ['name' => 'Item', 'price' => 42.0], 'limit' => 10], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_26 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['in_stock' => true, 'name' => 'Item', 'price' => 42.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['in_stock' => true, 'name' => 'Item', 'price' => 42.0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_27 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['event_date' => '2024-03-15', 'name' => 'Conference'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['event_date' => '2024-03-15', 'name' => 'Conference'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_28 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['created_at' => '2024-03-15T10:30:00Z', 'name' => 'Meeting'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['created_at' => '2024-03-15T10:30:00Z', 'name' => 'Meeting'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_29 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Product', 'price' => 100.0, 'seller' => ['address' => ['city' => 'Springfield', 'country' => ['code' => 'US', 'name' => 'USA'], 'street' => '123 Main St'], 'name' => 'John Doe']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'Product', 'price' => 100.0, 'seller' => ['address' => ['city' => 'Springfield', 'country' => ['code' => 'US', 'name' => 'USA'], 'street' => '123 Main St'], 'name' => 'John Doe']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_30 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => null, 'name' => null, 'price' => null, 'tax' => null], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_31 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Product', 'tags' => []];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['min_length' => 1], 'input' => [], 'loc' => ['body', 'tags'], 'msg' => 'List should have at least 1 item after validation', 'type' => 'too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_32 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['category' => 'furniture', 'name' => 'Item'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['expected' => '\'electronics\', \'clothing\' or \'books\''], 'input' => 'furniture', 'loc' => ['body', 'category'], 'msg' => 'Input should be \'electronics\', \'clothing\' or \'books\'', 'type' => 'enum']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_33 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['category' => 'electronics', 'name' => 'Item'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['category' => 'electronics', 'name' => 'Item'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_34 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['another_extra' => 123, 'extra_field' => 'this should be ignored', 'name' => 'Item', 'price' => 42.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'Item', 'price' => 42.0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_35 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['description' => 'A very nice Item', 'name' => 'Foo', 'price' => 'not a number', 'tax' => 3.2];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not a number', 'loc' => ['body', 'price'], 'msg' => 'Input should be a valid number', 'type' => 'float_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_36 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['image' => ['name' => 'Product Image', 'url' => 'https://example.com/image.jpg'], 'name' => 'Foo', 'price' => 42.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['image' => ['name' => 'Product Image', 'url' => 'https://example.com/image.jpg'], 'name' => 'Foo', 'price' => 42.0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_37 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['description' => null, 'name' => 'Item', 'price' => 42.0, 'tax' => null];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => null, 'name' => 'Item', 'price' => 42.0, 'tax' => null], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_38 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'price' => 0.5];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['ge' => 1], 'input' => 0.5, 'loc' => ['body', 'price'], 'msg' => 'Input should be greater than or equal to 1', 'type' => 'greater_than_equal']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_39 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'price' => 100.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'Item', 'price' => 100.0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_40 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Foo', 'price' => 35.4];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => null, 'name' => 'Foo', 'price' => 35.4, 'tax' => null], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_41 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['price' => 45.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => 'Original description', 'name' => 'Original Item', 'price' => 45.0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_42 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['description' => 'A very nice Item', 'price' => 35.4];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => '', 'loc' => ['body', 'name'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_43 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['description' => 'A very nice Item', 'name' => 'Foo', 'price' => 35.4, 'tax' => 3.2];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => 'A very nice Item', 'name' => 'Foo', 'price' => 35.4, 'tax' => 3.2], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_44 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'This is a very long name that exceeds the maximum length', 'price' => 35.4];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['max_length' => 50], 'input' => 'This is a very long name that exceeds the maximum length', 'loc' => ['body', 'name'], 'msg' => 'String should have at most 50 characters', 'type' => 'string_too_long']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_45 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'ab', 'price' => 35.4];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'ab', 'loc' => ['body', 'name'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_46 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'sku' => 'ABC-123'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[A-Z]{3}[0-9]{4}$'], 'input' => 'ABC-123', 'loc' => ['body', 'sku'], 'msg' => 'String should match pattern \'^[A-Z]{3}[0-9]{4}$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_47 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'sku' => 'ABC1234'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'Item', 'sku' => 'ABC1234'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_48 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['item_id' => 'not-a-valid-uuid', 'name' => 'Item'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not-a-valid-uuid', 'loc' => ['body', 'item_id'], 'msg' => 'Input should be a valid UUID', 'type' => 'uuid_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerjson_bodies_49 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['item_id' => 'c892496f-b1fd-4b91-bdb8-b46f92df1716', 'name' => 'Item'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 'c892496f-b1fd-4b91-bdb8-b46f92df1716', 'name' => 'Item'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['execution_order' => ['first_hook', 'second_hook', 'third_hook'], 'message' => 'Hooks executed in order'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer valid-token-12345', 'content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['action' => 'update_profile', 'user_id' => 'user-123'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['action' => 'update_profile', 'message' => 'Action completed successfully', 'request_id' => '.*', 'user_id' => 'user-123'], 200, ['X-Content-Type-Options' => 'nosniff', 'X-Frame-Options' => 'DENY', 'X-Request-ID' => '.*', 'X-Response-Time' => '.*ms']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Internal Server Error', 'error_id' => '.*', 'message' => 'An unexpected error occurred'], 500, ['Content-Type' => 'application/json']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['has_request_id' => true, 'message' => 'onRequest hooks executed', 'request_logged' => true], 200, ['X-Request-ID' => '.*']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Response with timing info'], 200, ['X-Response-Time' => '.*ms']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Response with security headers'], 200, ['Strict-Transport-Security' => 'max-age=31536000; includeSubDomains', 'X-Content-Type-Options' => 'nosniff', 'X-Frame-Options' => 'DENY', 'X-XSS-Protection' => '1; mode=block']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer invalid-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Unauthorized', 'message' => 'Invalid or expired authentication token'], 401, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer valid-token-12345'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['authenticated' => true, 'message' => 'Access granted', 'user_id' => 'user-123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer admin-token-67890'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Admin access granted', 'role' => 'admin', 'user_id' => 'admin-456'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer user-token-11111'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Forbidden', 'message' => 'Admin role required for this endpoint'], 403, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['data' => 'test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Rate limit exceeded', 'message' => 'Too many requests, please try again later'], 429, ['Retry-After' => '60']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerlifecycle_hooks_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['data' => 'test'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Request accepted', 'rate_limit_checked' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content_type' => 'image/png', 'field_name' => 'image', 'filename' => 'test.png', 'magic_bytes' => '89504e470d0a1a0a']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content_type' => 'image/jpeg', 'field_name' => 'image', 'filename' => 'test.jpg', 'magic_bytes' => 'ffd8ffe0']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content_type' => 'image/jpeg', 'field_name' => 'image', 'filename' => 'fake.jpg', 'magic_bytes' => '89504e470d0a1a0a']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['declared_mime' => 'image/jpeg', 'detected_type' => 'image/png', 'magic_bytes' => '89504e470d0a1a0a'], 'loc' => ['files', 'image'], 'msg' => 'File type mismatch: MIME type is image/jpeg but magic numbers indicate image/png', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content_type' => 'image/png', 'field_name' => 'image', 'filename' => 'fake.png', 'magic_bytes' => 'ffd8ffe0']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['declared_mime' => 'image/png', 'detected_type' => 'image/jpeg', 'magic_bytes' => 'ffd8ffe0'], 'loc' => ['files', 'image'], 'msg' => 'File type mismatch: MIME type is image/png but magic numbers indicate image/jpeg', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content_type' => 'application/pdf', 'field_name' => 'document', 'filename' => 'test.pdf', 'magic_bytes' => '25504446']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content_type' => 'text/plain', 'field_name' => 'file', 'filename' => 'empty.txt', 'magic_bytes' => '']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['buffer_size' => 0], 'loc' => ['files', 'file'], 'msg' => 'File buffer is empty', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => '#!/bin/bash
echo hello', 'content_type' => 'application/x-sh', 'field_name' => 'file', 'filename' => 'script.sh']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => '', 'content_type' => 'text/plain', 'field_name' => 'file', 'filename' => 'empty.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['filename' => 'empty.txt', 'size' => 0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => 'content of file 1', 'content_type' => 'text/plain', 'field_name' => 'files', 'filename' => 'file1.txt'], ['content' => 'content of file 2', 'content_type' => 'text/plain', 'field_name' => 'files', 'filename' => 'file2.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['filenames' => ['file1.txt', 'file2.txt'], 'total_size' => 35], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => 'x', 'content_type' => 'text/plain', 'field_name' => 'file', 'filename' => 'large.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'File too large. Maximum size is 1MB'], 413, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => '<file2 content>', 'content_encoding' => 'text', 'content_type' => 'text/plain', 'field_name' => 'test2', 'filename' => 'test2.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['test2' => ['content' => '<file2 content>', 'content_type' => 'text/plain', 'filename' => 'test2.txt', 'headers' => [['content-disposition', 'form-data; name="test2"; filename="test2.txt"'], ['content-type', 'text/plain'], ['x-custom', 'f2']], 'size' => 15]], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => '<file1 content>', 'content_encoding' => 'text', 'field_name' => 'test1']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['test1' => '<file1 content>'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['some' => 'data'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => 'fake_jpeg_content_here', 'content_type' => 'image/jpeg', 'field_name' => 'image', 'filename' => 'photo.jpg']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['content_type' => 'image/jpeg', 'filename' => 'photo.jpg', 'size' => 22], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => 'file data here', 'content_encoding' => 'text', 'content_type' => 'text/plain', 'field_name' => 'file', 'filename' => 'upload.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['active' => 'true', 'age' => '25', 'file' => ['content' => 'file data here', 'content_type' => 'text/plain', 'filename' => 'upload.txt', 'size' => 14], 'username' => 'testuser'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => '<file1 content>', 'content_encoding' => 'text', 'content_type' => 'text/plain', 'field_name' => 'test1', 'filename' => 'test1.txt'], ['content' => '<file2 content>', 'content_encoding' => 'text', 'content_type' => 'text/plain', 'field_name' => 'test2', 'filename' => 'test2.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['test1' => ['content' => '<file1 content>', 'content_type' => 'text/plain', 'filename' => 'test1.txt', 'size' => 15], 'test2' => ['content' => '<file2 content>', 'content_type' => 'text/plain', 'filename' => 'test2.txt', 'size' => 15]], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => 'first file', 'content_encoding' => 'text', 'content_type' => 'text/plain', 'field_name' => 'files', 'filename' => 'file1.txt'], ['content' => 'second file', 'content_encoding' => 'text', 'content_type' => 'text/plain', 'field_name' => 'files', 'filename' => 'file2.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['files' => [['content' => 'first file', 'content_type' => 'text/plain', 'filename' => 'file1.txt', 'size' => 10], ['content' => 'second file', 'content_type' => 'text/plain', 'filename' => 'file2.txt', 'size' => 11]], 'tags' => ['python', 'rust', 'web']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['file' => null], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => 'optional file content', 'content_type' => 'text/plain', 'field_name' => 'file', 'filename' => 'optional.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['content_type' => 'text/plain', 'filename' => 'optional.txt', 'size' => 21], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => 'fake_pdf_content', 'content_type' => 'application/pdf', 'field_name' => 'document', 'filename' => 'report.pdf']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['content_type' => 'application/pdf', 'filename' => 'report.pdf', 'size' => 16], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'required', 'loc' => ['body', 'file'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlermultipart_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [['content' => '<file content>', 'content_encoding' => 'text', 'content_type' => 'text/plain', 'field_name' => 'test', 'filename' => 'test.txt']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['test' => ['content' => '<file content>', 'content_type' => 'text/plain', 'filename' => 'test.txt', 'size' => 14]], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 'e8b5a51d-11c8-3310-a6ab-367563f20686'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => '630eb68f-e0fa-5ecc-887a-7c7a62614681'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['date' => '2025-10-30'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['format' => 'date', 'value' => '2025-13-45'], 'loc' => ['path', 'date'], 'msg' => 'Invalid date format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['timestamp' => '2025-10-30T14:30:00Z'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['duration' => 'P1DT2H30M'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['amount' => '19.99'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['username' => 'alice'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_length' => 2, 'min_length' => 3], 'loc' => ['path', 'username'], 'msg' => 'String length must be at least 3', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_length' => 42, 'max_length' => 20], 'loc' => ['path', 'username'], 'msg' => 'String length must not exceed 20', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['owner' => 'spikard-labs', 'repo' => 'spikard-http'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[a-zA-Z0-9-]+$', 'value' => 'invalid@owner'], 'loc' => ['path', 'owner'], 'msg' => 'String does not match pattern', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => -100], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['date_param' => '2023-07-15'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['expected' => '\'alexnet\', \'resnet\' or \'lenet\''], 'input' => 'foo', 'loc' => ['path', 'model_name'], 'msg' => 'Input should be \'alexnet\', \'resnet\' or \'lenet\'', 'type' => 'enum']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['model_name' => 'alexnet'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 42.5], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'foobar', 'loc' => ['path', 'item_id'], 'msg' => 'Input should be a valid integer, unable to parse string as an integer', 'type' => 'int_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 42], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 2], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_23 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 3], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_24 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['gt' => 3], 'input' => 2, 'loc' => ['path', 'item_id'], 'msg' => 'Input should be greater than 3', 'type' => 'greater_than']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_25 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 42], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_26 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 3], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_27 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 2], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_28 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['order_id' => 'c892496f-b1fd-4b91-bdb8-b46f92df1716', 'service_id' => 1, 'user_id' => 'abc', 'version' => 1.0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_29 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not-a-uuid', 'loc' => ['path', 'id'], 'msg' => 'Input should be a valid UUID', 'type' => 'uuid_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_30 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['count' => '50'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_31 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => '550e8400-e29b-41d4-a716-446655440000'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_32 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['user_id' => '42'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_33 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['file_path' => 'home/johndoe/myfile.txt'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_34 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 'foobar'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_35 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['max_length' => 3], 'input' => 'foobar', 'loc' => ['path', 'item_id'], 'msg' => 'String should have at most 3 characters', 'type' => 'string_too_long']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_36 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'fo', 'loc' => ['path', 'item_id'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerpath_params_37 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 'ec38df32-ceda-4cfa-9b4a-1aeb94ad551a'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['offset' => ['-10']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['offset' => -10], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['threshold' => ['1.5e-3']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['threshold' => 0.0015], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['term' => ['foo']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['term' => 'foo'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['term' => ['ab']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_length' => 2, 'min_length' => 3], 'loc' => ['query', 'term'], 'msg' => 'String length must be at least 3', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['term' => ['this_is_way_too_long']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_length' => 21, 'max_length' => 10], 'loc' => ['query', 'term'], 'msg' => 'String length must not exceed 10', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['email' => ['user@example.com']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['email' => 'user@example.com'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['email' => ['invalid-email']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$', 'value' => 'invalid-email'], 'loc' => ['query', 'email'], 'msg' => 'String does not match pattern', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['limit' => ['5']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['limit' => 5], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['limit' => ['0']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['exclusive_minimum' => 0, 'value' => 0], 'loc' => ['query', 'limit'], 'msg' => 'Value must be greater than 0', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['offset' => ['0']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['offset' => 0], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['limit' => ['100']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['limit' => 100], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['limit' => ['101']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['maximum' => 100, 'value' => 101], 'loc' => ['query', 'limit'], 'msg' => 'Value must not exceed 100', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['ids' => ['1', '2', '3']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['ids' => [1, 2, 3]], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['ids' => ['1']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_items' => 1, 'min_items' => 2], 'loc' => ['query', 'ids'], 'msg' => 'Array must contain at least 2 items', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['tags' => ['a', 'b', 'c', 'd', 'e', 'f']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_items' => 6, 'max_items' => 5], 'loc' => ['query', 'tags'], 'msg' => 'Array must not contain more than 5 items', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['active' => ['']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['active' => false], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['email' => ['user@example.com']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['email' => 'user@example.com'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['email' => ['not-an-email']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['format' => 'email', 'value' => 'not-an-email'], 'loc' => ['query', 'email'], 'msg' => 'Invalid email format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['ip' => ['192.168.1.1']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['ip' => '192.168.1.1'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['ip' => ['999.999.999.999']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['format' => 'ipv4', 'value' => '999.999.999.999'], 'loc' => ['query', 'ip'], 'msg' => 'Invalid IPv4 address format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['ip' => ['2001:0db8:85a3:0000:0000:8a2e:0370:7334']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['ip' => '2001:0db8:85a3:0000:0000:8a2e:0370:7334'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['url' => ['https://example.com/path?query=value']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['url' => 'https://example.com/path?query=value'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_23 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['url' => ['not a uri']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['format' => 'uri', 'value' => 'not a uri'], 'loc' => ['query', 'url'], 'msg' => 'Invalid URI format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_24 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['host' => ['api.example.com']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['host' => 'api.example.com'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_25 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['quantity' => ['15']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['quantity' => 15], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_26 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['quantity' => ['17']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['multiple_of' => 5, 'value' => 17], 'loc' => ['query', 'quantity'], 'msg' => 'Value must be a multiple of 5', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_27 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['ids' => ['1', '2', '3', '4']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['ids' => [1, 2, 3, 4]], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_28 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['ids' => ['1', '2', '2', '3']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['duplicate_index' => 2, 'duplicate_value' => 2, 'unique_items' => true], 'loc' => ['query', 'ids'], 'msg' => 'Array items must be unique', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_29 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['tags' => ['python|rust|typescript', 'python|rust|typescript']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['tags' => ['python', 'rust', 'typescript']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_30 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['colors' => ['red;green;blue', 'red;green;blue']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['colors' => ['red', 'green', 'blue']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_31 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['keywords' => ['rust web framework', 'rust web framework']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['keywords' => ['rust', 'web', 'framework']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_32 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response([], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_33 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['tags' => ['apple']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['apple'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_34 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['flag' => ['1']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['flag' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_35 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['flag' => ['true']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['flag' => true], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_36 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['event_date' => ['2024-01-15']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['event_date' => '2024-01-15'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_37 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['timestamp' => ['2024-01-15T10:30:00Z']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['timestamp' => '2024-01-15T10:30:00Z'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_38 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['model' => ['vgg16']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['expected' => '\'alexnet\', \'resnet\' or \'lenet\''], 'input' => 'vgg16', 'loc' => ['query', 'model'], 'msg' => 'Input should be \'alexnet\', \'resnet\' or \'lenet\'', 'type' => 'enum']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_39 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['model' => ['alexnet']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['model' => 'alexnet'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_40 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['price' => ['0.01']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['price' => 0.01], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_41 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['value' => ['10']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 10], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_42 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['value' => ['1']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 1], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_43 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['value' => ['100']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 100], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_44 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['value' => ['49']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['value' => 49], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_45 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('foo bar 10', 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_46 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['query' => ['50']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('foo bar 50', 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_47 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['device_ids' => ['1', '2']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response([1, 2], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_48 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['q' => ['bar', 'foo']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['q' => ['foo', 'bar']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_49 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['query', 'device_ids'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_50 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response([], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_51 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['active' => ['true'], 'age' => ['30'], 'name' => ['john'], 'score' => ['95.5']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['active' => true, 'age' => 30, 'name' => 'john', 'score' => 95.5], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_52 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('foo bar None', 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_53 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['limit' => 10], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_54 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('foo bar None', 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_55 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['query' => ['baz']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('foo bar baz', 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_56 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['name' => ['hello world']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'hello world'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_57 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['name' => ['test&value=123']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['name' => 'test&value=123'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_58 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['email' => ['x@test.com'], 'special' => ['&@A.ac']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['email' => 'x@test.com', 'special' => '&@A.ac'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_59 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['query' => ['42.5']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 42.5, 'loc' => ['query', 'query'], 'msg' => 'Input should be a valid integer, unable to parse string as an integer', 'type' => 'int_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_60 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['query' => ['baz']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'baz', 'loc' => ['query', 'query'], 'msg' => 'Input should be a valid integer, unable to parse string as an integer', 'type' => 'int_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_61 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['query', 'query'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_62 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['query' => ['42']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('foo bar 42', 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_63 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['query', 'query'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_64 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['query' => ['baz']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('foo bar baz', 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_65 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['name' => ['this_is_way_too_long']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['max_length' => 10], 'input' => 'this_is_way_too_long', 'loc' => ['query', 'name'], 'msg' => 'String should have at most 10 characters', 'type' => 'string_too_long']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_66 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['name' => ['ab']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'ab', 'loc' => ['query', 'name'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_67 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['code' => ['abc123']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[0-9]{3,}$'], 'input' => 'abc123', 'loc' => ['query', 'code'], 'msg' => 'String should match pattern \'^[0-9]{3,}$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_68 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['item_query' => ['nonregexquery']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^fixedquery$'], 'input' => 'nonregexquery', 'loc' => ['query', 'item_query'], 'msg' => 'String should match pattern \'^fixedquery$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_69 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['item_query' => ['fixedquery']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_query' => 'fixedquery'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_70 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['item_id' => ['not-a-uuid']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not-a-uuid', 'loc' => ['query', 'item_id'], 'msg' => 'Input should be a valid UUID', 'type' => 'uuid_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerquery_params_71 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['item_id' => ['c892496f-b1fd-4b91-bdb8-b46f92df1716']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['item_id' => 'c892496f-b1fd-4b91-bdb8-b46f92df1716'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerrate_limit_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['request' => 'under-limit', 'status' => 'ok'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerrate_limit_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 429, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerrequest_id_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-request-id' => 'trace-123'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['echo' => 'trace-123', 'status' => 'preserved'], 200, ['x-request-id' => 'trace-123']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerrequest_id_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['status' => 'generated'], 200, ['x-request-id' => '<<uuid>>']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerrequest_id_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-request-id' => 'external-id'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['status' => 'no-request-id'], 200, ['x-request-id' => '<<absent>>']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerrequest_timeout_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['duration' => 'fast', 'status' => 'ok'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerrequest_timeout_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 408, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatic_files_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('Hello from static storage', 200, ['cache-control' => 'public, max-age=60', 'content-type' => 'text/plain']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatic_files_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('<!doctype html><h1>Welcome</h1>', 200, ['content-type' => 'text/html']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['data' => '{{ repeat \'x\' 2000 times }}'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Payload Too Large', 'message' => 'Request body size exceeds maximum allowed size of 1024 bytes'], 413, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 1, 'name' => 'Item 1'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'New Item'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['id' => 1, 'name' => 'New Item'], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['task' => 'process_data'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['message' => 'Task accepted for processing', 'task_id' => 'abc123'], 202, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 204, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['range' => 'bytes=0-1023'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('binary_data_1024_bytes', 206, ['Accept-Ranges' => 'bytes', 'Content-Length' => '1024', 'Content-Range' => 'bytes 0-1023/5000', 'Content-Type' => 'application/pdf']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['skip_template_expansion' => ['true']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response([], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-large-header' => '{{ repeat \'x\' 10000 times }}'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Request Header Fields Too Large', 'message' => 'Request headers exceed maximum allowed size of 8192 bytes'], 431, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 405, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['error' => 'Service Unavailable', 'message' => 'The service is temporarily unavailable. Please try again later.'], 503, ['Retry-After' => '60']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 301, ['location' => '/new-path']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 302, ['location' => '/target-path']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['if-none-match' => '"abc123"'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(null, 304, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = [];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response([], 307, ['location' => '/target-post']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'not valid json';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Invalid request format'], 400, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Not authenticated'], 401, ['www-authenticate' => 'Bearer']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['authorization' => 'Bearer valid_token'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Not enough permissions'], 403, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Item not found'], 404, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['data' => 'large_data'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Request timeout'], 408, ['Connection' => 'close']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['price' => 'not a number'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => '', 'loc' => ['body', 'name'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Rate limit exceeded. Try again in 60 seconds.'], 429, ['Retry-After' => '60', 'X-RateLimit-Limit' => '100', 'X-RateLimit-Remaining' => '0', 'X-RateLimit-Reset' => '1609459200']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Internal server error', 'status' => 500, 'title' => 'Internal Server Error', 'type' => 'https://spikard.dev/errors/internal-server-error'], 500, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstatus_codes_23 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Service temporarily unavailable'], 503, ['retry-after' => '120']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstreaming_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('LOG:\\u0000\\u0001\\u0002\\u0003|TAIL|\\u0007\\n', 200, ['content-type' => 'application/octet-stream']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstreaming_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('id,name,value\\n1,Alice,42\\n2,Bob,7\\n', 200, ['content-type' => 'text/csv']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerstreaming_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response('{"index":0,"payload":"alpha"}\\n{"index":1,"payload":"beta"}\\n{"index":2,"payload":"gamma"}\\n', 200, ['content-type' => 'application/x-ndjson']);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'tags[]=python&tags[]=rust&tags[]=typescript';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['tags' => ['python', 'rust', 'typescript']], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'user[name]=John%20Doe&user[email]=john@example.com&user[age]=30';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['user' => ['age' => 30, 'email' => 'john@example.com', 'name' => 'John Doe']], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'user-name=JohnDoe&contact.email=john%40example.com';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['contact.email' => 'john@example.com', 'user-name' => 'JohnDoe'], 201, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'username=ab';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_length' => 2, 'min_length' => 3, 'value' => 'ab'], 'loc' => ['body', 'username'], 'msg' => 'String length must be at least 3', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'account_id=INVALID123';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^ACC-[0-9]{6}$', 'value' => 'INVALID123'], 'loc' => ['body', 'account_id'], 'msg' => 'String does not match pattern \'^ACC-[0-9]{6}$\'', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'quantity=0';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_value' => 0, 'minimum' => 1], 'loc' => ['body', 'quantity'], 'msg' => 'Value must be at least 1', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'tags[]=single';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['actual_items' => 1, 'min_items' => 2], 'loc' => ['body', 'tags'], 'msg' => 'Array must contain at least 2 items', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'email=not-an-email';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['format' => 'email', 'value' => 'not-an-email'], 'loc' => ['body', 'email'], 'msg' => 'Invalid email format', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'price=not-a-number';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['value' => 'not-a-number'], 'loc' => ['body', 'price'], 'msg' => 'Value is not a valid integer', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = 'theme=dark&unknown_field=value';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['property' => 'unknown_field'], 'loc' => ['body', 'unknown_field'], 'msg' => 'Additional properties are not allowed', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['subscribe' => true, 'username' => 'johndoe'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => '', 'username' => 'johndoe'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['tags' => ['python', 'fastapi', 'web']], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['age' => 30, 'username' => 'johndoe'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['access_token' => 'johndoe', 'token_type' => 'bearer'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['email' => null, 'username' => 'johndoe'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[a-z0-9_]+$'], 'input' => 'john doe', 'loc' => ['body', 'username'], 'msg' => 'String should match pattern \'^[a-z0-9_]+$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => '', 'loc' => ['body', 'username'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['username' => 'johndoe'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['description' => 'Test & Development', 'name' => 'John Doe'], 200, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['max_length' => 20], 'input' => 'this_is_a_very_long_username_that_exceeds_limit', 'loc' => ['body', 'username'], 'msg' => 'String should have at most 20 characters', 'type' => 'string_too_long']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlerurl_encoded_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/x-www-form-urlencoded'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'ab', 'loc' => ['body', 'username'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_1 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['age' => 15, 'email' => 'invalid-email', 'name' => 'ab'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '3 validation errors in request', 'errors' => [['ctx' => ['ge' => 18], 'input' => 15, 'loc' => ['body', 'age'], 'msg' => 'Input should be greater than or equal to 18', 'type' => 'greater_than_equal'], ['ctx' => ['pattern' => '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'], 'input' => 'invalid-email', 'loc' => ['body', 'email'], 'msg' => 'String should match pattern \'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\'', 'type' => 'string_pattern_mismatch'], ['ctx' => ['min_length' => 3], 'input' => 'ab', 'loc' => ['body', 'name'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_2 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['profile' => ['contact' => ['email' => 'invalid']]];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'], 'input' => 'invalid', 'loc' => ['body', 'profile', 'contact', 'email'], 'msg' => 'String should match pattern \'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_3 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'price' => 10.0, 'tags' => ['tag1', 'tag2', 123]];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 123, 'loc' => ['body', 'tags', '2'], 'msg' => 'Input should be a valid unknown', 'type' => 'type_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_4 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'price' => 10.0, 'tags' => ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8', 'tag9', 'tag10', 'tag11']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8', 'tag9', 'tag10', 'tag11'], 'loc' => ['body', 'tags'], 'msg' => '["tag1","tag2","tag3","tag4","tag5","tag6","tag7","tag8","tag9","tag10","tag11"] has more than 10 items', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_5 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'price' => 10.0, 'tags' => []];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => [], 'loc' => ['body', 'tags'], 'msg' => '[] has less than 1 item', 'type' => 'validation_error']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_6 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item', 'price' => 'not_a_float'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not_a_float', 'loc' => ['body', 'price'], 'msg' => 'Input should be a valid number, unable to parse string as a number', 'type' => 'float_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_7 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = ['q' => ['test']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['headers', 'x-token'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_8 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not-a-uuid', 'loc' => ['path', 'item_id'], 'msg' => 'Input should be a valid UUID, invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 0', 'type' => 'uuid_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_9 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['is_active' => ['maybe'], 'q' => ['test']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'maybe', 'loc' => ['query', 'is_active'], 'msg' => 'Input should be a valid boolean, unable to interpret input', 'type' => 'bool_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_10 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['created_at' => 'not-a-datetime', 'name' => 'Item', 'price' => 10.0];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not-a-datetime', 'loc' => ['body', 'created_at'], 'msg' => 'Input should be a valid datetime', 'type' => 'datetime_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_11 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = [];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['expected' => '\'alexnet\', \'resnet\' or \'lenet\''], 'input' => 'invalid_model', 'loc' => ['path', 'model_name'], 'msg' => 'Input should be \'alexnet\', \'resnet\' or \'lenet\'', 'type' => 'enum']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_12 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = '{"name": "Item", "price": }';
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => 'Invalid request format'], 400, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_13 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Item'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => ['name' => 'Item'], 'loc' => ['body', 'price'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_14 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => null, 'loc' => ['query', 'q'], 'msg' => 'Field required', 'type' => 'missing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_15 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'X', 'price' => -10, 'quantity' => 'not_a_number'];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '3 validation errors in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'X', 'loc' => ['body', 'name'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short'], ['ctx' => ['gt' => 0], 'input' => -10, 'loc' => ['body', 'price'], 'msg' => 'Input should be greater than 0', 'type' => 'greater_than'], ['input' => 'not_a_number', 'loc' => ['body', 'quantity'], 'msg' => 'Input should be a valid integer, unable to parse string as an integer', 'type' => 'int_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_16 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['content-type' => 'application/json'];
        $this->expectedCookies = [];
        $this->expectedQuery = [];
        $this->expectedBody = ['name' => 'Product', 'price' => 10.0, 'seller' => ['address' => ['city' => 'SF', 'zip_code' => '123'], 'name' => 'Jo']];
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '3 validation errors in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'SF', 'loc' => ['body', 'seller', 'address', 'city'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short'], ['ctx' => ['min_length' => 5], 'input' => '123', 'loc' => ['body', 'seller', 'address', 'zip_code'], 'msg' => 'String should have at least 5 characters', 'type' => 'string_too_short'], ['ctx' => ['min_length' => 3], 'input' => 'Jo', 'loc' => ['body', 'seller', 'name'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_17 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['price' => ['0'], 'q' => ['test']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['gt' => 0], 'input' => '0', 'loc' => ['query', 'price'], 'msg' => 'Input should be greater than 0', 'type' => 'greater_than']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_18 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['limit' => ['101'], 'q' => ['test']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['le' => 100], 'input' => '101', 'loc' => ['query', 'limit'], 'msg' => 'Input should be less than or equal to 100', 'type' => 'less_than_equal']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_19 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['q' => ['test'], 'skip' => ['not_a_number']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['input' => 'not_a_number', 'loc' => ['query', 'skip'], 'msg' => 'Input should be a valid integer, unable to parse string as an integer', 'type' => 'int_parsing']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_20 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['q' => ['this_is_a_very_long_query_string_that_exceeds_maximum_length_limit_for_this_parameter']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['max_length' => 50], 'input' => 'this_is_a_very_long_query_string_that_exceeds_maximum_length_limit_for_this_parameter', 'loc' => ['query', 'q'], 'msg' => 'String should have at most 50 characters', 'type' => 'string_too_long']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_21 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['q' => ['ab']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['min_length' => 3], 'input' => 'ab', 'loc' => ['query', 'q'], 'msg' => 'String should have at least 3 characters', 'type' => 'string_too_short']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}

final class Handlervalidation_errors_22 implements HandlerInterface {
    public function __construct() {
        $this->expectedHeaders = ['x-token' => 'test-token'];
        $this->expectedCookies = [];
        $this->expectedQuery = ['q' => ['invalid!']];
        $this->expectedBody = null;
    }

    public function matches(Request $request): bool
    {
        if (!$this->matchQuery($request->queryParams)) {
            return false;
        }
        if (!$this->matchHeaders($request->headers)) {
            return false;
        }
        if (!$this->matchCookies($request->cookies)) {
            return false;
        }
        if (!$this->matchBody($request->body)) {
            return false;
        }
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response(['detail' => '1 validation error in request', 'errors' => [['ctx' => ['pattern' => '^[a-zA-Z0-9_-]+$'], 'input' => 'invalid!', 'loc' => ['query', 'q'], 'msg' => 'String should match pattern \'^[a-zA-Z0-9_-]+$\'', 'type' => 'string_pattern_mismatch']], 'status' => 422, 'title' => 'Request Validation Failed', 'type' => 'https://spikard.dev/errors/validation-error'], 422, []);
    }

    private function matchQuery(array $actual): bool
    {
        if ($this->expectedQuery === []) {
            return $actual === [];
        }
        if (\count($actual) !== \count($this->expectedQuery)) {
            return false;
        }
        foreach ($this->expectedQuery as $key => $expectedValues) {
            if (!\array_key_exists($key, $actual)) {
                return false;
            }
            $candidate = $actual[$key];
            $normalizedCandidate = \is_array($candidate) ? $candidate : [$candidate];
            \sort($normalizedCandidate);
            $normalizedExpected = $expectedValues;
            \sort($normalizedExpected);
            foreach ($normalizedExpected as $val) {
                if (!\in_array($val, $normalizedCandidate, true)) {
                    return false;
                }
            }
        }
        return true;
    }

    private function matchHeaders(array $actual): bool
    {
        if ($this->expectedHeaders === []) {
            return true;
        }
        $normalized = [];
        foreach ($actual as $k => $v) {
            $normalized[strtolower($k)] = $v;
        }
        return $this->arrayEquals($normalized, $this->expectedHeaders);
    }

    private function matchCookies(array $actual): bool
    {
        if ($this->expectedCookies === []) {
            return true;
        }
        return $this->arrayEquals($actual, $this->expectedCookies);
    }

    private function matchBody(mixed $actual): bool
    {
        if ($this->expectedBody === null) {
            return true;
        }
        return json_encode($actual) === json_encode($this->expectedBody);
    }

    /** @param array<string, array<int, string>|string> $a */
    private function arrayEquals(array $a, array $b): bool
    {
        ksort($a);
        ksort($b);
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                return false;
            }
            $aval = $value;
            $bval = $b[$key];
            if (is_array($aval) && is_array($bval)) {
                sort($aval);
                sort($bval);
                if ($aval !== $bval) {
                    return false;
                }
            } elseif ($aval !== $bval) {
                return false;
            }
        }
        return count($a) === count($b);
    }

    /** @var array<string, string> */
    private array $expectedHeaders;
    /** @var array<string, string> */
    private array $expectedCookies;
    /** @var array<string, array<int, string>> */
    private array $expectedQuery;
    private mixed $expectedBody;
}
