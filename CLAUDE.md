<!--
ðŸ¤– GENERATED FILE - DO NOT EDIT DIRECTLY
===========================================

This file was automatically generated by ai-rulez from ai-rulez.yaml.

âš ï¸  IMPORTANT FOR AI ASSISTANTS AND DEVELOPERS:
- DO NOT modify this file directly
- DO NOT add, remove, or change rules in this file
- Changes made here will be OVERWRITTEN on next generation

âœ… TO UPDATE RULES:
1. Edit the source configuration: ai-rulez.yaml
2. Regenerate this file: ai-rulez generate
3. The updated CLAUDE.md will be created automatically

ðŸ“ Generated: 2025-11-28 16:07:18
ðŸ“ Source: ai-rulez.yaml
ðŸŽ¯ Target: CLAUDE.md
ðŸ“Š Content: 26 rules, 12 sections

Learn more: https://github.com/Goldziher/ai-rulez
===========================================
-->

# spikard

Spikard is a Rust-centric multi-language toolkit that provides a core library,
command-line interface, and HTTP runtime with tower-http middleware surfaced
through Python (PyO3), Node.js (napi-rs), Ruby (magnus), PHP (ext-php-rs), and
WebAssembly bindings to build and validate typed web services. The monorepo couples
Rust 2024 workspace crates with Python/uv, Node.js/pnpm, Ruby, PHP/Composer, and
taskfile automation, backed by extensive fixture-driven tests to ensure consistent
request handling across platforms.


Version: 1.0.0

Generated on 2025-11-28 16:07:18

Total content: 26 rules, 12 sections

## Cross-Language Error Boundaries

**Priority:** critical

Rust code in `crates/spikard`, `crates/spikard-http`, and the binding crates must
avoid panics; expose fallible APIs as `Result<T, E>` and propagate with `?`. When
exporting to Python (`crates/spikard-py/src`), always return `PyResult<T>` and convert
domain failures with `PyErr::new_err(...)`; for Node (`crates/spikard-node/src`),
return `napi::Result<T>` and build errors via `napi::Error::from_reason`; for PHP
(`crates/spikard-php/src`), return ext-php-rs Result and throw exceptions. Never let
an unwrap cross the FFI boundary.


**Structured error payloads Â· FFI boundaries Â· Validation schema alignment**

Error Structure: All errors return JSON { "error": string, "code": string, "details": {} }. Rust uses Result<T, E> with thiserror. Python: PyResult<T> â†’ PyErr. Node: napi::Result<T> â†’ napi::Error. Ruby: raise_error. PHP: ext-php-rs Result â†’ exceptions. All preserve same JSON payload.

FFI Boundaries: Rust core returns Result<T, E> to handlers. Adapters (PyO3/napi/magnus/ext-php-rs) convert to language errors while preserving JSON. Python: PyErr::new_err(json_string). Node: Error::from_reason(json_string). PHP: throw exceptions. Never let unwrap cross FFI boundary.

Validation: HTTP handlers validate against testing_data/{headers,cookies,json_bodies}. Reject with errors matching testing_data/validation_errors/schema.json. Assert in packages/python/tests/test_all_fixtures.py. Keep schema.json in sync with handler code.


## Fixture-Aligned Error Handling

**Priority:** critical

Keep every fallible path in the Rust workspace (`crates/spikard`, `crates/spikard-http`,
bindings crates) returning the structured payload described in
`testing_data/validation_errors/schema.json`. Reuse the shared error constructor so
Python (`crates/spikard-py`), Node (`crates/spikard-node`), Ruby (`crates/spikard-rb`),
and PHP (`crates/spikard-php`) adapters raise translated host-language errors while
preserving the same JSON body that `packages/python/tests/test_all_fixtures.py` asserts on.


## Fixture-Backed Testing

**Priority:** critical

Every feature change must expand the Python-driven integration suite in
`packages/python/tests/` and keep the JSON fixtures under `testing_data/` in sync.
Prefer validating new scenarios by adding fixture files and asserting them in
`packages/python/tests/test_all_fixtures.py`. Run `task test` locally before merging
so the Rust, Python, and JavaScript checks that CI executes stay green.


## Fixture-Driven Testing

**Priority:** critical

Every feature change must extend the pytest suites in packages/python/tests/ by loading
fixtures through packages/python/tests/conftest.py and invoking task test before merging;
new fixture collections belong in testing_data/ with a runnable illustration under
examples/ so automated coverage, demos, and docs stay synchronized.


## Fixture-First Testing

**Priority:** critical

When adding behavior, introduce or update fixtures under the relevant `testing_data/*`
directory and extend the parametrized suites in `packages/python/tests/test_all_fixtures.py`,
`packages/python/tests/test_integration_query_params.py`, and peers. Do not ship without
running `task test` plus the language targets (`task test:rust`, `task test:python`) so
local runs match CI.


**Fixture-driven Â· Multi-language parity Â· 95% coverage Â· Real infrastructure**

Fixture Organization: Central `testing_data/` with JSON files per scenario (headers, cookies, bodies, errors, edge_cases). Each directory has schema.json. Python tests parametrized: test_all_fixtures.py loads all JSONs. Rust: unit tests embed JSON; integration tests load from testing_data/.

Coverage: Rust 95% minimum (tarpaulin). Python/JS/Ruby/PHP 80%+ minimum. Enforce in CI; fail if < threshold.

Three-Tier Testing: Unit (pure functions, fast), Integration (real DB, PostgreSQL, fixtures), E2E (full HTTP stack, all bindings).

Running: `cargo test -p spikard`, `uv run pytest packages/python/tests/test_all_fixtures.py`, `pnpm test`, `bundle exec rspec`, `composer test`. All: `task test`.


## Handler Trait Abstraction

**Priority:** critical

In `crates/spikard-http`, define language-agnostic Handler trait with
`Pin<Box<dyn Future<Output = HandlerResult> + Send>>` return type. Language bindings
(`spikard-py`, `spikard-node`, `spikard-rb`, `spikard-php`) implement this trait with
Arc<dyn Handler> wrappers. The HTTP server accepts `Vec<(Route, Arc<dyn Handler>)>` enabling
clean separation: spikard-http has zero FFI dependencies, all Python/Node/Ruby/PHP/WASM code
lives in binding crates.


## PHP PSR Compliance & Standards Enforcement

**Priority:** critical

All PHP code in `packages/php/src/` must enforce PSR-4 (autoloading), PSR-12 (coding style),
and PSR-7 (HTTP interfaces). Use PHPStan level max (9) for static analysis; never suppress
errors with @phpstan-ignore directives. Declare strict_types=1 at the top of every file.
Use typed properties and return types on all methods; avoid mixed types. PHPUnit testing
must cover 80%+ of code; use data providers for parametrized tests. Composer dependencies
are committed (composer.lock) and managed strictly. Never use eval(), suppress errors with
@, or maintain global state. Methods must be <15 lines; use composition over inheritance.


## PyO3 Async Performance

**Priority:** critical

For async Python handlers in `crates/spikard-py/src/handler.rs`, use
`pyo3_async_runtimes::tokio::into_future()` to convert Python coroutines directly to
Rust futures, eliminating spawn_blocking overhead. Initialize the event loop once with
`TaskLocals` stored in a `OnceCell` to avoid per-request event loop creation. Ensure
GIL is released before awaiting Rust futures: `Python::attach(|py| {...}).await`
not `Python::with_gil(|py| {...}).await`.


## PyO3 Extension Module Management

**Priority:** critical

The `extension-module` feature in `crates/spikard-py/Cargo.toml` must NOT be in default
featuresâ€”it breaks linking for binaries that embed Python (like spikard-cli). Configure
maturin in `pyproject.toml` with `features = ["extension-module"]` so Python extension
modules build correctly. Binaries (CLI, tests) build without extension-module to link
libpython; extensions (maturin builds) enable it for manylinux compliance.


**Python 3.10+ Â· Functional-first Â· msgspec Â· Fully async Â· Strict typing**
- Python 3.10+; match/case, union types (X | Y), structural pattern matching
- msgspec ONLY (NEVER pydantic); msgspec.Struct with slots=True, frozen=True
- Full type hints: ParamSpec, TypeVar/Generic[T], mypy --strict; never use Any
- Functional patterns: pure functions, composition, immutability
- Fully async: anyio.Path, httpx AsyncClient, asyncpg, asyncio.gather
- Function-based tests ONLY (*_test.py); pytest fixtures, 95% coverage
- Never: class tests, pydantic, sync I/O in async, Any type, Optional[T]


**Rust 2024 Â· High strictness Â· clippy -D warnings Â· 95% coverage Â· Zero unwrap**
- Rust 2024; cargo fmt, clippy -D warnings (zero tolerance)
- Result<T, E> for errors; thiserror for custom errors; NEVER .unwrap() in production
- Testing: 95% minimum coverage (tarpaulin); unit/integration/doc tests
- Async: Tokio 1.x, 'static constraints, Send+Sync bounds
- FFI: isolated modules, pointer validation, SAFETY comments, error conversion at boundaries
- Code quality: RAII, explicit lifetimes, builder pattern, no panics


**TypeScript 5.x Â· Strictest typing Â· No any/object Â· Generics required**
- Enable ALL strict flags: strict, noUncheckedIndexedAccess, exactOptionalPropertyTypes
- Ban any and object types; use unknown with guards
- Generics with constraints, satisfies operator, const assertions
- Tests: .spec.ts next to source files; vitest, 80%+ coverage
- Functional: pure functions, map/filter/reduce, immutability, readonly
- Biome for linting/formatting; pnpm â‰¥10.17, pnpm-lock.yaml committed
- React: function components, custom hooks, proper prop typing
- Never: any/object types, non-null assertions !, || for defaults


## ext-php-rs Binding Configuration

**Priority:** critical

PHP bindings via ext-php-rs in `crates/spikard-php/` must maintain type safety across the
Rust-PHP FFI boundary. Configure ext-php-rs properly in Cargo.toml and ensure all Rust
errors convert to PHP exceptions with structured JSON payloads (error, code, details).
Never expose raw Rust panics; all fallible paths must return ext-php-rs Result types that
translate to thrown PHP exceptions. Maintain PSR-4 autoloading in `packages/php/src/`
and ensure PHPStan level max static analysis passes without @phpstan-ignore directives.


## Binding-Level Configuration Only

**Priority:** high

Language bindings (spikard-py, spikard-node, spikard-rb, spikard-php) must NOT duplicate
middleware logic. All middleware lives in Rust (tower-http). Bindings only expose configuration
APIs that construct ServerConfig and pass it to the Rust server. Python uses PyO3, TypeScript
uses napi-rs, Ruby uses magnus, PHP uses ext-php-rs.


**ADRs in docs/adr/ Â· Examples in examples/ Â· rustdoc/JSDoc/docstrings**

ADRs (docs/adr/): 0001 (architecture, layering), 0002 (tower-http, config), 0003 (fixtures, msgspec), 0005 (lifecycle hooks), 0006 (async, streaming). Update when architecture changes.

Code Documentation: Rust rustdoc on ALL public items with examples. Python docstrings (NumPy style) with type hints. TypeScript JSDoc; .d.ts auto-generated by napi-rs. Ruby RBS files with YARD docs. PHP PHPDoc with type declarations and @psalm annotations.

Examples (examples/): Runnable illustrations for Python, Node, Ruby, PHP, WASM. Load fixtures from testing_data/; show error handling.


## HTTP Error Contracts

**Priority:** high

When updating handlers in crates/spikard-http, translate domain failures into the JSON
payloads maintained under testing_data/status_codes and testing_data/validation_errors;
add the matching fixture files and assertions in packages/python/tests/test_all_fixtures.py
or the focused integration suites, and keep every testing_data/**/schema.json aligned
with the new variants.


## HTTP Input Validation

**Priority:** high

Handlers under `crates/spikard-http/src` must validate headers, cookies, and payloads
against the schemas in `testing_data/headers`, `testing_data/cookies`, and
`testing_data/json_bodies`. Reject unexpected or malformed values with structured
errors returned to the caller, and cover each guard with an integration test tied to
the corresponding fixture set.


**Tower-HTTP middleware stack Â· OpenAPI codegen Â· Lifecycle hooks**

Middleware Stack: Compression â†’ RateLimit â†’ Timeout â†’ RequestId â†’ Auth â†’ UserAgent â†’ Handler. All configurable via CompressionConfig, RateLimitConfig. Auth validates against testing_data/headers/*.json.

Handler Trait: Language-agnostic `trait Handler { fn handle(&self, req: Request) -> Pin<Box<dyn Future<...>>> }`. Binding wrappers implement Arc<dyn Handler>. HTTP server accepts `Vec<(Route, Arc<dyn Handler>)>`.

Lifecycle Hooks (docs/adr/0005-lifecycle-hooks.md): onRequest, preValidation, preHandler, onResponse, onError. Zero-cost: Option<Arc<dyn Fn>>. Async via pyo3_async_runtimes (Python) and ThreadsafeFunction (TypeScript).


## Header & Cookie Security

**Priority:** high

Authentication, header, and cookie code must enforce the scenarios captured in
testing_data/headers and testing_data/cookiesâ€”reject deviations from those schemas, add
explicit fixtures plus assertions in packages/python/tests/test_integration_query_params.py
for new header names or cookie attributes, and keep Secure/HttpOnly/SameSite defaults
intact.


## Layered Code Organization

**Priority:** high

Implement cross-cutting logic in `crates/spikard/src` and expose it through thin adapters
in `crates/spikard-http`, `crates/spikard-py`, `crates/spikard-node`, `crates/spikard-rb`,
`crates/spikard-php`, and `crates/spikard-wasm`. Keep build metadata confined to each
binding's manifest (`pyproject.toml`, `crates/spikard-node/package.json`,
`crates/spikard-wasm/package.json`, `composer.json`) and register new workflows in
`Taskfile.yaml` so `task build`/`task lint` continue to orchestrate the monorepo.


## Lifecycle Hooks Implementation

**Priority:** high

Lifecycle hooks (onRequest, preValidation, preHandler, onResponse, onError) must follow
the zero-cost design in `docs/adr/0005-lifecycle-hooks.md`: use Option<Arc<dyn Fn>> for
conditional execution (<1ns when not registered), provide async support via
pyo3_async_runtimes for Python and ThreadsafeFunction for TypeScript, and allow hooks to
short-circuit with early responses. Implement HookResult enum with Continue/ShortCircuit
variants.


**PHP 8.2+ Â· ext-php-rs FFI Â· PSR compliance Â· PHPStan Â· Composer**
- PHP 8.2+ with .php-version; strict_types=1 in all files
- ext-php-rs for Rust FFI bindings; maintain type safety across boundary
- PSR compliance: PSR-4 (autoloading), PSR-12 (coding style), PSR-7 (HTTP)
- PHPStan level max for static analysis; never use @phpstan-ignore
- Composer for dependency management; composer.lock committed
- PHPUnit testing: 80%+ coverage, data providers for parametrized tests
- Code quality: methods <15 lines, typed properties, return types required
- Never: mixed types, eval(), suppress errors with @, global state


## Request Surface Security

**Priority:** high

Guard every HTTP-facing change with the validation strategy captured in
`docs/adr/0003-validation-and-fixtures.md`: enforce cookie rules via
`testing_data/cookies/*.json`, headers/auth via `testing_data/headers/*.json`, and
CORS expectations via `testing_data/cors/*.json`. Strip secrets from logs and ensure
new handlers never bypass the existing validator layer before reaching business logic.


**Ruby 3.2+ Â· RBS type definitions Â· Steep Â· RSpec Â· Rubocop**
- Ruby 3.2+ with .ruby-version; rbenv for version management
- RBS files in sig/ directory parallel to source: lib/foo.rb â†’ sig/foo.rbs
- Steep for type checking; avoid Any types, use union types explicitly
- RSpec testing: 80%+ coverage, function-like tests
- Rubocop with auto-fix: line length â‰¤120
- Code quality: methods <10 lines, guard clauses, modules for mixins


**Multi-crate Rust workspace Â· Layered binding architecture Â· Fixture-driven testing**

Rust Workspace: `crates/spikard/` (core), `crates/spikard-http/` (tower-http), `crates/spikard-cli/` (CLI), `crates/spikard-py/` (PyO3), `crates/spikard-node/` (napi-rs), `crates/spikard-rb/` (magnus), `crates/spikard-php/` (ext-php-rs), `crates/spikard-wasm/` (wasm-bindgen).

Binding Principles: All middleware in Rust; bindings expose config APIs only. Language-neutral Handler trait: `Pin<Box<dyn Future<Output = HandlerResult> + Send>>`. Each binding wraps with Arc<dyn Handler>. No PyO3/napi/magnus/ext-php-rs in core crates.

Python & Testing: Package scaffold `packages/python/spikard`; integration tests in `packages/python/tests/` with conftest.py. Shared fixtures `testing_data/` with schema.json per scenario. Fixture-driven: `testing_data/{headers,cookies,json_bodies,validation_errors,edge_cases}/`. Coverage: 95% Rust core, 80%+ Python/JS/Ruby/PHP.


**Taskfile.yaml Â· Multi-language coordination Â· Dependency management Â· CI/CD parity**

Root Commands: `task setup` (install tooling, build bindings), `task update` (upgrade all), `task build` (all languages), `task lint` (mypy, clippy, biome, steep, phpstan), `task format` (all), `task test` (all suites).

Language-Specific: `task rust:build`, `task python:build` (maturin), `task python:test`, `task js:build`, `task js:test`, `task ruby:build`, `task php:build`, `task wasm:build`.

Dependency Files (committed): Cargo.lock, uv.lock, pnpm-lock.yaml, Gemfile.lock, composer.lock. All mandatory in version control.


## Tower-HTTP Middleware Stack

**Priority:** high

All standard middleware (compression, rate limiting, timeouts, graceful shutdown, static
files, request IDs) is implemented in Rust using tower-http and exposed via typed
ServerConfig. Configuration structs (CompressionConfig, RateLimitConfig, StaticFilesConfig,
etc.) must be forwarded to Python/TypeScript/Ruby bindings with proper type safety.
See `docs/adr/0002-runtime-and-middleware.md` for the complete middleware stack order
and configuration options.


**WebAssembly Â· wasm-bindgen Â· wasm-pack Â· WASI compatibility**
- wasm-bindgen for FFI to JavaScript; wasm-pack for bundling
- Minimize binary size: tree-shake unused code, opt-level=z with lto=true
- No blocking operations: all I/O async or via workers
- Testing: wasm-pack test for unit tests, browser/node environments
- Type safety: proper type boundaries at JS/WASM interface, no Any types
- Never: spawn threads (limited WASM threading), blocking allocations


## Workspace Organization

**Priority:** high

Place reusable domain types and logic in crates/spikard/src/ and keep feature-specific
glue isolated within sibling crates (spikard-http, spikard-cli, bindings); mirror module
changes across Cargo manifests and refresh the relevant docs/adr/* notes whenever the
layering or routing changes.


## Zero-Copy JSON to Python Conversion

**Priority:** high

Convert `serde_json::Value` to Python objects using direct PyO3 type construction
(PyDict::new, PyList::empty, PyString::new, etc.) instead of serialize-to-JSON-string
then json.loads. This zero-copy approach in `crates/spikard-py/src/handler.rs::json_to_python()`
eliminates 30-40% conversion overhead. Match on Value variants and recursively build
native Python objects.


## Async-Friendly Performance

**Priority:** medium

Respect the project's zero-copy serialization choicesâ€”keep Rust structs `serde`-ready
so bindings reuse them, lean on the adapters documented in `docs/adr/0003-validation-and-fixtures.md`,
and wrap heavy work in async-safe boundaries (`tokio::task::spawn_blocking` in Rust,
`pyo3::Python::allow_threads` when calling back into Python). Reuse fixture loaders such
as `packages/python/tests/fixture_app.py` instead of re-parsing schema files per request.


## Consistent Tooling

**Priority:** medium

Honor the repo formatters and linters before committing: run `cargo fmt` (configured by
`rustfmt.toml`), rely on Biome per `biome.json` for JavaScript/TypeScript, and manage
Python tooling through `uv` (`uv.lock`). Invoke them via `task lint` so local changes
match the CI configuration.


## Cross-Target Performance

**Priority:** medium

Consolidate heavy computation inside the shared Rust core (crates/spikard) and expose
thin bindings in crates/spikard-py, packages/python, crates/spikard-node, crates/spikard-rb,
crates/spikard-php, and crates/spikard-wasm; stress-test large or deeply nested payloads with
testing_data/edge_cases and verify optimized builds via task build:rust, task build:py,
task build:node, task build:ruby, and task build:php.


## Lint & Formatting Discipline

**Priority:** medium

Before committing, run task lint to honor the Biome settings in biome.json for JS/TS,
format Rust with cargo fmt --manifest-path Cargo.toml configured by rustfmt.toml, and
sync Python dependencies with uv so pyproject.toml and uv.lock stay consistentâ€”avoid
introducing divergent toolchains or unchecked formatting drift.


## Optimized Serialization Path

**Priority:** medium

Follow the conversion patterns captured in `docs/adr/0003-validation-and-fixtures.md`
so data exchanged between Rust and Python leverages `msgspec` without extra JSON hops.
Share zero-copy buffers where possible, and use `task build:rust` (release mode) when
benchmarking or publishing bindings to avoid debug-performance regressions.


## Workspace Separation

**Priority:** medium

Keep language-neutral logic inside `crates/spikard/src` and limit each binding crate
(`spikard-py`, `spikard-node`, `spikard-wasm`) to thin adapters over that core. When
introducing new modules, register them in the relevant `Cargo.toml`, mirror usage in
`examples/`, and avoid duplicating business rules across bindings.
