$schema: https://github.com/Goldziher/ai-rulez/schema/ai-rules-v2.schema.json
agents:
    - name: rust-polyglot-architect
      description: Designs Rust-first APIs and keeps Python, Node, and WASM bindings aligned with shared memory-safety and error contracts.
      priority: critical
    - name: integration-qa
      description: Expands fixture-driven coverage and hunts for regressions across Rust, Python, and Node integration suites.
      priority: high
    - name: docs-strategist
      description: Maintains developer guides, upgrade notes, and architecture references so contributors can follow cross-language patterns.
      priority: medium
    - name: build-and-ci-ops
      description: Curates Taskfile, CI, and release automation to keep multi-language toolchains reproducible.
      priority: high
    - name: workspace-architect
      description: Structures Cargo workspaces, feature flags, and dependency graph to avoid duplication across crates.
      priority: high
    - name: interop-build-engineer
      description: Ensures binding build scripts for PyO3, napi-rs, and wasm-pack stay in sync and optimized.
      priority: medium
    - name: fixture-tester
      description: Evolves `testing_data` fixtures and validation schemas so every handler respects documented contracts.
      priority: high
    - name: docs-scribe
      description: Generates agent handbooks and CLAUDE briefs that summarize current rules and workflows.
      priority: medium
commands: []
mcp_servers:
    - args:
        - -y
        - ai-rulez@latest
        - mcp
      command: npx
      description: AI-Rulez MCP server for configuration management
      name: ai-rulez
metadata:
    description: Spikard is a Rust-centric multi-language toolkit that provides a core library, command-line interface, and HTTP runtime surfaced through Python (PyO3), Node.js (napi-rs), and WebAssembly bindings to build and validate typed web services. The monorepo couples Rust 2024 workspace crates with Python/uv, Node.js/pnpm, and taskfile automation, backed by extensive fixture-driven tests to ensure consistent request handling across platforms.
    name: spikard
    version: 1.0.0
outputs:
    - path: CLAUDE.md
    - naming_scheme: '{name}.md'
      path: .claude/agents/
      type: agent
presets:
    - claude
rules:
    - content: Rust code in `crates/spikard`, `crates/spikard-http`, and the binding crates must avoid panics; expose fallible APIs as `Result<T, E>` and propagate with `?`. When exporting to Python (`crates/spikard-py/src`), always return `PyResult<T>` and convert domain failures with `PyErr::new_err(...)`; for Node (`crates/spikard-node/src`), return `napi::Result<T>` and build errors via `napi::Error::from_reason`. Never let an unwrap cross the FFI boundary.
      name: Cross-Language Error Boundaries
      priority: critical
    - content: Every feature change must expand the Python-driven integration suite in `packages/python/tests/` and keep the JSON fixtures under `testing_data/` in sync. Prefer validating new scenarios by adding fixture files and asserting them in `packages/python/tests/test_all_fixtures.py`. Run `task test` locally before merging so the Rust, Python, and JavaScript checks that CI executes stay green.
      name: Fixture-Backed Testing
      priority: critical
    - content: Handlers under `crates/spikard-http/src` must validate headers, cookies, and payloads against the schemas in `testing_data/headers`, `testing_data/cookies`, and `testing_data/json_bodies`. Reject unexpected or malformed values with structured errors returned to the caller, and cover each guard with an integration test tied to the corresponding fixture set.
      name: HTTP Input Validation
      priority: high
    - content: Follow the conversion patterns captured in `docs/design/msgspec-type-conversion.md` so data exchanged between Rust and Python leverages `msgspec` without extra JSON hops. Share zero-copy buffers where possible, and use `task build:rust` (release mode) when benchmarking or publishing bindings to avoid debug-performance regressions.
      name: Optimized Serialization Path
      priority: medium
    - content: Keep language-neutral logic inside `crates/spikard/src` and limit each binding crate (`spikard-py`, `spikard-node`, `spikard-wasm`) to thin adapters over that core. When introducing new modules, register them in the relevant `Cargo.toml`, mirror usage in `examples/`, and avoid duplicating business rules across bindings.
      name: Workspace Separation
      priority: medium
    - content: 'Honor the repo formatters and linters before committing: run `cargo fmt` (configured by `rustfmt.toml`), rely on Biome per `biome.json` for JavaScript/TypeScript, and manage Python tooling through `uv` (`uv.lock`). Invoke them via `task lint` so local changes match the CI configuration.'
      name: Consistent Tooling
      priority: medium
    - content: Keep every fallible path in the Rust workspace (`crates/spikard`, `crates/spikard-http`, bindings crates) returning the structured payload described in `testing_data/validation_errors/schema.json`. Reuse the shared error constructor so Python (`crates/spikard-py`) and Node (`crates/spikard-node`) adapters raise translated host-language errors while preserving the same JSON body that `tests/test_all_fixtures.py` asserts on.
      name: Fixture-Aligned Error Handling
      priority: critical
    - content: When adding behavior, introduce or update fixtures under the relevant `testing_data/*` directory and extend the parametrized suites in `tests/test_all_fixtures.py`, `tests/test_integration_query_params.py`, and peers. Do not ship without running `task test` plus the language targets (`task test:rust`, `task test:python`) so local runs match CI.
      name: Fixture-First Testing
      priority: critical
    - content: 'Guard every HTTP-facing change with the validation strategy captured in `docs/design/01-validation-strategy.md`: enforce cookie rules via `testing_data/cookies/*.json`, headers/auth via `testing_data/headers/*.json`, and CORS expectations via `testing_data/cors/*.json`. Strip secrets from logs and ensure new handlers never bypass the existing validator layer before reaching business logic.'
      name: Request Surface Security
      priority: high
    - content: Respect the project’s zero-copy serialization choices—keep Rust structs `serde`-ready so bindings reuse them, lean on the `msgspec` adapters documented in `docs/design/msgspec-type-conversion.md`, and wrap heavy work in async-safe boundaries (`tokio::task::spawn_blocking` in Rust, `pyo3::Python::allow_threads` when calling back into Python). Reuse fixture loaders such as `tests/fixture_app.py` instead of re-parsing schema files per request.
      name: Async-Friendly Performance
      priority: medium
    - content: Implement cross-cutting logic in `crates/spikard/src` and expose it through thin adapters in `crates/spikard-http`, `crates/spikard-py`, `crates/spikard-node`, and `crates/spikard-wasm`. Keep build metadata confined to each binding’s manifest (`pyproject.toml`, `crates/spikard-node/package.json`, `crates/spikard-wasm/package.json`) and register new workflows in `Taskfile.yaml` so `task build`/`task lint` continue to orchestrate the monorepo.
      name: Layered Code Organization
      priority: high
    - content: When updating handlers in crates/spikard-http, translate domain failures into the JSON payloads maintained under testing_data/status_codes and testing_data/validation_errors; add the matching fixture files and assertions in tests/test_all_fixtures.py or the focused integration suites, and keep every testing_data/**/schema.json aligned with the new variants.
      name: HTTP Error Contracts
      priority: high
    - content: Every feature change must extend the pytest suites in tests/ by loading fixtures through tests/conftest.py and invoking task test before merging; new fixture collections belong in testing_data/ with a runnable illustration under examples/ so automated coverage, demos, and docs stay synchronized.
      name: Fixture-Driven Testing
      priority: critical
    - content: Authentication, header, and cookie code must enforce the scenarios captured in testing_data/headers and testing_data/cookies—reject deviations from those schemas, add explicit fixtures plus assertions in tests/test_integration_query_params.py for new header names or cookie attributes, and keep Secure/HttpOnly/SameSite defaults intact.
      name: Header & Cookie Security
      priority: high
    - content: Consolidate heavy computation inside the shared Rust core (crates/spikard) and expose thin bindings in crates/spikard-py, packages/python, crates/spikard-node, and crates/spikard-wasm; stress-test large or deeply nested payloads with testing_data/edge_cases and verify optimized builds via task build:rust, task build:py, and task build:node.
      name: Cross-Target Performance
      priority: medium
    - content: Place reusable domain types and logic in crates/spikard/src/ and keep feature-specific glue isolated within sibling crates (spikard-http, spikard-cli, bindings); mirror module changes across Cargo manifests and refresh the relevant docs/design/* notes whenever the layering or routing changes.
      name: Workspace Organization
      priority: high
    - content: Before committing, run task lint to honor the Biome settings in biome.json for JS/TS, format Rust with cargo fmt --manifest-path Cargo.toml configured by rustfmt.toml, and sync Python dependencies with uv so pyproject.toml and uv.lock stay consistent—avoid introducing divergent toolchains or unchecked formatting drift.
      name: Lint & Formatting Discipline
      priority: medium
sections:
    - content: |-
        ## Tooling
        - Rust workspace declared in `Cargo.toml` and per-crate manifests under `crates/`; install the stable toolchain with `rustup` and add required targets as you touch bindings.
        - JavaScript tooling is managed by `pnpm-workspace.yaml`; install pnpm ≥8 so shared dependencies resolve correctly.
        - Python environments lock via `uv.lock` and `packages/python/pyproject.toml`; install the `uv` CLI to keep wheels in sync.

        ## Install Once Per Machine
        ```bash
        # from /Users/naamanhirschfeld/workspace/spikard
        pnpm install
        uv sync
        cargo check
        ```
        - `pnpm install` hydrates JS packages, including the bindings in `crates/spikard-node/package.json` and WASM artifacts in `crates/spikard-wasm/package.json`.
        - `uv sync` respects the pinned dependencies for the bindings in `crates/spikard-py/pyproject.toml` and the Python package under `packages/python/`.
        - `cargo check` validates the Rust workspace spans (`crates/spikard-*`) before heavier builds.
      name: Workspace Setup
      priority: high
    - content: |-
        ## Task Runner
        - The root `Taskfile.yaml` standardizes workflows; rely on `task build`, `task test`, and `task lint` to match CI in `.github/workflows/ci.yaml`.
        ```bash
        task build       # composite build across Rust, Python, Node, WASM
        .task lint        # matches repository lint gates
        task test        # mirrors CI matrix
        ```

        ## Targeted Builds
        - Use Cargo directly when iterating on a single crate:
        ```bash
        cargo build -p spikard-http
        cargo run -p spikard-cli -- --help
        ```
        - Python examples under `examples/` assume the bindings built from `crates/spikard-py`; run them with the synced uv environment after building the crate.
        - Design docs in `docs/design/` (e.g., `docs/design/00-architecture.md`) capture architectural decisions; update them alongside code changes.
      name: Development Workflow
      priority: medium
    - content: |-
        ## End-to-End Runs
        - Execute the full suite with the task runner so Rust, Python, and JS checks stay in parity with CI:
        ```bash
        task test
        ```

        ## Focused Testing
        - Python fixtures live in `testing_data/` and tests in `packages/python/tests/`; iterate quickly with pytest:
        ```bash
        PYTHONPATH=. uv run pytest packages/python/tests/test_integration_query_params.py
        ```
        - Validate Rust crates individually to isolate failures:
        ```bash
        cargo test -p spikard -- --nocapture
        cargo test -p spikard-http
        ```
        - When adding new fixture scenarios, mirror the schema files in `testing_data/*/schema.json` so validation stays consistent with generated data.
      name: Testing Strategy
      priority: medium
    - content: |-
        ## Prerequisites
        - Rust toolchain for workspace crates (`Cargo.toml`)
        - Node.js 18+ with `pnpm` (`package.json`, `pnpm-workspace.yaml`)
        - Python 3.10+ with `uv` (`pyproject.toml`, `uv.lock`)
        - `task` CLI to use `Taskfile.yaml` automation

        ## Install Dependencies
        ```bash
        pnpm install
        uv sync
        cargo fetch
        ```

        ## Verify Tooling
        ```bash
        task build
        ```
      name: Environment Setup
      priority: high
    - content: |-
        ## Rust Workspace Layout
        - Core library: `crates/spikard/Cargo.toml`.
        - CLI frontend: `crates/spikard-cli/`.
        - Server: `crates/spikard-http/`.
        - Bindings: `crates/spikard-{node,py,wasm}/`.

        ## Python & Testing
        - Python package scaffold: `packages/python/spikard`.
        - Shared integration fixtures: `testing_data/` with schemas per scenario.
        - Pytests live in `packages/python/tests/`, using fixture helpers (`packages/python/tests/fixture_app.py`) and sample apps in `examples/`.

        ## Reference Docs
        - High-level design: `docs/design/00-architecture.md`.
        - Validation strategy: `docs/design/01-validation-strategy.md`.
        - Routing notes: `docs/design/axum-routing.md`.
      name: Architecture Overview
      priority: medium
