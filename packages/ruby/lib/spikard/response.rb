# frozen_string_literal: true

# ⚠️ GENERATED BY crates/spikard-rb/build.rs — DO NOT EDIT BY HAND
module Spikard
  class Response # :nodoc: Native-backed HTTP response facade generated from Rust metadata.
    attr_reader :content, :status_code, :headers, :native_response

    def initialize(content: nil, body: nil, status_code: 200, headers: nil, content_type: nil)
      @content = content.nil? ? body : content
      @status_code = Integer(status_code || 200)
      @headers = normalize_headers(headers)
      set_header('content-type', content_type) if content_type
      rebuild_native!
    end

    def status
      @status_code
    end

    def status_code=(value)
      @status_code = Integer(value)
      rebuild_native!
    rescue ArgumentError, TypeError
      raise ArgumentError, 'status_code must be an integer'
    end

    def headers=(value)
      @headers = normalize_headers(value)
      rebuild_native!
    end

    def content=(value)
      @content = value
      rebuild_native!
    end

    def set_header(name, value)
      @headers[name.to_s] = value.to_s
      rebuild_native!
    end

    def set_cookie(name, value, **options)
      raise ArgumentError, 'cookie name required' if name.nil? || name.empty?

      header_value = ["#{name}=#{value}", *cookie_parts(options)].join('; ')
      set_header('set-cookie', header_value)
    end

    def to_native_response
      @native_response
    end

    private

    def rebuild_native!
      ensure_native!
      @native_response = Spikard::Native.build_response(@content, @status_code, @headers)
      return unless @native_response

      @status_code = @native_response.status_code
      @headers = @native_response.headers
    end

    def ensure_native!
      return if defined?(Spikard::Native) && Spikard::Native.respond_to?(:build_response)

      raise 'Spikard native extension is not loaded'
    end

    def cookie_parts(options)
      [
        options[:max_age] && "Max-Age=#{Integer(options[:max_age])}",
        options[:domain] && "Domain=#{options[:domain]}",
        "Path=#{options.fetch(:path, '/') || '/'}",
        options[:secure] ? 'Secure' : nil,
        options[:httponly] ? 'HttpOnly' : nil,
        options[:samesite] && "SameSite=#{options[:samesite]}"
      ].compact
    end

    def normalize_headers(value)
      case value
      when nil
        {}
      when Hash
        value.each_with_object({}) do |(key, val), acc|
          acc[key.to_s.downcase] = val.to_s
        end
      else
        raise ArgumentError, 'headers must be a Hash'
      end
    end
  end

  class StreamingResponse # :nodoc: Streaming response wrapper backed by the native Rust builder.
    attr_reader :stream, :status_code, :headers, :native_response

    def initialize(stream, status_code: 200, headers: nil)
      unless stream.respond_to?(:next) || stream.respond_to?(:each)
        raise ArgumentError, 'StreamingResponse requires an object responding to #next or #each'
      end

      @stream = stream.respond_to?(:to_enum) ? stream.to_enum : stream
      @status_code = Integer(status_code || 200)
      header_hash = headers || {}
      @headers = header_hash.each_with_object({}) do |(key, value), memo|
        memo[String(key)] = String(value)
      end

      rebuild_native!
    end

    def to_native_response
      @native_response
    end

    private

    def rebuild_native!
      ensure_native!
      @native_response = Spikard::Native.build_streaming_response(@stream, @status_code, @headers)
      return unless @native_response

      @status_code = @native_response.status_code
      @headers = @native_response.headers
    end

    def ensure_native!
      return if defined?(Spikard::Native) && Spikard::Native.respond_to?(:build_streaming_response)

      raise 'Spikard native extension is not loaded'
    end
  end

  module Testing
    class Response # :nodoc: Lightweight response wrapper used by the test client.
      attr_reader :status_code, :headers, :body

      def initialize(payload)
        @status_code = payload[:status_code]
        @headers = payload[:headers] || {}
        @body = payload[:body]
        @body_text = payload[:body_text]
      end

      def status
        @status_code
      end

      def body_bytes
        @body || ''.b
      end

      def body_text
        @body_text || @body&.dup&.force_encoding(Encoding::UTF_8)
      end

      def text
        body_text
      end

      def json
        return nil if @body.nil? || @body.empty?

        JSON.parse(@body)
      end

      def graphql_data
        return nil if @body.nil? || @body.empty?

        payload = parse_graphql_json
        payload['data']
      end

      def graphql_errors
        return [] if @body.nil? || @body.empty?

        payload = parse_graphql_json
        errors = payload['errors']
        errors.is_a?(Array) ? errors : []
      end

      def bytes
        body_bytes.bytes
      end

      private

      def parse_graphql_json
        JSON.parse(@body)
      rescue JSON::ParserError => e
        raise "Failed to parse GraphQL response: #{e.message}"
      end
    end
  end
end
