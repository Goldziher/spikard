/* auto-generated by NAPI-RS */
/* eslint-disable */

// Type definitions for JSON values with proper type safety
export type JsonPrimitive = string | number | boolean | null;
export type JsonValue = JsonPrimitive | JsonValue[] | { [Key in string]: JsonValue };

/** Node.js wrapper for SSE event */
export declare class SseEvent {
  /** Get the data field of the event */
  getData(): string
  /** Parse the event data as JSON */
  asJson<T extends JsonValue = JsonValue>(): T
}

/** Node.js wrapper for SSE stream */
export declare class SseStream {
  /** Get the raw body of the SSE response */
  body(): string
  /** Get all events from the stream */
  events(): Array<SseEvent>
  /** Get events as JSON values */
  eventsAsJson<T extends JsonValue = JsonValue>(): Array<T>
}

/** Test client for making HTTP requests to a Spikard application */
export declare class TestClient {
  /** Create a new test client from routes and handlers */
  constructor(routesJson: string, handlersMap: object, config?: object | undefined | null)
  get(path: string, headers?: Record<string, string> | undefined | null): Promise<TestResponse>
  post<T extends JsonValue = JsonValue>(path: string, headers?: Record<string, string> | undefined | null, json?: T | undefined | null): Promise<TestResponse>
  put<T extends JsonValue = JsonValue>(path: string, headers?: Record<string, string> | undefined | null, json?: T | undefined | null): Promise<TestResponse>
  delete(path: string, headers?: Record<string, string> | undefined | null): Promise<TestResponse>
  patch<T extends JsonValue = JsonValue>(path: string, headers?: Record<string, string> | undefined | null, json?: T | undefined | null): Promise<TestResponse>
  head(path: string, headers?: Record<string, string> | undefined | null): Promise<TestResponse>
  options(path: string, headers?: Record<string, string> | undefined | null): Promise<TestResponse>
  trace(path: string, headers?: Record<string, string> | undefined | null): Promise<TestResponse>
  /** Connect to a Server-Sent Events endpoint */
  sse(path: string): Promise<SseStream>
  /** Connect to a WebSocket endpoint */
  websocket(path: string): Promise<WebSocketTestConnection>
}

/** HTTP Response wrapper */
export declare class TestResponse {
  /** Get the HTTP status code */
  get statusCode(): number
  /** Get response headers as JSON */
  headers(): Record<string, string>
  /** Get response body as text */
  text(): string
  /** Parse response body as JSON */
  json<T extends JsonValue = JsonValue>(): T
  /** Get raw response body bytes */
  bytes(): Buffer
}

/** Node.js wrapper for WebSocket messages */
export declare class WebSocketMessage {
  /** Get message as text if it's a text message */
  asText(): string | null
  /** Get message as JSON if it's a text message containing JSON */
  asJson<T extends JsonValue = JsonValue>(): T | null
  /** Get message as binary if it's a binary message */
  asBinary(): Buffer | null
  /** Check if this is a close message */
  isClose(): boolean
}

/** Node.js wrapper for WebSocket test client */
export declare class WebSocketTestConnection {
  /** Send a text message */
  sendText(text: string): Promise<void>
  /** Send a JSON message */
  sendJson<T extends JsonValue = JsonValue>(obj: T): Promise<void>
  /** Receive a text message */
  receiveText(): Promise<string>
  /** Receive and parse a JSON message */
  receiveJson<T extends JsonValue = JsonValue>(): Promise<T>
  /** Receive raw bytes */
  receiveBytes(): Promise<Buffer>
  /** Receive a message and return WebSocketMessage */
  receiveMessage(): Promise<WebSocketMessage>
  /** Close the WebSocket connection */
  close(): Promise<void>
}

export declare function backgroundRun(task: () => Promise<undefined>): void

export declare function createStreamingHandle(iterator: object, init?: StreamingResponseInit | undefined | null): number

/**
 * Start the Spikard HTTP server from Node.js
 *
 * Creates an Axum HTTP server in a dedicated background thread with its own Tokio runtime.
 * This ensures the Node.js event loop remains free to process ThreadsafeFunction calls.
 *
 * # Arguments
 *
 * * `app` - Application object containing routes and handler functions
 * * `config` - Optional ServerConfig with all middleware settings
 *
 * # Returns
 *
 * Returns `Ok(())` after the server thread is spawned. Note that this function
 * returns immediately - the server runs in the background.
 *
 * # Errors
 *
 * Returns an error if:
 * - Route metadata is invalid or missing required fields
 * - Handler functions cannot be converted to ThreadsafeFunctions
 * - Socket address is invalid
 * - Route creation fails
 *
 * # Example
 *
 * ```typescript
 * import { Spikard, ServerConfig } from 'spikard';
 *
 * const config: ServerConfig = {
 *   host: '0.0.0.0',
 *   port: 8000,
 *   compression: { quality: 9 },
 *   openapi: {
 *     enabled: true,
 *     title: 'My API',
 *     version: '1.0.0'
 *   }
 * };
 *
 * const app = new Spikard();
 * app.run(config);
 * ```
 */
export declare function runServer(app: object, config?: object | undefined | null): void

/** Optional configuration for a streaming response. */
export interface StreamingResponseInit {
  /** HTTP status code for the streaming response (default 200). */
  statusCode?: number
  /** Headers to attach to the streaming response. */
  headers?: Record<string, string>
}
