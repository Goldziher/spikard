//! Auto-generated Spikard-Rust benchmark server
//!
//! DO NOT EDIT - Generated by app-generator
//!
//! Uses the full spikard-http Handler trait system with complete middleware stack

use axum::{
    body::Body,
    http::{Request, Response, StatusCode},
};
use serde_json::json;
use spikard_http::{
    RouteMetadata,
    handler_trait::{Handler, HandlerResult, RequestData},
    router::Route,
    server::build_router_with_handlers,
};
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;

#[allow(dead_code)]
struct GetAcceptTestId {}

impl Handler for GetAcceptTestId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("id") {
                response["id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItems {}

impl Handler for PostItems {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostData {}

impl Handler for PostData {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostUpload {}

impl Handler for PostUpload {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostApiV1Resource {}

impl Handler for PostApiV1Resource {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostRoot {}

impl Handler for PostRoot {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostApiId {}

impl Handler for PostApiId {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostLang {}

impl Handler for PostLang {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostId {}

impl Handler for PostId {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsNested {}

impl Handler for PostItemsNested {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsList {}

impl Handler for PostItemsList {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsValidated {}

impl Handler for PostItemsValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsOptionalAll {}

impl Handler for PostItemsOptionalAll {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsListValidated {}

impl Handler for PostItemsListValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostEvents {}

impl Handler for PostEvents {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItems2 {}

impl Handler for PostItems2 {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("limit") {
                response["limit"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PatchItemsId {}

impl Handler for PatchItemsId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("id") {
                response["id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostUsers {}

impl Handler for PostUsers {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostProducts {}

impl Handler for PostProducts {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItems3 {}

impl Handler for PostItems3 {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostPayment {}

impl Handler for PostPayment {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostContact {}

impl Handler for PostContact {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostApiV1Data {}

impl Handler for PostApiV1Data {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostConfig {}

impl Handler for PostConfig {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostBilling {}

impl Handler for PostBilling {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesOptional {}

impl Handler for PostFilesOptional {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesList {}

impl Handler for PostFilesList {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesUpload {}

impl Handler for PostFilesUpload {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesImage {}

impl Handler for PostFilesImage {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesDocument {}

impl Handler for PostFilesDocument {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesValidated {}

impl Handler for PostFilesValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesImagesOnly {}

impl Handler for PostFilesImagesOnly {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesRequired {}

impl Handler for PostFilesRequired {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostLogin {}

impl Handler for PostLogin {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostRegister {}

impl Handler for PostRegister {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostForm {}

impl Handler for PostForm {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFormValidated {}

impl Handler for PostFormValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFormTags {}

impl Handler for PostFormTags {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostToken {}

impl Handler for PostToken {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostRegister2 {}

impl Handler for PostRegister2 {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostProfile {}

impl Handler for PostProfile {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostAccounts {}

impl Handler for PostAccounts {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostTags {}

impl Handler for PostTags {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostSubscribe {}

impl Handler for PostSubscribe {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostSettings {}

impl Handler for PostSettings {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let port: u16 = std::env::args().nth(1).and_then(|s| s.parse().ok()).unwrap_or(8000);

    eprintln!("Starting Spikard-Rust server on port {}", port);

    let schema_registry = spikard_http::SchemaRegistry::new();
    let mut routes: Vec<(Route, Arc<dyn Handler>)> = Vec::new();

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/accept-test/{id}".to_string(),
                handler_name: "GetAcceptTestId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(GetAcceptTestId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/".to_string(),
                handler_name: "PostItems".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostItems {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/data".to_string(),
                handler_name: "PostData".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostData {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/upload".to_string(),
                handler_name: "PostUpload".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostUpload {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/api/v1/resource".to_string(),
                handler_name: "PostApiV1Resource".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostApiV1Resource {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/".to_string(),
                handler_name: "PostRoot".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostRoot {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/api/{id}".to_string(),
                handler_name: "PostApiId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostApiId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/{lang}".to_string(),
                handler_name: "PostLang".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostLang {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/nested".to_string(),
                handler_name: "PostItemsNested".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostItemsNested {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/list".to_string(),
                handler_name: "PostItemsList".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostItemsList {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/validated".to_string(),
                handler_name: "PostItemsValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostItemsValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/optional-all".to_string(),
                handler_name: "PostItemsOptionalAll".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostItemsOptionalAll {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/list-validated".to_string(),
                handler_name: "PostItemsListValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostItemsListValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/events/".to_string(),
                handler_name: "PostEvents".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostEvents {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "PATCH".to_string(),
                path: "/items/{id}".to_string(),
                handler_name: "PatchItemsId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PatchItemsId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/users".to_string(),
                handler_name: "PostUsers".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostUsers {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/products".to_string(),
                handler_name: "PostProducts".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostProducts {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items".to_string(),
                handler_name: "PostItems3".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostItems3 {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/payment".to_string(),
                handler_name: "PostPayment".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostPayment {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/contact".to_string(),
                handler_name: "PostContact".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostContact {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/api/v1/data".to_string(),
                handler_name: "PostApiV1Data".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostApiV1Data {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/config".to_string(),
                handler_name: "PostConfig".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostConfig {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/billing".to_string(),
                handler_name: "PostBilling".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostBilling {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/optional".to_string(),
                handler_name: "PostFilesOptional".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesOptional {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/list".to_string(),
                handler_name: "PostFilesList".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesList {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/upload".to_string(),
                handler_name: "PostFilesUpload".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesUpload {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/image".to_string(),
                handler_name: "PostFilesImage".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesImage {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/document".to_string(),
                handler_name: "PostFilesDocument".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesDocument {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/validated".to_string(),
                handler_name: "PostFilesValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/images-only".to_string(),
                handler_name: "PostFilesImagesOnly".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesImagesOnly {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/required".to_string(),
                handler_name: "PostFilesRequired".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFilesRequired {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/login/".to_string(),
                handler_name: "PostLogin".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostLogin {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/register/".to_string(),
                handler_name: "PostRegister".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostRegister {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/form/".to_string(),
                handler_name: "PostForm".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostForm {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/form/validated".to_string(),
                handler_name: "PostFormValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFormValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/form/tags".to_string(),
                handler_name: "PostFormTags".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostFormTags {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/token".to_string(),
                handler_name: "PostToken".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostToken {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/register".to_string(),
                handler_name: "PostRegister2".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostRegister2 {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/profile".to_string(),
                handler_name: "PostProfile".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostProfile {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/accounts".to_string(),
                handler_name: "PostAccounts".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostAccounts {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/tags".to_string(),
                handler_name: "PostTags".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostTags {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/subscribe".to_string(),
                handler_name: "PostSubscribe".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostSubscribe {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/settings".to_string(),
                handler_name: "PostSettings".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
            },
            &schema_registry,
        )?,
        Arc::new(PostSettings {}) as Arc<dyn Handler>,
    ));

    let app = build_router_with_handlers(routes)?;

    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], port));
    let listener = tokio::net::TcpListener::bind(addr).await?;

    eprintln!("Listening on http://{}", addr);

    axum::serve(listener, app).await?;

    Ok(())
}
