<?php
declare(strict_types=1);

/**
 * Spikard PHP HTTP server for workload benchmarking.
 *
 * This server implements all workload types to measure PHP binding performance
 * against the pure Rust baseline.
 *
 * Generated by app-generator and enhanced for benchmark harness.
 */

require_once __DIR__ . '/vendor/autoload.php';

use Spikard\App;
use Spikard\Config\ServerConfig;
use Spikard\DI\DependencyContainer;
use Spikard\Handlers\HandlerInterface;
use Spikard\Http\Request;
use Spikard\Http\Response;

/**
 * Enable suite-level profiling if available.
 *
 * Uses the `excimer` extension when installed and writes a Speedscope JSON file
 * at process exit, controlled by `SPIKARD_PHP_PROFILE_OUTPUT`.
 */
$profileOutput = getenv('SPIKARD_PHP_PROFILE_OUTPUT') ?: '';
if ($profileOutput !== '' && class_exists('ExcimerProfiler')) {
    try {
        $profiler = new ExcimerProfiler();
        if (defined('EXCIMER_CPU')) {
            $profiler->setEventType(EXCIMER_CPU);
        }
        if (method_exists($profiler, 'setPeriod')) {
            $profiler->setPeriod(0.001); // 1ms
        }
        $profiler->start();

        $dumpProfile = static function () use ($profiler, $profileOutput): void {
            static $dumped = false;
            if ($dumped) {
                return;
            }
            $dumped = true;

            try {
                $profiler->stop();
                $log = $profiler->getLog();

                $payload = null;
                if (is_object($log) && method_exists($log, 'formatSpeedscope')) {
                    $payload = $log->formatSpeedscope();
                    if (!is_string($payload)) {
                        $encoded = json_encode($payload);
                        if (is_string($encoded)) {
                            $payload = $encoded;
                        }
                    }
                } elseif (is_object($log) && method_exists($log, 'formatCollapsed')) {
                    $payload = $log->formatCollapsed();
                }

                if (!is_string($payload) || $payload === '') {
                    $payload = json_encode(['error' => 'no profile samples captured']);
                }
                if (!is_string($payload)) {
                    return;
                }

                $dir = dirname($profileOutput);
                if (!is_dir($dir)) {
                    mkdir($dir, 0777, true);
                }
                file_put_contents($profileOutput, $payload);
            } catch (Throwable) {
                // Best-effort only; benchmarks must not crash due to profiling.
            }
        };

        register_shutdown_function(static function () use ($dumpProfile): void {
            $dumpProfile();
        });

        if (function_exists('pcntl_async_signals') && function_exists('pcntl_signal')) {
            pcntl_async_signals(true);
            pcntl_signal(SIGINT, static function () use ($dumpProfile): void {
                $dumpProfile();
                exit(0);
            });
            pcntl_signal(SIGTERM, static function () use ($dumpProfile): void {
                $dumpProfile();
                exit(0);
            });
        }
    } catch (Throwable) {
        // Best-effort only; benchmarks must not crash due to profiling.
    }
}

$app = new App();

// ============================================================================
// Handler Classes (must be named classes for FFI compatibility)
// ============================================================================

final class EchoHandler implements HandlerInterface
{
    public function matches(Request $request): bool
    {
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response($request->body ?? [], 200, []);
    }

    public function __invoke(Request $request): Response
    {
        return $this->handle($request);
    }
}

final class FixedDataHandler implements HandlerInterface
{
    public function __construct(private readonly array $data)
    {
    }

    public function matches(Request $request): bool
    {
        return true;
    }

    public function handle(Request $request): Response
    {
        return new Response($this->data, 200, []);
    }

    public function __invoke(Request $request): Response
    {
        return $this->handle($request);
    }
}

final class PathParamHandler implements HandlerInterface
{
    public function matches(Request $request): bool
    {
        return true;
    }

    public function handle(Request $request): Response
    {
        $response = [];
        if (isset($request->pathParams['id'])) {
            $response['id'] = $request->pathParams['id'];
        }
        if ($request->body !== null) {
            $response = array_merge($response, $request->body);
        }
        return new Response($response, 200, []);
    }

    public function __invoke(Request $request): Response
    {
        return $this->handle($request);
    }
}

// ============================================================================
// Helper functions to create handler instances
// ============================================================================

function echoHandler(): HandlerInterface
{
    return new EchoHandler();
}

function fixedHandler(array $data): HandlerInterface
{
    return new FixedDataHandler($data);
}

// ============================================================================
// Health Check
// ============================================================================

$app = $app->addRoute('GET', '/health', fixedHandler(['status' => 'ok']));

// ============================================================================
// JSON Body Workloads - Small Payloads (~100-500 bytes)
// ============================================================================

$app = $app->addRoute('POST', '/items/', echoHandler());
$app = $app->addRoute('POST', '/items', echoHandler());
$app = $app->addRoute('POST', '/users', echoHandler());
$app = $app->addRoute('POST', '/products', echoHandler());
$app = $app->addRoute('POST', '/contact', echoHandler());
$app = $app->addRoute('POST', '/', echoHandler());

// ============================================================================
// JSON Body Workloads - Nested Objects (Medium ~1-10KB)
// ============================================================================

$app = $app->addRoute('POST', '/items/nested', echoHandler());
$app = $app->addRoute('POST', '/payment', echoHandler());
$app = $app->addRoute('POST', '/billing', echoHandler());

// ============================================================================
// JSON Body Workloads - Arrays and Lists (Medium-Large)
// ============================================================================

$app = $app->addRoute('POST', '/items/list', echoHandler());
$app = $app->addRoute('POST', '/items/validated', echoHandler());
$app = $app->addRoute('POST', '/items/optional-all', echoHandler());
$app = $app->addRoute('POST', '/items/list-validated', echoHandler());
$app = $app->addRoute('POST', '/events/', echoHandler());

// ============================================================================
// JSON Body Workloads - Large Payloads (~10-100KB)
// ============================================================================

$app = $app->addRoute('POST', '/api/v1/data', echoHandler());
$app = $app->addRoute('POST', '/config', echoHandler());
$app = $app->addRoute('POST', '/data', echoHandler());

// ============================================================================
// Path Parameter Workloads
// ============================================================================

$app = $app->addRoute('PATCH', '/items/{id}', new PathParamHandler());

// ============================================================================
// Multipart Form Workloads (~1KB - 100KB)
// ============================================================================

$app = $app->addRoute('POST', '/files/optional', fixedHandler(['files_received' => 1, 'total_bytes' => 1024]));
$app = $app->addRoute('POST', '/files/list', fixedHandler(['files_received' => 2, 'total_bytes' => 10240]));
$app = $app->addRoute('POST', '/files/upload', fixedHandler(['files_received' => 1, 'total_bytes' => 5120]));
$app = $app->addRoute('POST', '/files/image', fixedHandler(['files_received' => 1, 'total_bytes' => 8192]));
$app = $app->addRoute('POST', '/files/document', fixedHandler(['files_received' => 1, 'total_bytes' => 15360]));
$app = $app->addRoute('POST', '/files/validated', fixedHandler(['files_received' => 1, 'total_bytes' => 2048]));
$app = $app->addRoute('POST', '/files/images-only', fixedHandler(['files_received' => 3, 'total_bytes' => 30720]));
$app = $app->addRoute('POST', '/files/required', fixedHandler(['files_received' => 1, 'total_bytes' => 4096]));
$app = $app->addRoute('POST', '/upload', fixedHandler(['files_received' => 1, 'total_bytes' => 10240]));

// ============================================================================
// URL Encoded Form Workloads (3-20 fields)
// ============================================================================

$app = $app->addRoute('POST', '/login/', echoHandler());
$app = $app->addRoute('POST', '/register/', echoHandler());
$app = $app->addRoute('POST', '/form/', echoHandler());
$app = $app->addRoute('POST', '/form/validated', echoHandler());
$app = $app->addRoute('POST', '/form/tags', echoHandler());
$app = $app->addRoute('POST', '/token', echoHandler());
$app = $app->addRoute('POST', '/register', echoHandler());
$app = $app->addRoute('POST', '/profile', echoHandler());
$app = $app->addRoute('POST', '/accounts', echoHandler());
$app = $app->addRoute('POST', '/tags', echoHandler());
$app = $app->addRoute('POST', '/subscribe', echoHandler());
$app = $app->addRoute('POST', '/settings', echoHandler());

// ============================================================================
// Server Entry Point
// ============================================================================

if (PHP_SAPI === 'cli' && __FILE__ === realpath($_SERVER['SCRIPT_FILENAME'])) {
    $port = (int)($argv[1] ?? 8000);
    error_log("[spikard-php] Starting server on port $port");

    // Create server config with named parameters
    $config = new ServerConfig(
        host: '0.0.0.0',
        port: $port,
        workers: 1  // Single worker for consistent benchmarking
    );

    // Provide an empty DI container to satisfy the native runtime.
    $container = new DependencyContainer();

    $app = $app
        ->withConfig($config)
        ->withDependencies($container);
    $app->run();
}
