//! Auto-generated Spikard-Rust benchmark server
//!
//! DO NOT EDIT - Generated by app-generator
//!
//! Uses the full spikard-http Handler trait system with complete middleware stack

use axum::{
    body::Body,
    http::{Request, Response, StatusCode},
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use spikard::UploadFile;
use spikard_http::{
    RouteMetadata, SchemaRegistry,
    handler_trait::{Handler, HandlerResult, RequestData},
    router::Route,
    server::build_router_with_handlers,
};
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;

#[allow(dead_code)]
struct HealthHandler {}

impl Handler for HealthHandler {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({"status": "ok"});
            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItems {}

impl Handler for PostItems {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsNested {}

impl Handler for PostItemsNested {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsList {}

impl Handler for PostItemsList {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsValidated {}

impl Handler for PostItemsValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsOptionalAll {}

impl Handler for PostItemsOptionalAll {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItemsListValidated {}

impl Handler for PostItemsListValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostEvents {}

impl Handler for PostEvents {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PatchItemsId {}

impl Handler for PatchItemsId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("id") {
                response["id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostUsers {}

impl Handler for PostUsers {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostProducts {}

impl Handler for PostProducts {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostItems2 {}

impl Handler for PostItems2 {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostPayment {}

impl Handler for PostPayment {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostContact {}

impl Handler for PostContact {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostApiV1Data {}

impl Handler for PostApiV1Data {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostConfig {}

impl Handler for PostConfig {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostBilling {}

impl Handler for PostBilling {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostData {}

impl Handler for PostData {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostRoot {}

impl Handler for PostRoot {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesOptional {}

impl Handler for PostFilesOptional {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesList {}

impl Handler for PostFilesList {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesUpload {}

impl Handler for PostFilesUpload {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesImage {}

impl Handler for PostFilesImage {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesDocument {}

impl Handler for PostFilesDocument {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesValidated {}

impl Handler for PostFilesValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesImagesOnly {}

impl Handler for PostFilesImagesOnly {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFilesRequired {}

impl Handler for PostFilesRequired {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostUpload {}

impl Handler for PostUpload {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathStrItemId {}

impl Handler for GetPathStrItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathIntItemId {}

impl Handler for GetPathIntItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathFloatItemId {}

impl Handler for GetPathFloatItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetItemsId {}

impl Handler for GetItemsId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathParamGtItemId {}

impl Handler for GetPathParamGtItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathParamMinlengthItemId {}

impl Handler for GetPathParamMinlengthItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetModelsModelName {}

impl Handler for GetModelsModelName {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("model_name") {
                response["model_name"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetFilesFilePath {}

impl Handler for GetFilesFilePath {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("file_path") {
                response["file_path"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetVersionServiceIdUserIdOrderId {}

impl Handler for GetVersionServiceIdUserIdOrderId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("order_id") {
                response["order_id"] = json!(val);
            }
            if let Some(val) = request_data.path_params.get("user_id") {
                response["user_id"] = json!(val);
            }
            if let Some(val) = request_data.path_params.get("version") {
                response["version"] = json!(val);
            }
            if let Some(val) = request_data.path_params.get("service_id") {
                response["service_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathBoolItemId {}

impl Handler for GetPathBoolItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathParamGeItemId {}

impl Handler for GetPathParamGeItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathParamLeItemId {}

impl Handler for GetPathParamLeItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathParamLtItemId {}

impl Handler for GetPathParamLtItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathParamLtGtItemId {}

impl Handler for GetPathParamLtGtItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPathParamMaxlengthItemId {}

impl Handler for GetPathParamMaxlengthItemId {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("item_id") {
                response["item_id"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetDateDateParam {}

impl Handler for GetDateDateParam {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("date_param") {
                response["date_param"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetEventsDate {}

impl Handler for GetEventsDate {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("date") {
                response["date"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetBookingsTimestamp {}

impl Handler for GetBookingsTimestamp {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("timestamp") {
                response["timestamp"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetDelaysDuration {}

impl Handler for GetDelaysDuration {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("duration") {
                response["duration"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetPricesAmount {}

impl Handler for GetPricesAmount {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("amount") {
                response["amount"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetUsersUsername {}

impl Handler for GetUsersUsername {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("username") {
                response["username"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetReposOwnerRepo {}

impl Handler for GetReposOwnerRepo {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("owner") {
                response["owner"] = json!(val);
            }
            if let Some(val) = request_data.path_params.get("repo") {
                response["repo"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetReposOwner {}

impl Handler for GetReposOwner {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("owner") {
                response["owner"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetOffsetValue {}

impl Handler for GetOffsetValue {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("value") {
                response["value"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetTypeSyntaxItemsId {}

impl Handler for GetTypeSyntaxItemsId {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetTypeSyntaxUsersUserId {}

impl Handler for GetTypeSyntaxUsersUserId {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetTypeSyntaxItemsCountCount {}

impl Handler for GetTypeSyntaxItemsCountCount {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.path_params.get("count") {
                response["count"] = json!(val);
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQuery {}

impl Handler for GetQuery {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("query") {
                response["query"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryInt {}

impl Handler for GetQueryInt {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("query") {
                response["query"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryOptional {}

impl Handler for GetQueryOptional {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("query") {
                response["query"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryIntOptional {}

impl Handler for GetQueryIntOptional {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("query") {
                response["query"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryIntDefault {}

impl Handler for GetQueryIntDefault {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("query") {
                response["query"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryList {}

impl Handler for GetQueryList {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("device_ids") {
                response["device_ids"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryListDefault {}

impl Handler for GetQueryListDefault {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("tags") {
                response["tags"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetItems {}

impl Handler for GetItems {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("q") {
                response["q"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetTest {}

impl Handler for GetTest {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("email") {
                response["email"] = val.clone();
            }
            if let Some(val) = request_data.query_params.get("special") {
                response["special"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryBool {}

impl Handler for GetQueryBool {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("flag") {
                response["flag"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryUuid {}

impl Handler for GetQueryUuid {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("item_id") {
                response["item_id"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryEnum {}

impl Handler for GetQueryEnum {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("model") {
                response["model"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryIntGe {}

impl Handler for GetQueryIntGe {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("value") {
                response["value"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryIntLe {}

impl Handler for GetQueryIntLe {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("value") {
                response["value"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryIntLt {}

impl Handler for GetQueryIntLt {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("value") {
                response["value"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryIntGt {}

impl Handler for GetQueryIntGt {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("value") {
                response["value"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryStrMaxLength {}

impl Handler for GetQueryStrMaxLength {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("name") {
                response["name"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryStrMinLength {}

impl Handler for GetQueryStrMinLength {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("name") {
                response["name"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryDate {}

impl Handler for GetQueryDate {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("event_date") {
                response["event_date"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryDatetime {}

impl Handler for GetQueryDatetime {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("timestamp") {
                response["timestamp"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryPattern {}

impl Handler for GetQueryPattern {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("code") {
                response["code"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryBasic {}

impl Handler for GetQueryBasic {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("name") {
                response["name"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryMultiType {}

impl Handler for GetQueryMultiType {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("active") {
                response["active"] = val.clone();
            }
            if let Some(val) = request_data.query_params.get("name") {
                response["name"] = val.clone();
            }
            if let Some(val) = request_data.query_params.get("age") {
                response["age"] = val.clone();
            }
            if let Some(val) = request_data.query_params.get("score") {
                response["score"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryOptionalDefault {}

impl Handler for GetQueryOptionalDefault {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("limit") {
                response["limit"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetQueryFloatGe {}

impl Handler for GetQueryFloatGe {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("price") {
                response["price"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetItemsNegative {}

impl Handler for GetItemsNegative {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("offset") {
                response["offset"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetStats {}

impl Handler for GetStats {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("threshold") {
                response["threshold"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetSearch {}

impl Handler for GetSearch {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("term") {
                response["term"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetSubscribe {}

impl Handler for GetSubscribe {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("email") {
                response["email"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetItems2 {}

impl Handler for GetItems2 {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("limit") {
                response["limit"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetNetwork {}

impl Handler for GetNetwork {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("ip") {
                response["ip"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetNetworkIpv6 {}

impl Handler for GetNetworkIpv6 {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("ip") {
                response["ip"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetRedirect {}

impl Handler for GetRedirect {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("url") {
                response["url"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct GetDns {}

impl Handler for GetDns {
    fn call(
        &self,
        _request: Request<Body>,
        request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let mut response = json!({});

            if let Some(val) = request_data.query_params.get("host") {
                response["host"] = val.clone();
            }

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostLogin {}

impl Handler for PostLogin {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostRegister {}

impl Handler for PostRegister {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostForm {}

impl Handler for PostForm {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFormValidated {}

impl Handler for PostFormValidated {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostFormTags {}

impl Handler for PostFormTags {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostToken {}

impl Handler for PostToken {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostRegister2 {}

impl Handler for PostRegister2 {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostProfile {}

impl Handler for PostProfile {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostAccounts {}

impl Handler for PostAccounts {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostTags {}

impl Handler for PostTags {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostSubscribe {}

impl Handler for PostSubscribe {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[allow(dead_code)]
struct PostSettings {}

impl Handler for PostSettings {
    fn call(
        &self,
        _request: Request<Body>,
        _request_data: RequestData,
    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {
        Box::pin(async move {
            let response = json!({});

            let body = serde_json::to_vec(&response).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

            Response::builder()
                .status(StatusCode::OK)
                .header("content-type", "application/json")
                .body(Body::from(body))
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        })
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let port: u16 = std::env::args().nth(1).and_then(|s| s.parse().ok()).unwrap_or(8000);

    eprintln!("Starting Spikard-Rust server on port {}", port);

    let registry = SchemaRegistry::new();
    let mut routes: Vec<(Route, Arc<dyn Handler>)> = Vec::new();

    // Health check route
    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/health".to_string(),
                handler_name: "HealthHandler".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(HealthHandler {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/".to_string(),
                handler_name: "PostItems".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostItems {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/nested".to_string(),
                handler_name: "PostItemsNested".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostItemsNested {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/list".to_string(),
                handler_name: "PostItemsList".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostItemsList {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/validated".to_string(),
                handler_name: "PostItemsValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostItemsValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/optional-all".to_string(),
                handler_name: "PostItemsOptionalAll".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostItemsOptionalAll {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items/list-validated".to_string(),
                handler_name: "PostItemsListValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostItemsListValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/events/".to_string(),
                handler_name: "PostEvents".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostEvents {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "PATCH".to_string(),
                path: "/items/{id}".to_string(),
                handler_name: "PatchItemsId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PatchItemsId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/users".to_string(),
                handler_name: "PostUsers".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostUsers {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/products".to_string(),
                handler_name: "PostProducts".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostProducts {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/items".to_string(),
                handler_name: "PostItems2".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostItems2 {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/payment".to_string(),
                handler_name: "PostPayment".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostPayment {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/contact".to_string(),
                handler_name: "PostContact".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostContact {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/api/v1/data".to_string(),
                handler_name: "PostApiV1Data".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostApiV1Data {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/config".to_string(),
                handler_name: "PostConfig".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostConfig {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/billing".to_string(),
                handler_name: "PostBilling".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostBilling {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/data".to_string(),
                handler_name: "PostData".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostData {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/".to_string(),
                handler_name: "PostRoot".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostRoot {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/optional".to_string(),
                handler_name: "PostFilesOptional".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesOptional {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/list".to_string(),
                handler_name: "PostFilesList".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesList {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/upload".to_string(),
                handler_name: "PostFilesUpload".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesUpload {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/image".to_string(),
                handler_name: "PostFilesImage".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesImage {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/document".to_string(),
                handler_name: "PostFilesDocument".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesDocument {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/validated".to_string(),
                handler_name: "PostFilesValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/images-only".to_string(),
                handler_name: "PostFilesImagesOnly".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesImagesOnly {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/files/required".to_string(),
                handler_name: "PostFilesRequired".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFilesRequired {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/upload".to_string(),
                handler_name: "PostUpload".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostUpload {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/str/{item_id}".to_string(),
                handler_name: "GetPathStrItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathStrItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/int/{item_id}".to_string(),
                handler_name: "GetPathIntItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathIntItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/float/{item_id}".to_string(),
                handler_name: "GetPathFloatItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathFloatItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/items/{id}".to_string(),
                handler_name: "GetItemsId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetItemsId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/param-gt/{item_id}".to_string(),
                handler_name: "GetPathParamGtItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathParamGtItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/param-minlength/{item_id}".to_string(),
                handler_name: "GetPathParamMinlengthItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathParamMinlengthItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/models/{model_name}".to_string(),
                handler_name: "GetModelsModelName".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetModelsModelName {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/files/{file_path}".to_string(),
                handler_name: "GetFilesFilePath".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetFilesFilePath {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/{version}/{service_id}/{user_id}/{order_id}".to_string(),
                handler_name: "GetVersionServiceIdUserIdOrderId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetVersionServiceIdUserIdOrderId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/bool/{item_id}".to_string(),
                handler_name: "GetPathBoolItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathBoolItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/param-ge/{item_id}".to_string(),
                handler_name: "GetPathParamGeItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathParamGeItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/param-le/{item_id}".to_string(),
                handler_name: "GetPathParamLeItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathParamLeItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/param-lt/{item_id}".to_string(),
                handler_name: "GetPathParamLtItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathParamLtItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/param-lt-gt/{item_id}".to_string(),
                handler_name: "GetPathParamLtGtItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathParamLtGtItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/path/param-maxlength/{item_id}".to_string(),
                handler_name: "GetPathParamMaxlengthItemId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPathParamMaxlengthItemId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/date/{date_param}".to_string(),
                handler_name: "GetDateDateParam".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetDateDateParam {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/events/{date}".to_string(),
                handler_name: "GetEventsDate".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetEventsDate {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/bookings/{timestamp}".to_string(),
                handler_name: "GetBookingsTimestamp".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetBookingsTimestamp {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/delays/{duration}".to_string(),
                handler_name: "GetDelaysDuration".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetDelaysDuration {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/prices/{amount}".to_string(),
                handler_name: "GetPricesAmount".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetPricesAmount {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/users/{username}".to_string(),
                handler_name: "GetUsersUsername".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetUsersUsername {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/repos/{owner}/{repo}".to_string(),
                handler_name: "GetReposOwnerRepo".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetReposOwnerRepo {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/repos/{owner}".to_string(),
                handler_name: "GetReposOwner".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetReposOwner {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/offset/{value}".to_string(),
                handler_name: "GetOffsetValue".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetOffsetValue {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/type-syntax/items/{id}".to_string(),
                handler_name: "GetTypeSyntaxItemsId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetTypeSyntaxItemsId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/type-syntax/users/{user_id}".to_string(),
                handler_name: "GetTypeSyntaxUsersUserId".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetTypeSyntaxUsersUserId {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/type-syntax/items-count/{count}".to_string(),
                handler_name: "GetTypeSyntaxItemsCountCount".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetTypeSyntaxItemsCountCount {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query".to_string(),
                handler_name: "GetQuery".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQuery {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/int".to_string(),
                handler_name: "GetQueryInt".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryInt {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/optional".to_string(),
                handler_name: "GetQueryOptional".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryOptional {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/int/optional".to_string(),
                handler_name: "GetQueryIntOptional".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryIntOptional {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/int/default".to_string(),
                handler_name: "GetQueryIntDefault".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryIntDefault {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/list".to_string(),
                handler_name: "GetQueryList".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryList {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/list-default".to_string(),
                handler_name: "GetQueryListDefault".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryListDefault {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/items/".to_string(),
                handler_name: "GetItems".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetItems {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/test".to_string(),
                handler_name: "GetTest".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetTest {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/bool".to_string(),
                handler_name: "GetQueryBool".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryBool {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/uuid".to_string(),
                handler_name: "GetQueryUuid".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryUuid {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/enum".to_string(),
                handler_name: "GetQueryEnum".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryEnum {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/int-ge".to_string(),
                handler_name: "GetQueryIntGe".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryIntGe {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/int-le".to_string(),
                handler_name: "GetQueryIntLe".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryIntLe {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/int-lt".to_string(),
                handler_name: "GetQueryIntLt".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryIntLt {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/int-gt".to_string(),
                handler_name: "GetQueryIntGt".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryIntGt {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/str-max-length".to_string(),
                handler_name: "GetQueryStrMaxLength".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryStrMaxLength {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/str-min-length".to_string(),
                handler_name: "GetQueryStrMinLength".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryStrMinLength {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/date".to_string(),
                handler_name: "GetQueryDate".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryDate {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/datetime".to_string(),
                handler_name: "GetQueryDatetime".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryDatetime {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/pattern".to_string(),
                handler_name: "GetQueryPattern".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryPattern {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/basic".to_string(),
                handler_name: "GetQueryBasic".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryBasic {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/multi-type".to_string(),
                handler_name: "GetQueryMultiType".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryMultiType {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/optional-default".to_string(),
                handler_name: "GetQueryOptionalDefault".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryOptionalDefault {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/query/float-ge".to_string(),
                handler_name: "GetQueryFloatGe".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetQueryFloatGe {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/items/negative".to_string(),
                handler_name: "GetItemsNegative".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetItemsNegative {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/stats".to_string(),
                handler_name: "GetStats".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetStats {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/search".to_string(),
                handler_name: "GetSearch".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetSearch {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/subscribe".to_string(),
                handler_name: "GetSubscribe".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetSubscribe {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/items".to_string(),
                handler_name: "GetItems2".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetItems2 {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/network".to_string(),
                handler_name: "GetNetwork".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetNetwork {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/network/ipv6".to_string(),
                handler_name: "GetNetworkIpv6".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetNetworkIpv6 {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/redirect".to_string(),
                handler_name: "GetRedirect".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetRedirect {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "GET".to_string(),
                path: "/dns".to_string(),
                handler_name: "GetDns".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(GetDns {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/login/".to_string(),
                handler_name: "PostLogin".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostLogin {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/register/".to_string(),
                handler_name: "PostRegister".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostRegister {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/form/".to_string(),
                handler_name: "PostForm".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostForm {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/form/validated".to_string(),
                handler_name: "PostFormValidated".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFormValidated {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/form/tags".to_string(),
                handler_name: "PostFormTags".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostFormTags {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/token".to_string(),
                handler_name: "PostToken".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostToken {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/register".to_string(),
                handler_name: "PostRegister2".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostRegister2 {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/profile".to_string(),
                handler_name: "PostProfile".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostProfile {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/accounts".to_string(),
                handler_name: "PostAccounts".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostAccounts {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/tags".to_string(),
                handler_name: "PostTags".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostTags {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/subscribe".to_string(),
                handler_name: "PostSubscribe".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostSubscribe {}) as Arc<dyn Handler>,
    ));

    routes.push((
        Route::from_metadata(
            RouteMetadata {
                method: "POST".to_string(),
                path: "/settings".to_string(),
                handler_name: "PostSettings".to_string(),
                request_schema: None,
                response_schema: None,
                parameter_schema: None,
                file_params: None,
                is_async: true,
                cors: None,
                body_param_name: None,
                #[cfg(feature = "di")]
                handler_dependencies: None,
                jsonrpc_method: None,
            },
            &registry,
        )?,
        Arc::new(PostSettings {}) as Arc<dyn Handler>,
    ));

    let app = build_router_with_handlers(routes, None)?;

    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], port));
    let listener = tokio::net::TcpListener::bind(addr).await?;

    eprintln!("Listening on http://{}", addr);

    axum::serve(listener, app).await?;

    Ok(())
}
