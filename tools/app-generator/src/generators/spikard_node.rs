//! Spikard-Node code generator
//!
//! Generates TypeScript/Node code using Spikard bindings

use crate::analyzer::{RouteAnalysis, RouteInfo};
use crate::fixture::ParameterDef;
use anyhow::Result;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    // Generate imports
    output.push_str(&generate_imports());

    // Create app
    output.push_str("const app = new Spikard();\n\n");

    // Generate handler functions
    for route in &analysis.routes {
        output.push_str(&generate_handler(route));
        output.push_str("\n\n");
    }

    // Generate main
    output.push_str(&generate_main());

    Ok(output)
}

fn generate_imports() -> String {
    r#"#!/usr/bin/env node
/**
 * Auto-generated Spikard-Node benchmark server
 *
 * DO NOT EDIT - Generated by app-generator
 */

import { Spikard } from '@spikard/node';

"#
    .to_string()
}

fn generate_handler(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let params = generate_parameters(route);
    let body = generate_handler_body(route);

    format!(
        r#"app.{}('{}', async ({}) => {{
  const response: Record<string, any> = {{}};
  {}
  return response;
}});"#,
        method, route.route, params, body
    )
}

fn generate_parameters(route: &RouteInfo) -> String {
    // Check what we need
    let has_path = !route.params.path.is_empty();
    let has_query = !route.params.query.is_empty();
    let has_body = route.params.body.is_some();

    // Build destructured parameter
    let mut obj_parts: Vec<&str> = Vec::new();

    if has_path {
        obj_parts.push("params");
    }
    if has_query {
        obj_parts.push("query");
    }
    if has_body {
        obj_parts.push("body");
    }

    if obj_parts.is_empty() {
        "_req".to_string()
    } else {
        format!("{{ {} }}", obj_parts.join(", "))
    }
}

fn generate_handler_body(route: &RouteInfo) -> String {
    let mut lines = Vec::new();

    // Add path params to response
    for (name, _) in &route.params.path {
        lines.push(format!("response['{}'] = params.{};", name, name));
    }

    // Add query params to response
    for (name, _) in &route.params.query {
        lines.push(format!("if (query.{} !== undefined) {{", name));
        lines.push(format!("  response['{}'] = query.{};", name, name));
        lines.push("}".to_string());
    }

    // Return body if present
    if route.params.body.is_some() {
        lines.push("Object.assign(response, body);".to_string());
    }

    lines.join("\n  ")
}

fn generate_main() -> String {
    r#"const port = process.argv[2] ? parseInt(process.argv[2]) : 8000;

console.error(`Starting Spikard-Node server on port ${port}`);
app.listen(port, '0.0.0.0');
"#
    .to_string()
}
