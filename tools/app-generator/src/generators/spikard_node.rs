//! Spikard-Node code generator
//!
//! Generates TypeScript code using Spikard Node bindings with ergonomic
//! handler wrappers (wrapHandler, wrapBodyHandler) that automatically
//! convert file metadata to UploadFile instances

use crate::analyzer::{RouteAnalysis, RouteInfo};
use anyhow::Result;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    output.push_str(&generate_header());

    let has_body_handlers = analysis.routes.iter().any(|r| r.params.body.is_some());
    output.push_str(&generate_imports(has_body_handlers));
    output.push_str("\n");

    // Generate TypeScript interfaces for body handlers
    for route in &analysis.routes {
        if route.params.body.is_some() {
            output.push_str(&generate_interface(route));
            output.push_str("\n\n");
        }
    }

    // Generate handler functions using wrapBodyHandler pattern
    for route in &analysis.routes {
        output.push_str(&generate_handler(route));
        output.push_str("\n\n");
    }

    output.push_str(&generate_main(analysis));

    Ok(output)
}

fn generate_header() -> String {
    r#"#!/usr/bin/env node
/**
 * Auto-generated Spikard-Node benchmark server
 *
 * DO NOT EDIT - Generated by app-generator
 */

"#
    .to_string()
}

fn generate_imports(_has_body_handlers: bool) -> String {
    // Import both wrapHandler and wrapBodyHandler for flexibility
    let imports = "import { Spikard, wrapHandler, wrapBodyHandler, type UploadFile } from \"@spikard/node\";\n";

    format!("{}\nconst app = new Spikard();", imports)
}

fn sanitize_handler_name(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let path = route
        .route
        .replace("{", "")
        .replace("}", "")
        .replace("/", "_")
        .replace("-", "_")
        .replace("?", "_")
        .replace("=", "_")
        .replace("&", "_")
        .replace(".", "_")
        .trim_start_matches('_')
        .trim_end_matches('_')
        .to_string();

    if path.is_empty() {
        format!("{}_root", method)
    } else {
        format!("{}_{}", method, path)
    }
}

fn generate_interface_name(route: &RouteInfo) -> String {
    let handler_name = sanitize_handler_name(route);
    // Convert snake_case to PascalCase and append "Request"
    let parts: Vec<&str> = handler_name.split('_').collect();
    let pascal = parts
        .iter()
        .map(|part| {
            if part.is_empty() {
                String::new()
            } else {
                let mut chars = part.chars();
                let first = chars.next().unwrap().to_uppercase().to_string();
                format!("{}{}", first, chars.collect::<String>())
            }
        })
        .collect::<Vec<_>>()
        .join("");

    format!("{}Request", pascal)
}

fn generate_interface(route: &RouteInfo) -> String {
    let interface_name = generate_interface_name(route);
    let mut fields = Vec::new();

    // Add body fields (if any)
    if let Some(_body) = &route.params.body {
        fields.push("  // TODO: Define body fields based on your API".to_string());
    }

    if fields.is_empty() {
        fields.push("  // Add fields here".to_string());
    }

    format!("interface {} {{\n{}\n}}", interface_name, fields.join("\n"))
}

fn generate_handler(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let method_func = if method == "delete" { "delete" } else { &method };

    let path_params = crate::analyzer::extract_path_params(&route.route);
    let has_path_params = !path_params.is_empty();
    let has_body = route.params.body.is_some();
    let has_query = !route.params.query.is_empty();

    // If the route only needs the body, use wrapBodyHandler for a simpler signature.
    if has_body && !has_path_params && !has_query {
        let interface_name = generate_interface_name(route);
        let body = generate_handler_body(route, has_query, has_body);

        return format!(
            r#"app.{}('{}', wrapBodyHandler<{}>(async (body) => {{
  {}
}}));"#,
            method_func, route.route, interface_name, body
        );
    }

    // For all other cases, use wrapHandler and destructure only the parameters we need.
    let mut destructured: Vec<&str> = Vec::new();
    if has_path_params {
        destructured.push("pathParams");
    }
    if has_query {
        destructured.push("queryParams");
    }
    if has_body {
        destructured.push("body");
    }

    let signature = if destructured.is_empty() {
        "()".to_string()
    } else {
        format!("({{ {} }})", destructured.join(", "))
    };

    let body = generate_handler_body(route, has_query, has_body);

    format!(
        r#"app.{}('{}', wrapHandler(async {} => {{
  {}
}}));"#,
        method_func, route.route, signature, body
    )
}

fn generate_handler_body(route: &RouteInfo, has_query: bool, has_body: bool) -> String {
    let mut lines = Vec::new();
    lines.push("const response: Record<string, unknown> = {};".to_string());

    let path_params = crate::analyzer::extract_path_params(&route.route);
    for param_name in &path_params {
        lines.push(format!("  if (pathParams['{}'] !== undefined) {{", param_name));
        lines.push(format!(
            "    response['{}'] = pathParams['{}'];",
            param_name, param_name
        ));
        lines.push("  }".to_string());
    }

    if has_query {
        for (name, _) in &route.params.query {
            lines.push(format!("  if (queryParams['{}'] !== undefined) {{", name));
            lines.push(format!("    response['{}'] = queryParams['{}'];", name, name));
            lines.push("  }".to_string());
        }
    }

    if has_body {
        lines.push("  Object.assign(response, body);".to_string());
    }

    lines.push("  return response;".to_string());

    lines.join("\n    ")
}

fn generate_handler_body_simple(route: &RouteInfo) -> String {
    let mut lines = Vec::new();
    lines.push("const response: Record<string, unknown> = {};".to_string());

    let path_params = crate::analyzer::extract_path_params(&route.route);
    for param_name in &path_params {
        lines.push(format!("  if (pathParams['{}'] !== undefined) {{", param_name));
        lines.push(format!(
            "    response['{}'] = pathParams['{}'];",
            param_name, param_name
        ));
        lines.push("  }".to_string());
    }

    for (name, _) in &route.params.query {
        lines.push(format!("  // response['{}'] = /* query param: {} */;", name, name));
    }

    lines.push("  return response;".to_string());

    lines.join("\n    ")
}

fn generate_main(_analysis: &RouteAnalysis) -> String {
    r#"
// Start the server
const port = process.argv[2] ? parseInt(process.argv[2]) : 8000;
console.error(`[spikard-node] Starting server on port ${port}`);
await app.run({ host: "0.0.0.0", port });
"#
    .to_string()
}
