//! Spikard-Node code generator
//!
//! Generates JavaScript code using Spikard Node bindings with the raw API
//! (routes array + handlers object) that works with ThreadsafeFunction

use crate::analyzer::{RouteAnalysis, RouteInfo};
use anyhow::Result;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    // Generate file header
    output.push_str(&generate_header());

    // Generate route registration helpers
    output.push_str(&generate_helpers());

    // Generate handler functions
    for route in &analysis.routes {
        output.push_str(&generate_handler(route));
        output.push_str("\n\n");
    }

    // Generate route registrations
    for route in &analysis.routes {
        output.push_str(&generate_route_registration(route));
        output.push_str("\n");
    }

    // Generate app object and server startup
    output.push_str(&generate_main());

    Ok(output)
}

fn generate_header() -> String {
    r#"#!/usr/bin/env node
/**
 * Auto-generated Spikard-Node benchmark server
 *
 * DO NOT EDIT - Generated by app-generator
 */

// Route registration arrays
const routes = [];
const handlers = {};

"#
    .to_string()
}

fn generate_helpers() -> String {
    r#"// Helper functions to register routes
function registerRoute(method, path, handler) {
  const metadata = {
    method: method.toUpperCase(),
    path,
    handler_name: handler.name,
    is_async: true,
  };
  routes.push(metadata);
  handlers[handler.name] = handler;
  return handler;
}

function get(path) {
  return (handler) => registerRoute('GET', path, handler);
}

function post(path) {
  return (handler) => registerRoute('POST', path, handler);
}

function put(path) {
  return (handler) => registerRoute('PUT', path, handler);
}

function patch(path) {
  return (handler) => registerRoute('PATCH', path, handler);
}

function del(path) {
  return (handler) => registerRoute('DELETE', path, handler);
}

function head(path) {
  return (handler) => registerRoute('HEAD', path, handler);
}

function options(path) {
  return (handler) => registerRoute('OPTIONS', path, handler);
}

// Handler functions that accept JSON string and return Promise<string>
"#
    .to_string()
}

fn sanitize_handler_name(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let path = route
        .route
        .replace("{", "")
        .replace("}", "")
        .replace("/", "_")
        .replace("-", "_")
        .replace("?", "_")
        .replace("=", "_")
        .replace("&", "_")
        .replace(".", "_")
        .trim_start_matches('_')
        .trim_end_matches('_')
        .to_string();

    if path.is_empty() {
        format!("{}_root", method)
    } else {
        format!("{}_{}", method, path)
    }
}

fn generate_handler(route: &RouteInfo) -> String {
    let handler_name = sanitize_handler_name(route);
    let body = generate_handler_body(route);

    format!(
        r#"async function {}(requestJson) {{
  const request = JSON.parse(requestJson);
  const response = {{}};
  {}
  return JSON.stringify(response);
}}"#,
        handler_name, body
    )
}

fn generate_handler_body(route: &RouteInfo) -> String {
    let mut lines = Vec::new();

    // Add path params to response
    for (name, _) in &route.params.path {
        lines.push(format!("  response['{}'] = request.path_params.{};", name, name));
    }

    // Add query params to response
    for (name, _) in &route.params.query {
        lines.push(format!("  if (request.query_params.{} !== undefined) {{", name));
        lines.push(format!("    response['{}'] = request.query_params.{};", name, name));
        lines.push("  }".to_string());
    }

    // Return body if present
    if route.params.body.is_some() {
        lines.push("  Object.assign(response, request.body);".to_string());
    }

    lines.join("\n")
}

fn generate_route_registration(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let handler_name = sanitize_handler_name(route);

    // Use 'del' for DELETE since 'delete' is a reserved keyword in JavaScript
    let method_func = if method == "delete" { "del" } else { &method };

    format!("{}('{}')({});", method_func, route.route, handler_name)
}

fn generate_main() -> String {
    r#"
// Create app object
const app = {
  routes,
  handlers,
};

// Load and run the server
const path = require('path');
const nativePath = path.join(__dirname, '../../../../packages/node/spikard-node.darwin-arm64.node');
const native = require(nativePath);
const port = process.argv[2] ? parseInt(process.argv[2]) : 8000;

console.error(`[spikard-node] Starting server on port ${port}`);
native.runServer(app, '0.0.0.0', port);
"#
    .to_string()
}
