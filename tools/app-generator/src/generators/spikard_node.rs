//! Spikard-Node code generator
//!
//! Generates TypeScript code using the correct Spikard Node.js API:
//! - Handler functions with HandlerInput and HandlerOutput types
//! - App structure with routes array and handlers object
//! - runServer() function to start the server

use crate::analyzer::{RouteAnalysis, RouteInfo};
use anyhow::Result;
use std::collections::HashMap;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    output.push_str(&generate_header());
    output.push_str(&generate_imports());
    output.push_str("\n\n");

    // Add health check handler
    output.push_str(&generate_health_handler());
    output.push_str("\n\n");

    // Build a map of base handler names to their routes (to detect duplicates and assign unique names)
    let mut handler_name_map: HashMap<String, Vec<usize>> = HashMap::new();
    for (idx, route) in analysis.routes.iter().enumerate() {
        let handler_name = sanitize_handler_name(route);
        handler_name_map
            .entry(handler_name)
            .or_insert_with(Vec::new)
            .push(idx);
    }

    // Generate handler functions with unique names
    for (idx, route) in analysis.routes.iter().enumerate() {
        let base_name = sanitize_handler_name(route);
        let final_name = if handler_name_map[&base_name].len() > 1 {
            // Multiple routes with same base name - add an index suffix
            let position_in_duplicates = handler_name_map[&base_name]
                .iter()
                .position(|&i| i == idx)
                .unwrap();
            format!("{}_{}", base_name, position_in_duplicates + 1)
        } else {
            base_name
        };
        output.push_str(&generate_handler_function(route, &final_name));
        output.push_str("\n\n");
    }

    // Generate createApp function
    output.push_str(&generate_create_app(analysis, &handler_name_map));
    output.push_str("\n\n");

    // Generate main entry point
    output.push_str(&generate_main());

    Ok(output)
}

fn generate_header() -> String {
    r#"/**
 * Auto-generated Spikard-Node benchmark server
 *
 * DO NOT EDIT - Generated by app-generator
 */
"#
    .to_string()
}

fn generate_imports() -> String {
    "import { runServer, type HandlerInput, type HandlerOutput } from \"@spikard/node\";"
        .to_string()
}

fn generate_health_handler() -> String {
    r#"// Health check handler for the benchmark harness
async function health(_request: HandlerInput): Promise<HandlerOutput> {
	return {
		status: 200,
		body: { status: "ok" },
	};
}"#
    .to_string()
}

fn sanitize_handler_name(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let path = route
        .route
        .replace("{", "")
        .replace("}", "")
        .replace("/", "_")
        .replace("-", "_")
        .replace("?", "_")
        .replace("=", "_")
        .replace("&", "_")
        .replace(".", "_")
        .trim_start_matches('_')
        .trim_end_matches('_')
        .to_string();

    if path.is_empty() {
        format!("{}_root", method)
    } else {
        format!("{}_{}", method, path)
    }
}

fn generate_handler_function(route: &RouteInfo, final_name: &str) -> String {
    let path_params = crate::analyzer::extract_path_params(&route.route);
    let has_body = route.params.body.is_some();
    let has_query = !route.params.query.is_empty();

    // Determine if request parameter is actually used
    let uses_request = !path_params.is_empty() || has_body || has_query;

    let mut body_lines = Vec::new();
    body_lines.push("\tconst response: Record<string, unknown> = {};".to_string());

    // Add path params to response
    for param_name in &path_params {
        body_lines.push(format!(
            "\tif (request.pathParams?.['{}'] !== undefined) {{",
            param_name
        ));
        body_lines.push(format!(
            "\t\tresponse['{}'] = request.pathParams['{}'];",
            param_name, param_name
        ));
        body_lines.push("\t}".to_string());
    }

    // Add query params to response
    if has_query {
        for name in route.params.query.keys() {
            body_lines.push(format!(
                "\tif (request.queryParams?.['{}'] !== undefined) {{",
                name
            ));
            body_lines.push(format!(
                "\t\tresponse['{}'] = request.queryParams['{}'];",
                name, name
            ));
            body_lines.push("\t}".to_string());
        }
    }

    // Add body to response
    if has_body {
        body_lines.push("\tif (request.body !== undefined) {".to_string());
        body_lines.push("\t\tObject.assign(response, request.body);".to_string());
        body_lines.push("\t}".to_string());
    }

    body_lines.push("\treturn {".to_string());
    body_lines.push("\t\tstatus: 200,".to_string());
    body_lines.push("\t\tbody: response,".to_string());
    body_lines.push("\t};".to_string());

    format!(
        "async function {}({}request: HandlerInput): Promise<HandlerOutput> {{\n{}\n}}",
        final_name,
        if uses_request { "" } else { "_" },
        body_lines.join("\n")
    )
}

fn generate_create_app(analysis: &RouteAnalysis, handler_name_map: &HashMap<String, Vec<usize>>) -> String {
    let mut output = String::new();
    output.push_str("export function createApp() {\n");
    output.push_str("\treturn {\n");
    output.push_str("\t\troutes: [\n");

    // Add health check route first
    output.push_str("\t\t\t{\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tpath: \"/health\",\n\t\t\t\thandler_name: \"health\",\n\t\t\t\tis_async: true,\n\t\t\t},\n");

    // Generate routes array
    for (idx, route) in analysis.routes.iter().enumerate() {
        let base_name = sanitize_handler_name(route);
        let final_name = if handler_name_map[&base_name].len() > 1 {
            // Multiple routes with same base name - add an index suffix
            let position_in_duplicates = handler_name_map[&base_name]
                .iter()
                .position(|&i| i == idx)
                .unwrap();
            format!("{}_{}", base_name, position_in_duplicates + 1)
        } else {
            base_name
        };
        let path = &route.route;
        let method = &route.method;

        output.push_str(&format!(
            "\t\t\t{{\n\t\t\t\tmethod: \"{}\",\n\t\t\t\tpath: \"{}\",\n\t\t\t\thandler_name: \"{}\",\n\t\t\t\tis_async: true,\n\t\t\t}},\n",
            method, path, final_name
        ));
    }

    output.push_str("\t\t],\n");
    output.push_str("\t\thandlers: {\n");

    // Add health handler first
    output.push_str("\t\t\thealth,\n");

    // Generate handlers object
    for (idx, route) in analysis.routes.iter().enumerate() {
        let base_name = sanitize_handler_name(route);
        let final_name = if handler_name_map[&base_name].len() > 1 {
            // Multiple routes with same base name - add an index suffix
            let position_in_duplicates = handler_name_map[&base_name]
                .iter()
                .position(|&i| i == idx)
                .unwrap();
            format!("{}_{}", base_name, position_in_duplicates + 1)
        } else {
            base_name
        };
        output.push_str(&format!("\t\t\t{},\n", final_name));
    }

    output.push_str("\t\t},\n");
    output.push_str("\t};\n");
    output.push_str("}");

    output
}

fn generate_main() -> String {
    r#"// Run if executed directly
import { fileURLToPath } from "node:url";
import { dirname } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

if (import.meta.url === `file://${process.argv[1]}`) {
	const port = process.argv[2] ? parseInt(process.argv[2], 10) : 8000;
	const app = createApp();
	console.log(`Starting Spikard Node.js benchmark server on http://127.0.0.1:${port}`);
	runServer(app, { host: "127.0.0.1", port });
}
"#
    .to_string()
}
