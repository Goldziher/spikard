//! Spikard-PHP code generator
//!
//! Generates PHP code using Spikard bindings

use crate::analyzer::{RouteAnalysis, RouteInfo};
use anyhow::Result;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    output.push_str(&generate_header(analysis));
    output.push('\n');

    output.push_str("$app = new App();\n\n");

    // Add health check endpoint first
    output.push_str(&generate_health_check());
    output.push_str("\n\n");

    for route in &analysis.routes {
        output.push_str(&generate_handler(route));
        output.push_str("\n\n");
    }

    output.push_str(&generate_main());

    Ok(output)
}

fn generate_header(analysis: &RouteAnalysis) -> String {
    let mut header = r#"<?php
declare(strict_types=1);

/**
 * Auto-generated Spikard-PHP benchmark server
 *
 * DO NOT EDIT - Generated by app-generator
 */

require_once __DIR__ . '/../../../../packages/php/src/App.php';
require_once __DIR__ . '/../../../../packages/php/src/Http/Request.php';
require_once __DIR__ . '/../../../../packages/php/src/Http/Response.php';

use Spikard\App;
use Spikard\Http\Request;
use Spikard\Http\Response;
"#
    .to_string();

    // Check if any routes need config for middleware
    let has_middleware = analysis.routes.iter().any(|r| r.has_middleware());
    if has_middleware {
        header.push_str("use Spikard\\Config\\ServerConfig;\n");
        header.push_str("use Spikard\\Config\\JwtConfig;\n");
        header.push_str("use Spikard\\Config\\ApiKeyConfig;\n");
    }

    header
}

fn generate_health_check() -> String {
    r#"$app->get('/health', function(Request $request): array {
    return ['status' => 'ok'];
});"#
        .to_string()
}

fn generate_handler(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let handler_body = generate_handler_body(route);

    format!(
        r#"$app->{}('{}', function(Request $request): array {{
    {}
}});"#,
        method, route.route, handler_body
    )
}

fn generate_handler_body(route: &RouteInfo) -> String {
    let mut lines = Vec::new();
    lines.push("$response = [];".to_string());

    // Extract path parameters
    let path_params = crate::analyzer::extract_path_params(&route.route);
    for param_name in &path_params {
        lines.push(format!(
            "$response['{}'] = $request->pathParams['{}'];",
            param_name, param_name
        ));
    }

    // Extract query parameters
    for name in route.params.query.keys() {
        lines.push(format!("if (isset($request->queryParams['{}'])) {{", name));
        lines.push(format!(
            "    $response['{}'] = $request->queryParams['{}'];",
            name, name
        ));
        lines.push("}".to_string());
    }

    // Extract headers if needed
    for name in route.params.headers.keys() {
        lines.push(format!("if (isset($request->headers['{}'])) {{", name));
        lines.push(format!("    $response['{}'] = $request->headers['{}'];", name, name));
        lines.push("}".to_string());
    }

    // Extract body if present
    if route.params.body.is_some() {
        lines.push("if ($request->body !== null) {".to_string());
        lines.push("    $response = array_merge($response, $request->body);".to_string());
        lines.push("}".to_string());
    }

    lines.push("return $response;".to_string());

    lines.join("\n    ")
}

fn generate_main() -> String {
    r#"if (PHP_SAPI === 'cli' && __FILE__ === realpath($_SERVER['SCRIPT_FILENAME'])) {
    $port = (int)($argv[1] ?? 8000);
    error_log("Starting Spikard-PHP server on port $port");
    $app->listen($port);
}
"#
    .to_string()
}
