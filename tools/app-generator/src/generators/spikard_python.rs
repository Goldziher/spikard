//! Spikard-Python code generator
//!
//! Generates Python code using Spikard bindings

use crate::analyzer::{RouteAnalysis, RouteInfo};
use crate::fixture::ParameterDef;
use anyhow::Result;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    // Generate imports
    output.push_str(&generate_imports());

    // Create app
    output.push_str("app = Spikard()\n\n\n");

    // Generate handler functions
    for route in &analysis.routes {
        output.push_str(&generate_handler(route));
        output.push_str("\n\n");
    }

    // Generate main block
    output.push_str(&generate_main());

    Ok(output)
}

fn generate_imports() -> String {
    r#"#!/usr/bin/env python3
"""Auto-generated Spikard-Python benchmark server.

DO NOT EDIT - Generated by app-generator
"""

from typing import Any
from spikard import Spikard, delete, get, patch, post, put

"#
    .to_string()
}

fn generate_handler(route: &RouteInfo) -> String {
    let fn_name = generate_handler_name(route);
    let decorator = generate_decorator(route);
    let params = generate_parameters(route);
    let body = generate_handler_body(route);

    format!(
        r#"@{}("{}")
async def {}({}) -> dict[str, Any]:
    """Handler for {} {}."""
    {}"#,
        decorator, route.route, fn_name, params, route.method, route.route, body
    )
}

fn generate_decorator(route: &RouteInfo) -> String {
    match route.method.to_uppercase().as_str() {
        "GET" => "get",
        "POST" => "post",
        "PUT" => "put",
        "DELETE" => "delete",
        "PATCH" => "patch",
        _ => "get",
    }
    .to_string()
}

fn generate_handler_name(route: &RouteInfo) -> String {
    let method_prefix = route.method.to_lowercase();

    // Strip query parameters from route (everything after ?)
    let path_without_query = route.route.split('?').next().unwrap_or(&route.route);

    // Strip type hints like {id:int} -> {id}
    let path = path_without_query
        .trim_start_matches('/')
        .split('/')
        .map(|segment| {
            if segment.starts_with('{') && segment.ends_with('}') {
                // Extract param name without type hint
                let inner = &segment[1..segment.len() - 1];
                if let Some(colon_pos) = inner.find(':') {
                    &inner[..colon_pos]
                } else {
                    inner
                }
            } else {
                segment
            }
        })
        .collect::<Vec<_>>()
        .join("_")
        .replace('-', "_");

    if path.is_empty() {
        format!("{}_root", method_prefix)
    } else {
        format!("{}_{}", method_prefix, path)
    }
}

fn generate_parameters(route: &RouteInfo) -> String {
    let mut params = Vec::new();

    // Path parameters - extract from route pattern
    let path_params = crate::analyzer::extract_path_params(&route.route);
    for param_name in &path_params {
        // Try to get type from params.path, default to str
        let py_type = route
            .params
            .path
            .get(param_name)
            .map(|def| param_to_python_type(def))
            .unwrap_or_else(|| "str".to_string());
        params.push(format!("{}: {}", param_name, py_type));
    }

    // Query parameters
    for (name, def) in &route.params.query {
        let py_type = param_to_python_type(def);
        let default = if is_required(def) {
            String::new()
        } else {
            " = None".to_string()
        };
        params.push(format!("{}: {}{}", name, py_type, default));
    }

    // Body parameter (if POST/PUT/PATCH)
    if route.params.body.is_some() {
        params.push("body: dict[str, Any]".to_string());
    }

    params.join(", ")
}

fn param_to_python_type(param: &ParameterDef) -> String {
    match param {
        ParameterDef::Simple {
            type_name, required, ..
        } => {
            let base_type = match type_name.as_str() {
                "string" | "str" => "str",
                "integer" | "int" => "int",
                "number" | "float" => "float",
                "boolean" | "bool" => "bool",
                "array" => "list[Any]",
                _ => "Any",
            };

            if required.unwrap_or(true) {
                base_type.to_string()
            } else {
                format!("{}  | None", base_type)
            }
        }
        ParameterDef::Full(map) => {
            if let Some(serde_json::Value::String(t)) = map.get("type") {
                match t.as_str() {
                    "string" => "str",
                    "integer" => "int",
                    "number" => "float",
                    "boolean" => "bool",
                    "array" => "list[Any]",
                    _ => "Any",
                }
                .to_string()
            } else {
                "Any".to_string()
            }
        }
    }
}

fn is_required(param: &ParameterDef) -> bool {
    match param {
        ParameterDef::Simple { required, .. } => required.unwrap_or(true),
        ParameterDef::Full(map) => {
            if let Some(serde_json::Value::Bool(req)) = map.get("required") {
                *req
            } else {
                true
            }
        }
    }
}

fn generate_handler_body(route: &RouteInfo) -> String {
    let mut lines = Vec::new();
    lines.push("response = {}".to_string());

    // Add path params to response (extract from route pattern)
    let path_params = crate::analyzer::extract_path_params(&route.route);
    for param_name in &path_params {
        lines.push(format!("response[\"{}\"] = {}", param_name, param_name));
    }

    // Add query params to response
    for (name, _) in &route.params.query {
        lines.push(format!("if {} is not None:", name));
        lines.push(format!("        response[\"{}\"] = {}", name, name));
    }

    // Return body if present
    if route.params.body.is_some() {
        lines.push("response = body".to_string());
    }

    lines.push("return response".to_string());

    lines.join("\n    ")
}

fn generate_main() -> String {
    r#"if __name__ == "__main__":
    import sys

    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
    print(f"Starting Spikard-Python server on port {port}", file=sys.stderr)
    app.run(host="0.0.0.0", port=port)
"#
    .to_string()
}
