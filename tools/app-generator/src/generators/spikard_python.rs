//! Spikard-Python code generator
//!
//! Generates Python code using Spikard bindings

use crate::analyzer::{RouteAnalysis, RouteInfo};
use crate::fixture::ParameterDef;
use anyhow::Result;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    let has_middleware = analysis.routes.iter().any(|r| r.has_middleware());

    output.push_str(&generate_imports(has_middleware));

    if has_middleware {
        output.push_str(&generate_server_config(analysis));
        output.push_str("\n\n");
    }

    if has_middleware {
        output.push_str("app = Spikard(config=config)\n\n\n");
    } else {
        output.push_str("app = Spikard()\n\n\n");
    }

    // Add health check endpoint first
    output.push_str("@get(\"/health\")\n");
    output.push_str("async def health() -> dict[str, Any]:\n");
    output.push_str("    \"\"\"Health check endpoint.\"\"\"\n");
    output.push_str("    return {\"status\": \"ok\"}\n\n\n");

    for route in &analysis.routes {
        output.push_str(&generate_handler(route));
        output.push_str("\n\n");
    }

    output.push_str(&generate_main());

    Ok(output)
}

fn generate_imports(has_middleware: bool) -> String {
    let base_imports = r#"#!/usr/bin/env python3
"""Auto-generated Spikard-Python benchmark server.

DO NOT EDIT - Generated by app-generator
"""

from typing import Any
from spikard import Spikard, delete, get, patch, post, put
"#;

    if has_middleware {
        format!(
            "{}from spikard.config import ServerConfig, JwtConfig, ApiKeyConfig\n\n",
            base_imports
        )
    } else {
        format!("{}\n", base_imports)
    }
}

fn generate_server_config(analysis: &RouteAnalysis) -> String {
    let mut config_parts = Vec::new();

    let mut jwt_config = None;
    let mut api_key_config = None;

    for route in &analysis.routes {
        if let Some(middleware) = &route.middleware {
            if let Some(jwt) = &middleware.jwt_auth {
                if jwt.enabled {
                    jwt_config = Some(jwt.clone());
                }
            }
            if let Some(api_key) = &middleware.api_key_auth {
                if api_key.enabled {
                    api_key_config = Some(api_key.clone());
                }
            }
        }
    }

    if let Some(jwt) = jwt_config {
        let mut jwt_params = Vec::new();
        jwt_params.push(format!("        secret=\"{}\"", jwt.secret));
        jwt_params.push(format!("        algorithm=\"{}\"", jwt.algorithm));

        if let Some(audience) = &jwt.audience {
            if !audience.is_empty() {
                let aud_str = audience
                    .iter()
                    .map(|s| format!("\"{}\"", s))
                    .collect::<Vec<_>>()
                    .join(", ");
                jwt_params.push(format!("        audience=[{}]", aud_str));
            }
        }

        if let Some(issuer) = &jwt.issuer {
            jwt_params.push(format!("        issuer=\"{}\"", issuer));
        }

        if let Some(leeway) = jwt.leeway {
            jwt_params.push(format!("        leeway={}", leeway));
        }

        config_parts.push(format!("    jwt_auth=JwtConfig(\n{}\n    )", jwt_params.join(",\n")));
    }

    if let Some(api_key) = api_key_config {
        let keys_str = api_key
            .keys
            .iter()
            .map(|k| format!("\"{}\"", k))
            .collect::<Vec<_>>()
            .join(", ");
        let api_key_params = vec![
            format!("        keys=[{}]", keys_str),
            format!("        header_name=\"{}\"", api_key.header_name),
        ];
        config_parts.push(format!(
            "    api_key_auth=ApiKeyConfig(\n{}\n    )",
            api_key_params.join(",\n")
        ));
    }

    if config_parts.is_empty() {
        String::new()
    } else {
        format!("config = ServerConfig(\n{}\n)", config_parts.join(",\n"))
    }
}

fn generate_handler(route: &RouteInfo) -> String {
    let fn_name = generate_handler_name(route);
    let decorator = generate_decorator(route);
    let params = generate_parameters(route);
    let body = generate_handler_body(route);

    format!(
        r#"@{}("{}")
async def {}({}) -> dict[str, Any]:
    """Handler for {} {}."""
    {}"#,
        decorator, route.route, fn_name, params, route.method, route.route, body
    )
}

fn generate_decorator(route: &RouteInfo) -> String {
    match route.method.to_uppercase().as_str() {
        "GET" => "get",
        "POST" => "post",
        "PUT" => "put",
        "DELETE" => "delete",
        "PATCH" => "patch",
        _ => "get",
    }
    .to_string()
}

fn generate_handler_name(route: &RouteInfo) -> String {
    let method_prefix = route.method.to_lowercase();

    let path_without_query = route.route.split('?').next().unwrap_or(&route.route);

    let path = path_without_query
        .trim_start_matches('/')
        .split('/')
        .map(|segment| {
            if segment.starts_with('{') && segment.ends_with('}') {
                let inner = &segment[1..segment.len() - 1];
                if let Some(colon_pos) = inner.find(':') {
                    &inner[..colon_pos]
                } else {
                    inner
                }
            } else {
                segment
            }
        })
        .collect::<Vec<_>>()
        .join("_")
        .replace('-', "_");

    if path.is_empty() {
        format!("{}_root", method_prefix)
    } else {
        format!("{}_{}", method_prefix, path)
    }
}

fn generate_parameters(route: &RouteInfo) -> String {
    let mut params = Vec::new();

    let path_params = crate::analyzer::extract_path_params(&route.route);
    for param_name in &path_params {
        let py_type = route
            .params
            .path
            .get(param_name)
            .map(|def| param_to_python_type(def))
            .unwrap_or_else(|| "str".to_string());
        params.push(format!("{}: {}", param_name, py_type));
    }

    for (name, def) in &route.params.query {
        let py_type = param_to_python_type(def);
        let default = if is_required(def) {
            String::new()
        } else {
            " = None".to_string()
        };
        params.push(format!("{}: {}{}", name, py_type, default));
    }

    if route.params.body.is_some() {
        params.push("body: dict[str, Any]".to_string());
    }

    params.join(", ")
}

fn param_to_python_type(param: &ParameterDef) -> String {
    match param {
        ParameterDef::Simple {
            type_name, required, ..
        } => {
            let base_type = match type_name.as_str() {
                "string" | "str" => "str",
                "integer" | "int" => "int",
                "number" | "float" => "float",
                "boolean" | "bool" => "bool",
                "array" => "list[Any]",
                _ => "Any",
            };

            if required.unwrap_or(true) {
                base_type.to_string()
            } else {
                format!("{}  | None", base_type)
            }
        }
        ParameterDef::Full(map) => {
            if let Some(serde_json::Value::String(t)) = map.get("type") {
                match t.as_str() {
                    "string" => "str",
                    "integer" => "int",
                    "number" => "float",
                    "boolean" => "bool",
                    "array" => "list[Any]",
                    _ => "Any",
                }
                .to_string()
            } else {
                "Any".to_string()
            }
        }
    }
}

fn is_required(param: &ParameterDef) -> bool {
    match param {
        ParameterDef::Simple { required, .. } => required.unwrap_or(true),
        ParameterDef::Full(map) => {
            if let Some(serde_json::Value::Bool(req)) = map.get("required") {
                *req
            } else {
                true
            }
        }
    }
}

fn generate_handler_body(route: &RouteInfo) -> String {
    let mut lines = Vec::new();
    lines.push("response = {}".to_string());

    let path_params = crate::analyzer::extract_path_params(&route.route);
    for param_name in &path_params {
        lines.push(format!("response[\"{}\"] = {}", param_name, param_name));
    }

    for (name, _) in &route.params.query {
        lines.push(format!("if {} is not None:", name));
        lines.push(format!("        response[\"{}\"] = {}", name, name));
    }

    if route.params.body.is_some() {
        lines.push("response = body".to_string());
    }

    lines.push("return response".to_string());

    lines.join("\n    ")
}

fn generate_main() -> String {
    r#"if __name__ == "__main__":
    import sys

    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
    print(f"Starting Spikard-Python server on port {port}", file=sys.stderr)
    app.run(host="0.0.0.0", port=port)
"#
    .to_string()
}
