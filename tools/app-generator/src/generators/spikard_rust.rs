//! Spikard-Rust (spikard-http) code generator
//!
//! Generates Rust code using spikard-http directly with native Handler implementation

use crate::analyzer::{RouteAnalysis, RouteInfo};
use anyhow::Result;
use std::collections::HashMap;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    // Generate imports
    output.push_str(&generate_imports());

    // Generate handler functions and collect unique names
    let mut handler_names = HashMap::new();
    let mut handlers_code = String::new();

    for route in &analysis.routes {
        let (fn_name, fn_code) = generate_handler_fn(route, &mut handler_names);
        handlers_code.push_str(&fn_code);
    }

    output.push_str(&handlers_code);

    // Generate main function with the collected handler names
    output.push_str(&generate_main(analysis, &handler_names)?);

    Ok(output)
}

fn generate_imports() -> String {
    r#"//! Auto-generated Spikard-Rust benchmark server
//!
//! DO NOT EDIT - Generated by app-generator

use axum::{
    Router,
    routing::{get, post, put, delete, patch},
    response::Json,
    extract::{Path, Query},
};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;
use std::net::SocketAddr;

"#
    .to_string()
}

fn generate_handler_fn(route: &RouteInfo, handler_names: &mut HashMap<String, String>) -> (String, String) {
    let base_name = generate_base_handler_name(route);

    // Handle collisions by adding a numeric suffix
    let mut fn_name = base_name.clone();
    let mut counter = 2;
    while handler_names.contains_key(&fn_name) {
        fn_name = format!("{}_{}", base_name, counter);
        counter += 1;
    }

    handler_names.insert(fn_name.clone(), route.route.clone());

    let has_query = !route.params.query.is_empty();
    let has_path = !route.params.path.is_empty();

    let mut fn_code = String::new();

    // Generate the handler function
    fn_code.push_str(&format!("async fn {}(", fn_name));

    // Add path parameters if present
    if has_path {
        let path_params: Vec<String> = route
            .params
            .path
            .iter()
            .map(|(name, _)| format!("{}: String", name))
            .collect();
        fn_code.push_str(&format!(
            "Path(({})):{}, ",
            route
                .params
                .path
                .iter()
                .map(|(n, _)| n.as_str())
                .collect::<Vec<_>>()
                .join(", "),
            if path_params.len() == 1 {
                " Path<String>"
            } else {
                &format!(" Path<({})>", path_params.join(", "))
            }
        ));
    }

    // Add query parameters if present
    if has_query {
        fn_code.push_str("Query(query): Query<HashMap<String, String>>, ");
    }

    fn_code.push_str(") -> Json<Value> {\n");
    fn_code.push_str("    let mut response = json!({});\n");

    // Add path parameters to response
    if has_path {
        for (name, _) in &route.params.path {
            fn_code.push_str(&format!("    response[\"{}\"] = json!({});\n", name, name));
        }
    }

    // Add query parameters to response
    if has_query {
        for (name, _) in &route.params.query {
            fn_code.push_str(&format!("    if let Some(val) = query.get(\"{}\") {{\n", name));
            fn_code.push_str(&format!("        response[\"{}\"] = json!(val);\n", name));
            fn_code.push_str("    }\n");
        }
    }

    fn_code.push_str("    Json(response)\n");
    fn_code.push_str("}\n\n");

    (fn_name, fn_code)
}

fn generate_base_handler_name(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let path = route
        .route
        .split('?')
        .next()
        .unwrap_or("")
        .trim_start_matches('/')
        .trim_end_matches('/')
        .replace('/', "_")
        .replace('{', "")
        .replace('}', "")
        .replace('-', "_");

    if path.is_empty() {
        format!("handler_{}_root", method)
    } else {
        format!("handler_{}_{}", method, path)
    }
}

fn generate_main(analysis: &RouteAnalysis, handler_names: &HashMap<String, String>) -> Result<String> {
    let mut route_registrations = Vec::new();
    let mut registered_routes = std::collections::HashSet::new();

    for route in &analysis.routes {
        let base_name = generate_base_handler_name(route);

        // Find the actual function name (might have a suffix)
        let fn_name = handler_names
            .iter()
            .find(|(k, v)| v == &&route.route && k.starts_with(&base_name))
            .map(|(k, _)| k.clone())
            .unwrap_or(base_name);

        let method_fn = match route.method.to_uppercase().as_str() {
            "GET" => "get",
            "POST" => "post",
            "PUT" => "put",
            "DELETE" => "delete",
            "PATCH" => "patch",
            _ => "get",
        };

        // Convert spikard route format to axum format (remove query params)
        let axum_path = route.route.split('?').next().unwrap_or(&route.route);

        // Create a unique key for this route (method + path)
        let route_key = format!("{} {}", route.method.to_uppercase(), axum_path);

        // Skip if we've already registered this route
        if registered_routes.contains(&route_key) {
            continue;
        }
        registered_routes.insert(route_key);

        route_registrations.push(format!(
            r#"        .route("{}", {}({}))"#,
            axum_path, method_fn, fn_name
        ));
    }

    Ok(format!(
        r#"#[tokio::main]
async fn main() {{
    let port: u16 = std::env::args()
        .nth(1)
        .and_then(|s| s.parse().ok())
        .unwrap_or(8000);

    let app = Router::new()
        .route("/health", get(|| async {{ Json(json!({{"status": "ok"}})) }}))
{}
;

    let addr = SocketAddr::from(([0, 0, 0, 0], port));
    eprintln!("Starting Spikard-Rust server on port {{}}", port);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}}
"#,
        route_registrations.join("\n")
    ))
}
