//! Spikard-Rust (spikard-http) code generator
//!
//! Generates Rust code using spikard-http directly with native RustHandler

use crate::analyzer::{RouteAnalysis, RouteInfo};
use anyhow::Result;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    // Generate imports
    output.push_str(&generate_imports());

    // Generate RustHandler implementation
    output.push_str(&generate_rust_handler());

    // Generate handler functions for each route
    for route in &analysis.routes {
        output.push_str(&generate_handler_fn(route));
    }

    // Generate main function
    output.push_str(&generate_main(analysis)?);

    Ok(output)
}

fn generate_imports() -> String {
    r#"//! Auto-generated Spikard-Rust benchmark server
//!
//! DO NOT EDIT - Generated by app-generator

use axum::{body::Body, extract::Request, http::{Response, StatusCode}};
use serde_json::{json, Value};
use spikard_http::handler::{ForeignHandler, HandlerFuture, HandlerResult, RequestData};
use spikard_http::{Method, Router, Server};
use std::collections::HashMap;
use std::sync::Arc;

"#
    .to_string()
}

fn generate_rust_handler() -> String {
    r#"/// Native Rust handler implementing ForeignHandler
#[derive(Clone)]
struct RustHandler {
    handler_fn: Arc<dyn Fn(RequestData) -> Value + Send + Sync>,
}

impl RustHandler {
    fn new<F>(handler_fn: F) -> Self
    where
        F: Fn(RequestData) -> Value + Send + Sync + 'static,
    {
        Self {
            handler_fn: Arc::new(handler_fn),
        }
    }
}

impl ForeignHandler for RustHandler {
    fn call(&self, _req: Request<Body>, request_data: RequestData) -> HandlerFuture {
        let result = (self.handler_fn)(request_data);
        let response = Response::builder()
            .status(StatusCode::OK)
            .header("content-type", "application/json")
            .body(Body::from(result.to_string()))
            .unwrap();

        Box::pin(async move { Ok(response) })
    }
}

"#
    .to_string()
}

fn generate_handler_fn(route: &RouteInfo) -> String {
    let fn_name = generate_handler_name(route);
    let has_query = !route.params.query.is_empty();
    let has_path = !route.params.path.is_empty();
    let has_body = route.params.body.is_some();

    let mut body_lines = Vec::new();
    body_lines.push("let mut response = json!({});".to_string());

    if has_path {
        body_lines.push("// Extract path parameters".to_string());
        for (name, _) in &route.params.path {
            body_lines.push(format!("if let Some(val) = req.path_params.get(\"{}\") {{", name));
            body_lines.push(format!("    response[\"{}\"] = json!(val);", name));
            body_lines.push("}".to_string());
        }
    }

    if has_query {
        body_lines.push("// Extract query parameters".to_string());
        for (name, _) in &route.params.query {
            body_lines.push(format!("if let Some(val) = req.query_params.get(\"{}\") {{", name));
            body_lines.push(format!("    response[\"{}\"] = val.clone();", name));
            body_lines.push("}".to_string());
        }
    }

    if has_body {
        body_lines.push("// Use request body".to_string());
        body_lines.push("if let Some(body) = req.body {".to_string());
        body_lines.push("    response = body;".to_string());
        body_lines.push("}".to_string());
    }

    body_lines.push("response".to_string());

    format!(
        r#"fn {}(req: RequestData) -> Value {{
    {}
}}

"#,
        fn_name,
        body_lines.join("\n    ")
    )
}

fn generate_handler_name(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let path = route
        .route
        .trim_start_matches('/')
        .replace('/', "_")
        .replace('{', "")
        .replace('}', "")
        .replace('-', "_");

    if path.is_empty() {
        format!("handler_{}_root", method)
    } else {
        format!("handler_{}_{}", method, path)
    }
}

fn generate_main(analysis: &RouteAnalysis) -> Result<String> {
    let mut route_registrations = Vec::new();

    for route in &analysis.routes {
        let handler_name = generate_handler_name(route);
        let method = match route.method.to_uppercase().as_str() {
            "GET" => "Method::Get",
            "POST" => "Method::Post",
            "PUT" => "Method::Put",
            "DELETE" => "Method::Delete",
            "PATCH" => "Method::Patch",
            _ => "Method::Get",
        };

        route_registrations.push(format!(
            r#"    router.add_route(
        {},
        "{}",
        "{}",
        RustHandler::new({}),
    );"#,
            method, route.route, handler_name, handler_name
        ));
    }

    Ok(format!(
        r#"#[tokio::main]
async fn main() {{
    let port: u16 = std::env::args()
        .nth(1)
        .and_then(|s| s.parse().ok())
        .unwrap_or(8000);

    let mut router = Router::new();

    // Add health check
    router.add_route(
        Method::Get,
        "/health",
        "health",
        RustHandler::new(|_| json!({{"status": "ok"}})),
    );

    // Add generated routes
{}

    eprintln!("Starting Spikard-Rust server on port {{}}", port);

    let server = Server::new(router);
    server.run(format!("0.0.0.0:{{}}", port).parse().unwrap()).await.unwrap();
}}
"#,
        route_registrations.join("\n\n")
    ))
}
