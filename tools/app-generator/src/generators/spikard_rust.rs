//! Spikard-Rust (spikard-http) code generator
//!
//! Generates Rust code using the full spikard-http Handler trait system with complete middleware

use crate::analyzer::{RouteAnalysis, RouteInfo};
use anyhow::Result;
use std::collections::HashMap;

pub fn generate(analysis: &RouteAnalysis) -> Result<String> {
    let mut output = String::new();

    // Generate imports
    output.push_str(&generate_imports());

    // Generate handler structs
    let mut handler_names = HashMap::new();
    let mut handlers_code = String::new();

    for route in &analysis.routes {
        let (struct_name, handler_code) = generate_handler_struct(route, &mut handler_names);
        handlers_code.push_str(&handler_code);
    }

    output.push_str(&handlers_code);

    // Generate main function
    output.push_str(&generate_main(analysis, &handler_names)?);

    Ok(output)
}

fn generate_imports() -> String {
    r#"//! Auto-generated Spikard-Rust benchmark server
//!
//! DO NOT EDIT - Generated by app-generator
//!
//! Uses the full spikard-http Handler trait system with complete middleware stack

use spikard_http::{
    handler_trait::{Handler, HandlerResult, RequestData},
    router::Route,
    server::build_router_with_handlers,
    RouteMetadata,
};
use axum::{
    body::Body,
    http::{Response, StatusCode, Request},
};
use serde_json::json;
use std::sync::Arc;
use std::future::Future;
use std::pin::Pin;

"#
    .to_string()
}

fn generate_handler_struct(route: &RouteInfo, handler_names: &mut HashMap<String, String>) -> (String, String) {
    let base_name = generate_base_handler_name(route);

    // Handle collisions by adding a numeric suffix (no underscore for proper PascalCase)
    let mut struct_name = base_name.clone();
    let mut counter = 2;
    while handler_names.contains_key(&struct_name) {
        struct_name = format!("{}{}", base_name, counter);
        counter += 1;
    }

    handler_names.insert(struct_name.clone(), route.route.clone());

    let has_query = !route.params.query.is_empty();
    let has_path = !route.params.path.is_empty();

    let mut code = String::new();

    // Generate handler struct
    code.push_str("#[allow(dead_code)]\n");
    code.push_str(&format!("struct {} {{}}\n\n", struct_name));

    // Implement Handler trait
    code.push_str(&format!("impl Handler for {} {{\n", struct_name));
    code.push_str("    fn call(\n");
    code.push_str("        &self,\n");
    code.push_str("        _request: Request<Body>,\n");

    // Only use request_data if we have params, otherwise prefix with underscore
    if has_path || has_query {
        code.push_str("        request_data: RequestData,\n");
    } else {
        code.push_str("        _request_data: RequestData,\n");
    }

    code.push_str("    ) -> Pin<Box<dyn Future<Output = HandlerResult> + Send + '_>> {\n");
    code.push_str("        Box::pin(async move {\n");

    // Only make response mutable if we need to modify it
    if has_path || has_query {
        code.push_str("            let mut response = json!({});\n\n");
    } else {
        code.push_str("            let response = json!({});\n\n");
    }

    // Add path parameters to response
    if has_path {
        for (name, _) in &route.params.path {
            code.push_str(&format!(
                "            if let Some(val) = request_data.path_params.get(\"{}\") {{\n",
                name
            ));
            code.push_str(&format!("                response[\"{}\"] = json!(val);\n", name));
            code.push_str("            }\n");
        }
        code.push_str("\n");
    }

    // Add query parameters to response
    if has_query {
        for (name, _) in &route.params.query {
            code.push_str(&format!(
                "            if let Some(val) = request_data.query_params.get(\"{}\") {{\n",
                name
            ));
            code.push_str(&format!("                response[\"{}\"] = val.clone();\n", name));
            code.push_str("            }\n");
        }
        code.push_str("\n");
    }

    code.push_str("            let body = serde_json::to_vec(&response)\n");
    code.push_str("                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\n");
    code.push_str("            Response::builder()\n");
    code.push_str("                .status(StatusCode::OK)\n");
    code.push_str("                .header(\"content-type\", \"application/json\")\n");
    code.push_str("                .body(Body::from(body))\n");
    code.push_str("                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))\n");
    code.push_str("        })\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    (struct_name, code)
}

fn generate_base_handler_name(route: &RouteInfo) -> String {
    let method = route.method.to_lowercase();
    let path = route
        .route
        .split('?')
        .next()
        .unwrap_or("")
        .trim_start_matches('/')
        .trim_end_matches('/')
        .replace('/', "_")
        .replace('{', "")
        .replace('}', "")
        .replace('-', "_");

    let name = if path.is_empty() {
        format!("{}_root", method)
    } else {
        format!("{}_{}", method, path)
    };

    // Convert to PascalCase (capitalize first letter of each word)
    name.split('_')
        .filter(|s| !s.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

fn normalize_path_pattern(path: &str) -> String {
    // Replace all path parameters with a generic {param} to detect pattern conflicts
    // e.g., /{id}, /{lang}, /{user_id} all become /{param}
    let mut normalized = String::new();
    let mut in_param = false;

    for ch in path.chars() {
        if ch == '{' {
            in_param = true;
            normalized.push_str("{param");
        } else if ch == '}' {
            in_param = false;
            normalized.push('}');
        } else if !in_param {
            normalized.push(ch);
        }
    }

    normalized
}

fn generate_main(analysis: &RouteAnalysis, handler_names: &HashMap<String, String>) -> Result<String> {
    let mut route_registrations = Vec::new();
    let mut registered_routes = std::collections::HashSet::new();

    for route in &analysis.routes {
        let base_name = generate_base_handler_name(route);

        // Find the actual struct name (might have a suffix)
        let struct_name = handler_names
            .iter()
            .find(|(k, v)| v == &&route.route && k.starts_with(&base_name))
            .map(|(k, _)| k.clone())
            .unwrap_or(base_name);

        let method = route.method.to_uppercase();

        // Convert spikard route format to path (remove query params)
        let path = route.route.split('?').next().unwrap_or(&route.route);

        // Normalize path to detect pattern conflicts (/{id} and /{lang} are the same pattern)
        let normalized_path = normalize_path_pattern(path);
        let route_key = format!("{} {}", method, normalized_path);

        // Skip if we've already registered this pattern
        if registered_routes.contains(&route_key) {
            continue;
        }
        registered_routes.insert(route_key);

        route_registrations.push(format!(
            r#"    routes.push((
        Route::from_metadata(RouteMetadata {{
            method: "{}".to_string(),
            path: "{}".to_string(),
            handler_name: "{}".to_string(),
            request_schema: None,
            response_schema: None,
            parameter_schema: None,
            file_params: None,
            is_async: true,
            cors: None,
        }})?,
        Arc::new({} {{}}) as Arc<dyn Handler>,
    ));"#,
            method, path, struct_name, struct_name
        ));
    }

    Ok(format!(
        r#"#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {{
    let port: u16 = std::env::args()
        .nth(1)
        .and_then(|s| s.parse().ok())
        .unwrap_or(8000);

    eprintln!("Starting Spikard-Rust server on port {{}}", port);

    let mut routes: Vec<(Route, Arc<dyn Handler>)> = Vec::new();

{}

    let app = build_router_with_handlers(routes)?;

    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], port));
    let listener = tokio::net::TcpListener::bind(addr).await?;

    eprintln!("Listening on http://{{}}", addr);

    axum::serve(listener, app).await?;

    Ok(())
}}
"#,
        route_registrations.join("\n\n")
    ))
}
