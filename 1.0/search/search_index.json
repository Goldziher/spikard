{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Spikard Documentation","text":"<p>Spikard is a polyglot API toolkit with a Rust core and first-class bindings for Python, TypeScript/Node, Ruby, and Rust. It keeps routing, middleware, validation, and streaming semantics identical across languages so teams can mix runtimes without relearning frameworks.</p>"},{"location":"#hello-route-pick-a-binding","title":"Hello Route (pick a binding)","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\nclass User(Struct):\n    id: int\n    name: str\n\napp = Spikard()\n\n@app.get(\"/users/{id:int}\")\nasync def get_user(id: int) -&gt; User:\n    return User(id=id, name=\"Alice\")\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/users/:id\", handler_name: \"getUser\", is_async: true },\n  async (req: Request): Promise&lt;User&gt; =&gt; {\n    const id = Number(req.params[\"id\"] ?? 0);\n    return { id, name: \"Alice\" };\n  },\n);\n\nif (require.main === module) {\n  app.run({ port: 8000 });\n}\n</code></pre> <pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get(\"/users/:id\") do |params, _query, _body|\n  { id: params[:id].to_i, name: \"Alice\" }\nend\n\napp.run(port: 8000)\n</code></pre> <pre><code>use axum::response::Json;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::{get, App, RequestContext};\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct User {\n    id: i64,\n    name: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut app = App::new();\n\n    app.route(get(\"/users/:id\"), |ctx: RequestContext| async move {\n        let id = ctx.path_param(\"id\").unwrap_or(\"0\").parse::&lt;i64&gt;().unwrap_or_default();\n        Ok(Json(User { id, name: \"Alice\".into() }).into())\n    })?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"#documentation-map","title":"Documentation Map","text":"<ul> <li>Getting Started \u2013 First route in each language plus how to run it.</li> <li>Installation \u2013 Binding install commands and repo setup.</li> <li>Guides \u2013 Routing, requests/responses, middleware, validation, dependency injection, deployment.</li> <li>Concepts \u2013 Architecture, runtime model, validation, middleware, streaming internals.</li> <li>Reference \u2013 Language APIs, configuration surface, types, and error semantics.</li> <li>CLI \u2013 Running the HTTP server and invoking generators from <code>spikard-cli</code>.</li> <li>ADRs \u2013 Design history and rationale behind the runtime.</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Questions / bugs: open an issue at github.com/Goldziher/spikard.</li> <li>Chat: join the community Discord (<code>https://discord.gg/pXxagNK2zN</code>).</li> <li>Contributing: see Contributing for coding standards, environment setup, and testing instructions.</li> </ul>"},{"location":"RELEASE_SETUP/","title":"PHP Release Setup and Workflow","text":"<p>This document describes the PHP publishing workflow for Spikard and the secrets/credentials required to run it.</p>"},{"location":"RELEASE_SETUP/#overview","title":"Overview","text":"<p>The PHP release workflow publishes Spikard PHP bindings to: 1. GitHub Releases - Pre-built extension binaries (.so, .dylib, .dll) 2. Packagist - Composer package registry for easy installation 3. PIE Source Bundle - For users who need to compile locally</p>"},{"location":"RELEASE_SETUP/#architecture","title":"Architecture","text":"<p>The release workflow is defined in <code>.github/workflows/release-php.yml</code> and orchestrated through Taskfile tasks.</p>"},{"location":"RELEASE_SETUP/#workflow-stages","title":"Workflow Stages","text":"<ol> <li>Prepare - Validates tags, computes versions, detects if it's a tag push</li> <li>Build - Compiles PHP extensions for multiple platforms (Matrix):</li> <li>Linux x86_64 (PHP 8.2, 8.3)</li> <li>Linux ARM64 (PHP 8.2, 8.3)</li> <li>macOS arm64 (PHP 8.2, 8.3)</li> <li>Windows x86_64 (PHP 8.2, 8.3)</li> <li>PIE Source Bundle - Creates source distribution for local compilation</li> <li>Smoke Tests - Validates extension loading on each platform</li> <li>Linting - Runs PHPStan static analysis</li> <li>Version Check - Verifies version consistency across manifests</li> <li>Upload - Publishes artifacts to GitHub Releases (tag releases only)</li> <li>Publish - Notifies Packagist of new version</li> </ol>"},{"location":"RELEASE_SETUP/#required-github-secrets","title":"Required GitHub Secrets","text":"<p>Add these secrets to your GitHub repository settings (Settings &gt; Secrets and variables &gt; Actions):</p>"},{"location":"RELEASE_SETUP/#packagist_vendor_api_token-required","title":"PACKAGIST_VENDOR_API_TOKEN (Required)","text":"<p>Purpose: Authenticate with Packagist API to trigger package updates</p> <p>How to obtain: 1. Visit https://packagist.org/profile/ 2. Log in with your Packagist account (or create one) 3. Navigate to \"API token\" section 4. Generate a new API token 5. Copy the token</p> <p>Security: - Store in GitHub as an organization secret (not repository) - Rotate every 90 days - Use minimal scope (vendor-level access only)</p> <p>Example value format: <pre><code>token abc123def456ghi789jkl012mno345\n</code></pre></p>"},{"location":"RELEASE_SETUP/#github_token-auto-provided","title":"GITHUB_TOKEN (Auto-provided)","text":"<p>Purpose: Authenticate with GitHub API for release uploads</p> <p>How it works: - Automatically provided by GitHub Actions - Scoped to the repository - Has <code>contents: write</code> permission for this workflow - No manual setup needed</p>"},{"location":"RELEASE_SETUP/#setup-instructions","title":"Setup Instructions","text":""},{"location":"RELEASE_SETUP/#1-register-spikard-package-on-packagist","title":"1. Register Spikard Package on Packagist","text":"<p>If not already registered:</p> <ol> <li>Visit https://packagist.org/submit</li> <li>Enter GitHub repository URL: <code>https://github.com/Goldziher/spikard</code></li> <li>Click \"Check\"</li> <li>Review package name (should auto-populate as <code>spikard/extension</code>)</li> <li>Click \"Submit\"</li> </ol>"},{"location":"RELEASE_SETUP/#2-enable-github-webhook","title":"2. Enable GitHub Webhook","text":"<ol> <li>Go to https://packagist.org/profile/ and log in</li> <li>Find \"spikard/extension\" package</li> <li>Click \"Configure\" or \"Edit\"</li> <li>In \"GitHub\" section, ensure webhook is enabled</li> <li>If auto-update is not enabled, click \"Update\" or trigger manually</li> </ol>"},{"location":"RELEASE_SETUP/#3-add-github-secret","title":"3. Add GitHub Secret","text":"<ol> <li>Go to repository Settings</li> <li>Navigate to \"Secrets and variables\" &gt; \"Actions\"</li> <li>Click \"New repository secret\"</li> <li>Name: <code>PACKAGIST_VENDOR_API_TOKEN</code></li> <li>Value: Paste your Packagist API token</li> <li>Click \"Add secret\"</li> </ol>"},{"location":"RELEASE_SETUP/#4-verify-composerjson-version","title":"4. Verify composer.json Version","text":"<p>Ensure <code>packages/php/composer.json</code> has a <code>version</code> field:</p> <pre><code>{\n  \"name\": \"spikard/extension\",\n  \"version\": \"0.1.3\",\n  \"description\": \"PHP bindings for the Spikard runtime...\"\n}\n</code></pre> <p>If missing, run: <pre><code>task version:sync:php\n</code></pre></p>"},{"location":"RELEASE_SETUP/#release-workflow","title":"Release Workflow","text":""},{"location":"RELEASE_SETUP/#releasing-a-new-version","title":"Releasing a New Version","text":""},{"location":"RELEASE_SETUP/#step-1-update-versions","title":"Step 1: Update Versions","text":"<p>Run the version sync to ensure all manifests match:</p> <pre><code># This updates both Cargo.toml and composer.json to the same version\ntask version:sync\n</code></pre> <p>Verify changes: <pre><code>git diff Cargo.toml packages/php/composer.json\n</code></pre></p>"},{"location":"RELEASE_SETUP/#step-2-commit-version-changes","title":"Step 2: Commit Version Changes","text":"<pre><code>git add Cargo.toml packages/php/composer.json crates/spikard-php/Cargo.toml\ngit commit -m \"chore: bump version to v0.1.4\"\n</code></pre>"},{"location":"RELEASE_SETUP/#step-3-test-release-workflow-optional","title":"Step 3: Test Release Workflow (Optional)","text":"<p>Perform a dry-run to validate the workflow before publishing:</p> <pre><code># Builds all artifacts without publishing\ntask release:php:dry-run -- --set TAG=v0.1.4-test --set REF=main\n</code></pre> <p>This will: - Build all platform binaries - Create PIE source bundle - Run smoke tests - Run PHPStan linting - Verify versions - Skip Packagist publishing</p>"},{"location":"RELEASE_SETUP/#step-4-create-and-push-tag","title":"Step 4: Create and Push Tag","text":"<pre><code># Create an annotated tag (recommended with GPG signing)\ngit tag -s v0.1.4 -m \"Release v0.1.4: PHP bindings\"\n\n# Push tag to trigger workflow\ngit push origin v0.1.4\n</code></pre>"},{"location":"RELEASE_SETUP/#step-5-monitor-release-workflow","title":"Step 5: Monitor Release Workflow","text":"<p>The workflow will automatically trigger. Monitor progress:</p> <pre><code># View workflow status in GitHub\ngh run list --workflow release-php.yml --limit 1\n\n# Stream logs\ngh run view --exit-status &lt;run-id&gt; --log\n</code></pre> <p>The workflow will: 1. Build all platform binaries 2. Create PIE source bundle 3. Run smoke tests 4. Verify versions match 5. Upload to GitHub Releases 6. Notify Packagist</p>"},{"location":"RELEASE_SETUP/#step-6-verify-release","title":"Step 6: Verify Release","text":"<p>After workflow completes:</p> <ol> <li>Check GitHub Releases: https://github.com/Goldziher/spikard/releases</li> <li> <p>Should show v0.1.4 with all binaries and PIE bundle</p> </li> <li> <p>Check Packagist: https://packagist.org/packages/spikard/extension</p> </li> <li> <p>New version should appear (may take 1-2 minutes)</p> </li> <li> <p>Test Installation:    <pre><code># Should be installable via Composer\ncomposer require spikard/extension:0.1.4\n</code></pre></p> </li> </ol>"},{"location":"RELEASE_SETUP/#manual-trigger","title":"Manual Trigger","text":"<p>If tag push doesn't work or you need to re-release:</p> <pre><code># Trigger workflow with custom tag and ref\ntask release:php -- --set TAG=v0.1.4\n</code></pre>"},{"location":"RELEASE_SETUP/#pre-release-checklist","title":"Pre-Release Checklist","text":"<p>Before creating a tag:</p> <ul> <li> All tests pass: <code>task test</code></li> <li> PHP code lints: <code>task php:lint:check</code></li> <li> Version updated in Cargo.toml</li> <li> <code>task version:sync</code> run and committed</li> <li> CHANGELOG.md updated (if applicable)</li> <li> E2E tests pass: <code>task test:e2e:php</code></li> <li> Git working tree clean: <code>git status</code></li> </ul>"},{"location":"RELEASE_SETUP/#troubleshooting","title":"Troubleshooting","text":""},{"location":"RELEASE_SETUP/#workflow-fails-to-build","title":"Workflow Fails to Build","text":"<p>Check Rust build: Run locally first <pre><code>cargo build --release -p spikard-php --features extension-module\n</code></pre></p> <p>Check PHP version: Ensure PHP 8.2+ is in use <pre><code>php --version\n</code></pre></p>"},{"location":"RELEASE_SETUP/#version-mismatch-error","title":"Version Mismatch Error","text":"<p>Occurs when tag doesn't match Cargo.toml/composer.json version.</p> <p>Fix: <pre><code># Get current workspace version\ngrep '^version = ' Cargo.toml\n\n# Update to match\ntask version:sync\n\n# Re-commit and re-tag\ngit add .\ngit commit -m \"chore: sync versions\"\ngit tag -s v0.1.4 -m \"Release v0.1.4\"\ngit push origin v0.1.4\n</code></pre></p>"},{"location":"RELEASE_SETUP/#packagist-update-fails","title":"Packagist Update Fails","text":"<p>Check token: Verify <code>PACKAGIST_VENDOR_API_TOKEN</code> is set <pre><code># In GitHub Actions logs, look for \"PACKAGIST_VENDOR_API_TOKEN not set\" warning\n</code></pre></p> <p>Manual trigger: Packagist has a webhook; if auto-update doesn't work: 1. Go to https://packagist.org/packages/spikard/extension 2. Click \"Force update\" or manually trigger GitHub webhook</p>"},{"location":"RELEASE_SETUP/#extension-fails-to-load-in-smoke-tests","title":"Extension Fails to Load in Smoke Tests","text":"<p>Check platform match: Extension must match OS/PHP version</p> <p>Verify build output: Check GitHub Actions logs for build errors</p> <p>Test locally: <pre><code># Build locally\ncargo build --release -p spikard-php --features extension-module\n\n# Test loading\nphp -d extension=target/release/libspikard_php.dylib -r \"echo 'OK\\n';\"\n</code></pre></p>"},{"location":"RELEASE_SETUP/#security-considerations","title":"Security Considerations","text":""},{"location":"RELEASE_SETUP/#token-management","title":"Token Management","text":"<ul> <li>Packagist Token: Scoped to vendor-level access, rotate every 90 days</li> <li>GitHub Token: Auto-scoped by Actions, no rotation needed</li> <li>Use organization secrets (not repository) for Packagist token</li> <li>Audit who has access to repository settings</li> </ul>"},{"location":"RELEASE_SETUP/#artifact-integrity","title":"Artifact Integrity","text":"<ul> <li>All workflows run on GitHub-hosted runners (no self-hosted)</li> <li>Artifacts signed by GitHub (SLSA provenance in beta)</li> <li>SHA256 checksums in release notes for manual verification</li> </ul>"},{"location":"RELEASE_SETUP/#code-signing","title":"Code Signing","text":"<p>For enhanced security, sign git tags with GPG:</p> <pre><code># Configure GPG\ngit config user.signingkey &lt;your-gpg-key-id&gt;\n\n# Sign tag\ngit tag -s v0.1.4 -m \"Release v0.1.4\"\n\n# Verify signature (GitHub will show \"Verified\" badge)\ngit tag -v v0.1.4\n</code></pre>"},{"location":"RELEASE_SETUP/#rollback-plan","title":"Rollback Plan","text":""},{"location":"RELEASE_SETUP/#automatic-rollback","title":"Automatic Rollback","text":"<p>If any check fails (smoke tests, linting, version checks), the workflow stops and doesn't publish: - Artifacts remain in GitHub Actions (14 day retention) - Packagist is NOT updated - No cleanup needed (just fix the issue and retry)</p>"},{"location":"RELEASE_SETUP/#manual-rollback","title":"Manual Rollback","text":"<p>If a bad version is published to Packagist:</p> <ol> <li> <p>Delete tag (prevents re-publishing):    <pre><code>git tag -d v0.1.4\ngit push origin --delete v0.1.4\n</code></pre></p> </li> <li> <p>Yank on Packagist (mark as unavailable):    <pre><code># Go to https://packagist.org/packages/spikard/extension\n# Find version, click \"Yank\" or use API\ncurl -X DELETE \\\n  https://packagist.org/packages/spikard/extension/v0.1.4 \\\n  -H \"Authorization: token $PACKAGIST_VENDOR_API_TOKEN\"\n</code></pre></p> </li> <li> <p>Create security advisory (if needed):</p> </li> <li>Go to repository Settings &gt; Security &gt; Advisories</li> <li> <p>Document issue and link patched version</p> </li> <li> <p>Release patch version:    <pre><code># Bump version and apply fix\ngit tag -s v0.1.5 -m \"Release v0.1.5: Security patch\"\ngit push origin v0.1.5\n</code></pre></p> </li> </ol>"},{"location":"RELEASE_SETUP/#file-structure","title":"File Structure","text":"<pre><code>.github/\n  workflows/\n    release-php.yml              # Main release workflow\n  actions/\n    build-php-extension/         # Composite action for building\n      action.yml\n    test-php-extension/          # Composite action for testing\n      action.yml\n\nscripts/\n  sync_versions.py               # Syncs version across manifests\n  package_php_pie_source.sh      # Creates PIE source bundle\n\npackages/php/\n  composer.json                  # Packagist metadata (version field)\n  bin/\n    install-extension.php        # Post-install hook (future binary downloader)\n\nTaskfile.yaml\n  release:php:dry-run            # Test release without publishing\n  release:php:                   # Trigger actual release\n  php:build:pie-source           # Build PIE bundle locally\n  version:sync:php               # Sync PHP version\n</code></pre>"},{"location":"RELEASE_SETUP/#references","title":"References","text":"<ul> <li>GitHub Workflows Documentation</li> <li>Packagist API Documentation</li> <li>Composer Post Install Hooks</li> <li>PHP Inspector Extension (PIE)</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>The canonical changelog lives at the repository root. It is included below for convenience when browsing the docs site.</p>"},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-2025-11-23","title":"0.1.0 - 2025-11-23","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#core-framework-rust","title":"Core Framework (Rust)","text":"<ul> <li>High-performance HTTP framework built on Axum and Tower-HTTP</li> <li>Type-safe routing with path parameter extraction</li> <li>JSON Schema validation via schemars</li> <li>RequestContext API for accessing request data (body, query, path params, headers, cookies)</li> <li>WebSocket support with trait-based handler abstraction</li> <li>Server-Sent Events (SSE) support with event producer pattern</li> <li>File upload handling with UploadFile type</li> <li>Streaming response support</li> <li>Testing utilities with in-memory TestServer</li> <li>Integration with custom Axum routers via <code>merge_axum_router</code></li> </ul>"},{"location":"changelog/#middleware-stack-tower-http","title":"Middleware Stack (Tower-HTTP)","text":"<ul> <li>Compression middleware (gzip, brotli) with configurable quality and thresholds</li> <li>Rate limiting with per-second and burst controls</li> <li>Request timeout handling</li> <li>Request ID generation and tracking</li> <li>JWT authentication with multiple algorithm support (HS256, HS384, HS512, RS256)</li> <li>Static file serving with cache control and index file support</li> <li>CORS configuration</li> <li>Graceful shutdown handling</li> </ul>"},{"location":"changelog/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<ul> <li>Zero-cost lifecycle hook system with Option&gt; design <li>Hook stages: <code>on_request</code>, <code>pre_validation</code>, <code>pre_handler</code>, <code>on_response</code>, <code>on_error</code></li> <li>Support for short-circuiting with early responses</li> <li>Async hook support across all language bindings</li>"},{"location":"changelog/#openapi-support","title":"OpenAPI Support","text":"<ul> <li>Automatic OpenAPI 3.1 schema generation from route definitions</li> <li>Swagger UI integration at configurable path</li> <li>ReDoc integration at configurable path</li> <li>Schema extraction from schemars types and raw JSON schemas</li> </ul>"},{"location":"changelog/#python-bindings-pyo3","title":"Python Bindings (PyO3)","text":"<ul> <li>FastAPI/Litestar-style decorator API (<code>@app.get</code>, <code>@post</code>, etc.)</li> <li>Standalone decorators (<code>@get</code>, <code>@post</code>, etc.)</li> <li>Path parameter extraction with type conversion</li> <li>Query parameter support with <code>Query</code> helper</li> <li>Request body validation with multiple backends:</li> <li>msgspec.Struct (recommended, zero-copy, fastest)</li> <li>Pydantic v2 BaseModel</li> <li>dataclasses</li> <li>TypedDict</li> <li>NamedTuple</li> <li>attrs classes</li> <li>Raw JSON Schema dicts</li> <li>WebSocket support via <code>@websocket</code> decorator with async function handlers</li> <li>SSE support via <code>@sse</code> decorator with async generator pattern</li> <li>Background task execution with <code>background.run()</code></li> <li>Custom response objects (Response, StreamingResponse)</li> <li>File upload handling with async <code>UploadFile.aread()</code></li> <li>TestClient for integration testing with WebSocket and SSE support</li> <li>Zero-copy JSON-to-Python conversion via direct PyO3 type construction</li> <li>Async/await support via pyo3_async_runtimes</li> <li>Full type hints with mypy --strict compliance</li> </ul>"},{"location":"changelog/#nodejs-bindings-napi-rs","title":"Node.js Bindings (napi-rs)","text":"<ul> <li>Manual route registration via <code>app.addRoute(metadata, handler)</code></li> <li>Route metadata decorators for type safety</li> <li>Zod schema validation support</li> <li>Raw JSON Schema support</li> <li>Handler wrappers (<code>wrapHandler</code>, <code>wrapBodyHandler</code>) for parameter extraction</li> <li>Request context with query, path params, headers, form data</li> <li>File upload support with UploadFile type</li> <li>Streaming responses with async generators</li> <li>Lifecycle hooks with async callbacks</li> <li>Background task support</li> <li>TestClient with WebSocket and SSE testing utilities</li> <li>Full TypeScript type definitions generated by napi-rs</li> <li>Zero-copy FFI via ThreadsafeFunction for async JavaScript callbacks</li> </ul>"},{"location":"changelog/#ruby-bindings-magnus","title":"Ruby Bindings (magnus)","text":"<ul> <li>Sinatra-style block-based routing (<code>app.get</code>, <code>app.post</code>, etc.)</li> <li>Single request hash argument with unified interface</li> <li>Request hash structure with <code>:method</code>, <code>:path</code>, <code>:path_params</code>, <code>:query</code>, <code>:headers</code>, <code>:cookies</code>, <code>:body</code>, <code>:params</code></li> <li>dry-schema validation support</li> <li>dry-struct validation support</li> <li>Raw JSON Schema support</li> <li>WebSocket support with class-based handlers</li> <li>SSE support with event producer classes</li> <li>Streaming responses with Enumerator</li> <li>Background task execution with <code>Spikard::Background.run</code></li> <li>TestClient with WebSocket and SSE support</li> <li>RBS type definitions for type checking with Steep</li> <li>File upload handling with UploadFile</li> </ul>"},{"location":"changelog/#webassembly-bindings","title":"WebAssembly Bindings","text":"<ul> <li>wasm-bindgen integration for browser and server-side WASM</li> <li>wasm-pack bundling support</li> <li>Optimized binary size with tree-shaking</li> <li>JavaScript/TypeScript interop with proper type safety</li> </ul>"},{"location":"changelog/#testing-infrastructure","title":"Testing Infrastructure","text":"<ul> <li>Fixture-driven testing strategy with 400+ JSON fixtures</li> <li>Centralized <code>testing_data/</code> directory with categorized fixtures:</li> <li><code>headers/</code> - HTTP header validation scenarios</li> <li><code>cookies/</code> - Cookie handling scenarios</li> <li><code>json_bodies/</code> - Request body validation</li> <li><code>validation_errors/</code> - Error response formats</li> <li><code>status_codes/</code> - HTTP status code scenarios</li> <li><code>edge_cases/</code> - Edge case coverage</li> <li><code>cors/</code> - CORS configuration scenarios</li> <li>Schema validation for all fixture directories</li> <li>Parametrized pytest suites for comprehensive coverage</li> <li>95% minimum Rust coverage (tarpaulin)</li> <li>80%+ minimum coverage for Python/Node/Ruby bindings</li> </ul>"},{"location":"changelog/#build-automation","title":"Build &amp; Automation","text":"<ul> <li>Taskfile.yaml for cross-language build orchestration</li> <li>Task commands: <code>setup</code>, <code>build</code>, <code>test</code>, <code>lint</code>, <code>format</code>, <code>update</code></li> <li>Language-specific tasks: <code>rust:build</code>, <code>python:build</code>, <code>node:build</code>, <code>ruby:build</code>, <code>wasm:build</code></li> <li>Multi-language testing: <code>test:rust</code>, <code>test:python</code>, <code>test:node</code>, <code>test:ruby</code></li> <li>Dependency management with committed lock files (Cargo.lock, uv.lock, pnpm-lock.yaml, Gemfile.lock)</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Architecture Decision Records (ADRs) in <code>docs/adr/</code>:</li> <li>0001: Architecture and layering</li> <li>0002: Tower-HTTP middleware and configuration</li> <li>0003: Validation and fixtures strategy</li> <li>0005: Lifecycle hooks design</li> <li>0006: Async and streaming support</li> <li>Language-specific READMEs for Rust, Python, Node, Ruby</li> <li>Runnable examples in <code>examples/</code> for all language bindings</li> <li>Comprehensive API documentation with rustdoc, Python docstrings, JSDoc, RBS</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":""},{"location":"changelog/#documentation-corrections","title":"Documentation Corrections","text":"<ul> <li>Ruby README: Fixed catastrophic handler signature errors (70% of examples incorrect)</li> <li>Corrected from <code>|params, query, body|</code> to single <code>|request|</code> hash argument</li> <li>Added comprehensive \"Request Hash Structure\" documentation</li> <li>Node README: Fixed Quick Start example showing non-existent auto-registration</li> <li>Corrected to use manual <code>app.addRoute(metadata, handler)</code> pattern</li> <li>Clarified that decorators only add metadata, don't auto-register</li> <li>Python README: Fixed 7 critical API mismatches</li> <li>WebSocket: Changed from class-based to decorator-based async function</li> <li>SSE: Changed from class with <code>next_event()</code> to async generator pattern</li> <li>Background tasks: Fixed to use awaitable coroutine, not lambda</li> <li>TestClient WebSocket: Corrected method names to <code>send()</code>/<code>recv()</code></li> <li>UploadFile: Added async <code>aread()</code> example</li> <li>OpenApiConfig: Fixed import path to <code>from spikard.config</code></li> <li>SSE testing: Corrected event iteration pattern</li> <li>Rust README: Fixed 3 type errors in configuration examples</li> <li><code>StaticFilesConfig.index_file</code>: Corrected from <code>Option&lt;bool&gt;</code> to <code>bool</code></li> <li><code>OpenApiConfig</code> paths: Corrected from <code>Option&lt;String&gt;</code> to <code>String</code></li> <li>Trait implementations: Fixed syntax from <code>async fn</code> to <code>-&gt; impl Future</code></li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>JWT validation with configurable algorithms and claims verification</li> <li>Secure cookie defaults (HttpOnly, Secure, SameSite) in Ruby bindings</li> <li>Header and cookie validation against fixture-based schemas</li> <li>Input validation at system boundaries (user input, external APIs)</li> <li>CORS middleware with configurable allowed origins, methods, headers</li> </ul>"},{"location":"changelog/#known-limitations","title":"Known Limitations","text":"<ul> <li>PHP bindings planned but not yet implemented (ext-php-rs integration pending)</li> <li>OpenAPI documentation generation requires schemars types (raw JSON schemas supported but don't contribute to OpenAPI)</li> <li>WebAssembly bindings have limited threading support due to WASM runtime constraints</li> <li>Background tasks in Python require explicit awaitable coroutines (no automatic lambda wrapping)</li> </ul>"},{"location":"changelog/#020-tbd","title":"[0.2.0] - TBD","text":""},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#php-bindings-ext-php-rs","title":"PHP Bindings (ext-php-rs)","text":"<ul> <li>Complete PHP 8.2+ bindings via ext-php-rs with 100% test coverage</li> <li>Native HTTP server with full middleware stack support</li> <li>Parameter extraction helpers (Query, Path, Header, Cookie, Body)</li> <li>Lifecycle hooks implementation (on_request, pre_validation, pre_handler, on_response, on_error)</li> <li>Streaming responses and WebSocket support</li> <li>Server-Sent Events (SSE) support with producer pattern</li> <li>Background task infrastructure with message queue pattern and serialization</li> <li>Dependency injection with thread-local architecture</li> <li>AsyncAPI integration and test generation</li> <li>PHP app generator for benchmark harness</li> <li>Comprehensive test coverage with native PHP test client</li> <li>Full configuration API support matching Python/Node/Ruby bindings</li> </ul>"},{"location":"changelog/#dependency-injection-di","title":"Dependency Injection (DI)","text":"<ul> <li>Cross-language DI framework implementation across all bindings</li> <li>Handler parameter extraction with type-safe context passing</li> <li>Language-specific DI container implementations:</li> <li>Python: PyO3 integration with proper GIL handling</li> <li>Node.js: napi-rs with ThreadsafeFunction support</li> <li>Ruby: Magnus with proper memory management</li> <li>PHP: ext-php-rs with Zval thread-safety</li> <li>100% test pass rates achieved across all bindings (18/18 Python, 442/442 Node, 478/478 Ruby, 100+ PHP)</li> <li>Request context exposure to handlers for accessing parsed parameters</li> </ul>"},{"location":"changelog/#documentation-examples","title":"Documentation &amp; Examples","text":"<ul> <li>MkDocs site setup with comprehensive playbooks and guides</li> <li>Architecture diagram and reference matrices</li> <li>Binding support matrix and feature parity audit</li> <li>Playbooks for authentication, uploads, streaming, background tasks, and error handling</li> <li>Runnable examples for all bindings including WASM/Deno</li> <li>Comprehensive README updates for all language bindings with testable snippets</li> <li>PHP language standards and agent configuration</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":""},{"location":"changelog/#php-implementation","title":"PHP Implementation","text":"<ul> <li>Parameter extraction system now utilizes DI framework for type-safe handler access</li> <li>Streaming and WebSocket handlers refined for production stability</li> <li>Background task system improved with proper serialization and error handling</li> <li>Thread-local architecture adopted for DI container management</li> </ul>"},{"location":"changelog/#build-testing","title":"Build &amp; Testing","text":"<ul> <li>PHP build and test tasks fully enabled with native extension loading</li> <li>E2E generation now supports PHP with schema-aware generation</li> <li>Test generator enhanced for PHP with ServerConfig, schema validation, and response verification</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":""},{"location":"changelog/#php-bindings","title":"PHP Bindings","text":"<ul> <li>Threading issues resolved - proper async handling without deadlocks</li> <li>ARM Mac compilation errors fixed with runtime feature enablement</li> <li>Zval thread safety achieved through thread-local architecture</li> <li>Parameter passing in background tasks corrected</li> <li>Query string handling and null body processing fixed</li> <li>All test failures resolved (query strings, streaming, WebSocket)</li> </ul>"},{"location":"changelog/#bindings-integration","title":"Bindings Integration","text":"<ul> <li>Python server config properly propagates DI container</li> <li>Node DI context correctly flows into handlers</li> <li>Ruby DI snippet evaluation bound to local app</li> <li>API compatibility across all bindings standardized</li> </ul>"},{"location":"changelog/#build-system","title":"Build System","text":"<ul> <li>Biome formatting alignment across codebase</li> <li>Lint issues addressed in all binding implementations</li> <li>PHP e2e generator headers normalization and proper escaping</li> <li>Dependency management stabilized with locked versions</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>PHP snippet API updated to match actual implementation</li> <li>Handler signatures corrected across all binding READMEs</li> <li>TypeScript examples aligned with current request shape</li> <li>WebSocket support status clarified</li> <li>Background task caveats documented</li> </ul>"},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li>Zval thread-safety in PHP bindings ensures safe concurrent access</li> <li>Proper error propagation across FFI boundaries prevents panic leakage</li> <li>DI container thread-local storage prevents cross-request contamination</li> </ul>"},{"location":"changelog/#infrastructure","title":"Infrastructure","text":"<ul> <li>Dependency updates: hono and various GitHub Actions</li> <li>Extended testing coverage across all bindings</li> <li>CI/CD setup for PHP native extension building</li> </ul>"},{"location":"changelog/#011-2025-11-23","title":"0.1.1 - 2025-11-23","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Homebrew formula publishing automation in release workflow</li> <li>Automatic Homebrew tap updates via <code>mislav/bump-homebrew-formula-action@v3</code></li> <li><code>homebrew</code> target to release workflow (can be used with <code>targets: all</code> or <code>targets: homebrew</code>)</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Package publishing configuration for all language bindings</li> <li>README.md inclusion in Python, Node.js, and WASM package manifests</li> <li>CLI crate (<code>spikard-cli</code>) now properly configured for crates.io publishing</li> </ul>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planned","title":"Planned","text":"<ul> <li>PHP bindings via ext-php-rs</li> <li>Enhanced OpenAPI customization options</li> <li>GraphQL support</li> <li>Additional middleware: CSRF protection, session management</li> <li>Performance benchmarks and comparison documentation</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for helping shape Spikard! The fastest way to get started is to follow the existing Taskfile and language-specific READMEs.</p>"},{"location":"contributing/#setup","title":"Setup","text":"<p><pre><code>task setup\n</code></pre> This installs Rust, Python, Node, and Ruby dependencies plus pre-commit hooks.</p>"},{"location":"contributing/#common-tasks","title":"Common Tasks","text":"<ul> <li><code>task build</code> \u2013 build Rust core and bindings</li> <li><code>task test</code> \u2013 run all language test suites</li> <li><code>task lint</code> / <code>task format</code> \u2013 apply linters and formatters</li> <li><code>task docs:serve</code> \u2013 work on this documentation locally</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Keep behavior consistent across bindings; add fixture-driven tests when adding new features.</li> <li>Prefer contract-first changes: update schemas, generators, and ADRs where relevant.</li> <li>Run <code>cargo fmt</code>, <code>cargo clippy</code>, <code>ruff</code>, <code>biome</code>, and language-specific tools before opening a PR.</li> </ul> <p>For more detail, see the root <code>CONTRIBUTING.md</code> file and ADRs that cover design intent.</p>"},{"location":"features/","title":"Features","text":"<p>Spikard delivers the same runtime and developer experience across languages while letting you choose the binding that best fits your stack.</p>"},{"location":"features/#core-runtime","title":"Core Runtime","text":"<ul> <li>Rust HTTP server built on Axum/Tokio with a pluggable middleware pipeline</li> <li>Shared request/response model with structured path/query/header/cookie parsing</li> <li>Built-in JSON Schema validation for inputs and outputs</li> <li>First-class streaming: WebSockets, SSE, and long-running tasks</li> <li>Strong typing across bindings (msgspec/Pydantic, Zod, RBS, serde)</li> </ul>"},{"location":"features/#polyglot-bindings","title":"Polyglot Bindings","text":"<ul> <li>Python via PyO3 with async event-loop orchestration and msgspec validation</li> <li>TypeScript/Node via NAPI-RS with Zod-powered schemas and WASM option</li> <li>Ruby via magnus with Ruby-friendly routing and middleware hooks</li> <li>Rust native API mirroring the binding ergonomics</li> </ul>"},{"location":"features/#developer-experience","title":"Developer Experience","text":"<ul> <li>CLI (<code>spikard-cli</code>) to run apps, hot-reload (planned), and generate DTOs/handlers from OpenAPI or AsyncAPI</li> <li>Taskfile targets for installing deps, building bindings, and serving docs</li> <li>Extensive fixture-driven tests to keep language parity</li> </ul>"},{"location":"features/#deployment","title":"Deployment","text":"<ul> <li>Run as a compiled Rust binary or via the CLI</li> <li>Container-friendly with predictable ports and health checks</li> <li>Configuration via code, environment variables, and upcoming config files (see Configuration)</li> </ul>"},{"location":"php-di-design/","title":"Dependency Injection Design for PHP Bindings","text":""},{"location":"php-di-design/#1-pythonnoderuby-di-analysis","title":"1. Python/Node/Ruby DI Analysis","text":""},{"location":"php-di-design/#python-di-implementation","title":"Python DI Implementation","text":"<p>Core Architecture (packages/python/spikard/di.py): - <code>Provide</code> class wraps factory functions with metadata:   - <code>dependency</code>: The callable (sync/async function or generator)   - <code>depends_on</code>: List of dependency keys this factory needs   - <code>use_cache</code>: Cache within a single request   - <code>singleton</code>: Cache globally across all requests   - <code>is_async</code>, <code>is_generator</code>, <code>is_async_generator</code>: Execution mode flags</p> <p>Rust-Side Python DI (crates/spikard-py/src/di.rs): - <code>PythonValueDependency</code>: Wraps <code>Py&lt;PyAny&gt;</code> for static values - <code>PythonFactoryDependency</code>: Wraps Python callables with dependency resolution   - Stores <code>Py&lt;PyAny&gt;</code> factory callable   - Implements <code>Dependency</code> trait from <code>spikard_core::di</code>   - Handles async execution via <code>PYTHON_EVENT_LOOP</code> and <code>tokio::task::spawn_blocking</code>   - Supports async generators with cleanup tasks</p> <p>Extraction Flow (crates/spikard-py/src/lib.rs:486-544): <pre><code>fn build_dependency_container(py: Python, dependencies: &amp;Bound&lt;PyAny&gt;) -&gt; PyResult&lt;DependencyContainer&gt; {\n    let mut container = DependencyContainer::new();\n\n    for (key, value) in deps_dict.iter() {\n        if value.hasattr(\"dependency\")? {\n            // Provide wrapper - extract factory details\n            let factory = value.getattr(\"dependency\")?;\n            let depends_on: Vec&lt;String&gt; = value.getattr(\"depends_on\")?;\n            let singleton: bool = value.getattr(\"singleton\")?;\n            // Create PythonFactoryDependency\n        } else {\n            // Static value - create PythonValueDependency\n        }\n        container.register(key, Arc::new(dependency))?;\n    }\n}\n</code></pre></p> <p>Handler Parameter Injection (packages/python/spikard/app.py:110-135): - Uses Python's <code>inspect.signature()</code> to extract handler parameters - Matches parameter names against registered dependency keys - Stores list in <code>Route.handler_dependencies</code> - Rust handler receives this list and resolves dependencies before calling Python handler</p>"},{"location":"php-di-design/#core-rust-di-infrastructure-cratesspikard-coresrcdi","title":"Core Rust DI Infrastructure (crates/spikard-core/src/di/)","text":"<p><code>Dependency</code> Trait (dependency.rs): <pre><code>pub trait Dependency: Send + Sync {\n    fn resolve(\n        &amp;self,\n        request: &amp;Request&lt;()&gt;,\n        request_data: &amp;RequestData,\n        resolved: &amp;ResolvedDependencies,\n    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Arc&lt;dyn Any + Send + Sync&gt;, DependencyError&gt;&gt; + Send&gt;&gt;;\n\n    fn key(&amp;self) -&gt; &amp;str;\n    fn depends_on(&amp;self) -&gt; Vec&lt;String&gt;;\n    fn cacheable(&amp;self) -&gt; bool { false }\n    fn singleton(&amp;self) -&gt; bool { false }\n}\n</code></pre></p> <p><code>DependencyContainer</code> (container.rs): - Stores <code>IndexMap&lt;String, Arc&lt;dyn Dependency&gt;&gt;</code> - <code>DependencyGraph</code> for topological sorting and cycle detection - Singleton cache: <code>Arc&lt;RwLock&lt;HashMap&lt;String, Arc&lt;dyn Any + Send + Sync&gt;&gt;&gt;&gt;</code> - <code>resolve_for_handler(&amp;[String], &amp;Request, &amp;RequestData) -&gt; ResolvedDependencies</code>   - Calculates batched resolution order   - Resolves dependencies in parallel batches   - Caches singletons globally, per-request cacheables locally</p> <p><code>ResolvedDependencies</code> (resolved.rs): - Stores resolved values: <code>HashMap&lt;String, Arc&lt;dyn Any + Send + Sync&gt;&gt;</code> - Type-safe retrieval: <code>get&lt;T&gt;(&amp;str) -&gt; Option&lt;Arc&lt;T&gt;&gt;</code> - Cleanup task support for generator-pattern dependencies</p>"},{"location":"php-di-design/#key-differences-for-php","title":"Key Differences for PHP","text":"<p>Python Advantages: 1. Reflection: <code>inspect.signature()</code> provides full parameter type information 2. Event Loop: <code>asyncio</code> provides built-in async support 3. GIL: Single-threaded execution simplifies threading concerns</p> <p>PHP Challenges: 1. No built-in event loop: PHP is synchronous by nature 2. Thread-local storage: Zval is not Send/Sync (like Python's GIL) 3. Reflection API: PHP has <code>ReflectionFunction</code>/<code>ReflectionMethod</code> but type hints may be classes, not strings 4. Closure storage: Need to store PHP callables as <code>Zval</code> in thread-local registry</p>"},{"location":"php-di-design/#2-php-di-container-api","title":"2. PHP DI Container API","text":""},{"location":"php-di-design/#php-classes","title":"PHP Classes","text":"<p>DependencyContainer (packages/php/src/DI/DependencyContainer.php): <pre><code>&lt;?php\ndeclare(strict_types=1);\n\nnamespace Spikard\\DI;\n\nfinal class DependencyContainer\n{\n    /** @var array&lt;string, mixed&gt; */\n    private array $values = [];\n\n    /** @var array&lt;string, Provide&gt; */\n    private array $factories = [];\n\n    /** @var array&lt;string, mixed&gt; */\n    private array $singletonCache = [];\n\n    /**\n     * Register a singleton value dependency.\n     *\n     * @param string $key Unique dependency identifier\n     * @param mixed $value The singleton instance\n     */\n    public function singleton(string $key, mixed $value): self\n    {\n        $this-&gt;values[$key] = $value;\n        return $this;\n    }\n\n    /**\n     * Register a factory dependency.\n     *\n     * @param string $key Unique dependency identifier\n     * @param Provide $factory Factory wrapper with dependency metadata\n     */\n    public function factory(string $key, Provide $factory): self\n    {\n        $this-&gt;factories[$key] = $factory;\n        return $this;\n    }\n\n    /**\n     * Register a scoped dependency (per-request singleton).\n     *\n     * @param string $key Unique dependency identifier\n     * @param callable $factory Factory callable\n     * @param list&lt;string&gt; $dependsOn Dependencies this factory needs\n     */\n    public function scoped(string $key, callable $factory, array $dependsOn = []): self\n    {\n        $this-&gt;factories[$key] = new Provide(\n            factory: $factory,\n            dependsOn: $dependsOn,\n            cacheable: true,\n            singleton: false\n        );\n        return $this;\n    }\n\n    /**\n     * Convert to native array for Rust extraction.\n     *\n     * @internal Called by App::start()\n     */\n    public function toNative(): array\n    {\n        return [\n            'values' =&gt; $this-&gt;values,\n            'factories' =&gt; $this-&gt;factories,\n        ];\n    }\n}\n</code></pre></p> <p>Provide (packages/php/src/DI/Provide.php): <pre><code>&lt;?php\ndeclare(strict_types=1);\n\nnamespace Spikard\\DI;\n\n/**\n * Wrapper for factory dependencies with resolution metadata.\n *\n * Similar to Python's Provide class.\n */\nfinal class Provide\n{\n    public function __construct(\n        /** The factory callable */\n        public readonly mixed $factory,\n\n        /** Dependencies this factory requires (parameter names or class names) */\n        public readonly array $dependsOn = [],\n\n        /** Whether to cache within a single request */\n        public readonly bool $cacheable = false,\n\n        /** Whether to cache globally across all requests */\n        public readonly bool $singleton = false,\n    ) {\n        if (!is_callable($this-&gt;factory)) {\n            throw new \\InvalidArgumentException('Factory must be callable');\n        }\n    }\n\n    /**\n     * Create a factory dependency.\n     */\n    public static function factory(\n        callable $factory,\n        array $dependsOn = [],\n    ): self {\n        return new self($factory, $dependsOn, cacheable: false, singleton: false);\n    }\n\n    /**\n     * Create a scoped dependency (per-request singleton).\n     */\n    public static function scoped(\n        callable $factory,\n        array $dependsOn = [],\n    ): self {\n        return new self($factory, $dependsOn, cacheable: true, singleton: false);\n    }\n\n    /**\n     * Create a singleton dependency.\n     */\n    public static function singleton(\n        callable $factory,\n        array $dependsOn = [],\n    ): self {\n        return new self($factory, $dependsOn, cacheable: true, singleton: true);\n    }\n\n    /**\n     * Convert to associative array for Rust extraction.\n     *\n     * @internal\n     */\n    public function toArray(): array\n    {\n        return [\n            'factory' =&gt; $this-&gt;factory,\n            'depends_on' =&gt; $this-&gt;dependsOn,\n            'cacheable' =&gt; $this-&gt;cacheable,\n            'singleton' =&gt; $this-&gt;singleton,\n        ];\n    }\n}\n</code></pre></p>"},{"location":"php-di-design/#usage-examples","title":"Usage Examples","text":"<p>Basic Usage: <pre><code>&lt;?php\nuse Spikard\\App;\nuse Spikard\\DI\\DependencyContainer;\nuse Spikard\\DI\\Provide;\n\n$app = new App();\n\n$container = new DependencyContainer();\n\n// Singleton value\n$container-&gt;singleton('database_url', 'postgresql://localhost/mydb');\n\n// Factory dependency\n$container-&gt;factory('db', Provide::singleton(\n    factory: function (string $database_url): PDO {\n        return new PDO($database_url);\n    },\n    dependsOn: ['database_url']\n));\n\n// Scoped dependency (new instance per request)\n$container-&gt;scoped('request_id', function (): string {\n    return bin2hex(random_bytes(16));\n});\n\n$app-&gt;withDependencies($container);\n\n// Handler with dependency injection\n$app-&gt;addRoute('GET', '/users', function (PDO $db, string $request_id): array {\n    // $db and $request_id automatically injected\n    $stmt = $db-&gt;query('SELECT * FROM users');\n    return [\n        'request_id' =&gt; $request_id,\n        'users' =&gt; $stmt-&gt;fetchAll(),\n    ];\n});\n\n$app-&gt;start();\n</code></pre></p> <p>Advanced Usage with Type Hints: <pre><code>&lt;?php\ninterface LoggerInterface {\n    public function info(string $message): void;\n}\n\nclass FileLogger implements LoggerInterface {\n    public function __construct(private string $logPath) {}\n\n    public function info(string $message): void {\n        file_put_contents($this-&gt;logPath, $message . PHP_EOL, FILE_APPEND);\n    }\n}\n\n$container = new DependencyContainer();\n\n// Register by interface name\n$container-&gt;singleton('log_path', '/var/log/app.log');\n$container-&gt;factory(LoggerInterface::class, Provide::singleton(\n    factory: fn(string $log_path) =&gt; new FileLogger($log_path),\n    dependsOn: ['log_path']\n));\n\n// Handler with interface type hint\n$app-&gt;addRoute('POST', '/events', function (LoggerInterface $logger, array $body): void {\n    $logger-&gt;info('Event created: ' . json_encode($body));\n});\n</code></pre></p>"},{"location":"php-di-design/#3-rust-side-architecture","title":"3. Rust-Side Architecture","text":""},{"location":"php-di-design/#data-structures","title":"Data Structures","text":"<p>PhpValueDependency (crates/spikard-php/src/php/di.rs): <pre><code>/// Wrapper for PHP static value dependencies.\npub struct PhpValueDependency {\n    key: String,\n    /// Stored as Zval since ext-php-rs types aren't Send/Sync\n    value: ext_php_rs::types::Zval,\n}\n\nimpl PhpValueDependency {\n    pub fn new(key: String, value: ext_php_rs::types::Zval) -&gt; Self {\n        Self { key, value }\n    }\n}\n\nimpl Dependency for PhpValueDependency {\n    fn resolve(\n        &amp;self,\n        _request: &amp;Request&lt;()&gt;,\n        _request_data: &amp;RequestData,\n        _resolved: &amp;ResolvedDependencies,\n    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Arc&lt;dyn Any + Send + Sync&gt;, DependencyError&gt;&gt; + Send + '_&gt;&gt; {\n        // Clone the Zval for return\n        let value = self.value.shallow_clone();\n        Box::pin(async move {\n            Ok(Arc::new(value) as Arc&lt;dyn Any + Send + Sync&gt;)\n        })\n    }\n\n    fn key(&amp;self) -&gt; &amp;str { &amp;self.key }\n    fn depends_on(&amp;self) -&gt; Vec&lt;String&gt; { vec![] }\n    fn singleton(&amp;self) -&gt; bool { true }\n    fn cacheable(&amp;self) -&gt; bool { true }\n}\n</code></pre></p> <p>PhpFactoryDependency (crates/spikard-php/src/php/di.rs): <pre><code>/// Wrapper for PHP factory dependencies.\npub struct PhpFactoryDependency {\n    key: String,\n    /// Index into PHP_FACTORY_REGISTRY (thread-local)\n    factory_index: usize,\n    depends_on: Vec&lt;String&gt;,\n    cacheable: bool,\n    singleton: bool,\n}\n\n/// Thread-local registry for PHP factory callables.\n///\n/// Similar to PHP_HANDLER_REGISTRY, we store Zval instead of reconstructing\n/// ZendCallable because Zval can be stored in static but ZendCallable has\n/// a lifetime parameter.\nthread_local! {\n    static PHP_FACTORY_REGISTRY: std::cell::RefCell&lt;Vec&lt;ext_php_rs::types::Zval&gt;&gt;\n        = std::cell::RefCell::new(Vec::new());\n}\n\nimpl PhpFactoryDependency {\n    /// Register a factory callable and return its index.\n    pub fn register_from_zval(\n        key: String,\n        factory_zval: &amp;ext_php_rs::types::Zval,\n        depends_on: Vec&lt;String&gt;,\n        cacheable: bool,\n        singleton: bool,\n    ) -&gt; Result&lt;Self, String&gt; {\n        if !factory_zval.is_callable() {\n            return Err(format!(\"Factory for '{}' is not callable\", key));\n        }\n\n        let factory_index = PHP_FACTORY_REGISTRY.with(|registry| {\n            let mut registry = registry.borrow_mut();\n            let idx = registry.len();\n            registry.push(factory_zval.shallow_clone());\n            idx\n        });\n\n        Ok(Self {\n            key,\n            factory_index,\n            depends_on,\n            cacheable,\n            singleton,\n        })\n    }\n}\n\nimpl Dependency for PhpFactoryDependency {\n    fn resolve(\n        &amp;self,\n        _request: &amp;Request&lt;()&gt;,\n        request_data: &amp;RequestData,\n        resolved: &amp;ResolvedDependencies,\n    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Arc&lt;dyn Any + Send + Sync&gt;, DependencyError&gt;&gt; + Send + '_&gt;&gt; {\n        // All PHP invocation must happen synchronously before returning future\n        // to avoid capturing non-Send types across .await boundaries.\n        let result = invoke_php_factory(\n            self.factory_index,\n            &amp;self.key,\n            &amp;self.depends_on,\n            request_data,\n            resolved,\n        );\n\n        Box::pin(async move { result })\n    }\n\n    fn key(&amp;self) -&gt; &amp;str { &amp;self.key }\n    fn depends_on(&amp;self) -&gt; Vec&lt;String&gt; { self.depends_on.clone() }\n    fn singleton(&amp;self) -&gt; bool { self.singleton }\n    fn cacheable(&amp;self) -&gt; bool { self.cacheable }\n}\n\n/// Invoke a PHP factory and return the resolved value.\nfn invoke_php_factory(\n    factory_index: usize,\n    key: &amp;str,\n    depends_on: &amp;[String],\n    request_data: &amp;RequestData,\n    resolved: &amp;ResolvedDependencies,\n) -&gt; Result&lt;Arc&lt;dyn Any + Send + Sync&gt;, DependencyError&gt; {\n    PHP_FACTORY_REGISTRY.with(|registry| -&gt; Result&lt;_, DependencyError&gt; {\n        let registry = registry.borrow();\n        let factory_zval = registry\n            .get(factory_index)\n            .ok_or_else(|| DependencyError::ResolutionFailed {\n                message: format!(\"Factory '{}' not found in registry\", key),\n            })?;\n\n        // Reconstruct ZendCallable from stored Zval\n        let callable = ext_php_rs::types::ZendCallable::new(factory_zval)\n            .map_err(|e| DependencyError::ResolutionFailed {\n                message: format!(\"Failed to reconstruct PHP callable for '{}': {:?}\", key, e),\n            })?;\n\n        // Build arguments array: resolved dependencies needed by this factory\n        let mut args = Vec::new();\n        for dep_key in depends_on {\n            let dep_value = resolved\n                .get::&lt;ext_php_rs::types::Zval&gt;(dep_key)\n                .ok_or_else(|| DependencyError::ResolutionFailed {\n                    message: format!(\"Dependency '{}' not found when resolving '{}'\", dep_key, key),\n                })?;\n            args.push(&amp;**dep_value);\n        }\n\n        // Invoke factory\n        let result_zval = callable\n            .try_call(args)\n            .map_err(|e| DependencyError::ResolutionFailed {\n                message: format!(\"Factory '{}' failed: {:?}\", key, e),\n            })?;\n\n        Ok(Arc::new(result_zval) as Arc&lt;dyn Any + Send + Sync&gt;)\n    })\n}\n</code></pre></p>"},{"location":"php-di-design/#extraction-from-php","title":"Extraction from PHP","text":"<p>Extract DI Container (crates/spikard-php/src/php/start.rs - add after extract_lifecycle_hooks_from_php): <pre><code>/// Extract DependencyContainer from PHP DependencyContainer::toNative().\n///\n/// Expected structure:\n/// [\n///     'values' =&gt; ['key' =&gt; value, ...],\n///     'factories' =&gt; ['key' =&gt; Provide, ...],\n/// ]\nfn extract_dependency_container_from_php(\n    container_zval: &amp;Zval,\n) -&gt; Result&lt;spikard_core::di::DependencyContainer, String&gt; {\n    use spikard_core::di::DependencyContainer;\n\n    let container_array = container_zval\n        .array()\n        .ok_or_else(|| \"DI container must be an array\".to_string())?;\n\n    let mut di_container = DependencyContainer::new();\n\n    // Extract values (singleton dependencies)\n    if let Some(values_zval) = container_array.get(\"values\") {\n        if let Some(values_arr) = values_zval.array() {\n            for (key_zval, value_zval) in values_arr.iter() {\n                let key = match key_zval {\n                    ext_php_rs::types::ArrayKey::String(s) =&gt; s.to_string(),\n                    ext_php_rs::types::ArrayKey::Str(s) =&gt; s.to_string(),\n                    ext_php_rs::types::ArrayKey::Long(i) =&gt; i.to_string(),\n                };\n\n                let value_dep = crate::php::di::PhpValueDependency::new(\n                    key.clone(),\n                    value_zval.shallow_clone(),\n                );\n\n                di_container\n                    .register(key, Arc::new(value_dep))\n                    .map_err(|e| format!(\"Failed to register value dependency: {}\", e))?;\n            }\n        }\n    }\n\n    // Extract factories\n    if let Some(factories_zval) = container_array.get(\"factories\") {\n        if let Some(factories_arr) = factories_zval.array() {\n            for (key_zval, provide_zval) in factories_arr.iter() {\n                let key = match key_zval {\n                    ext_php_rs::types::ArrayKey::String(s) =&gt; s.to_string(),\n                    ext_php_rs::types::ArrayKey::Str(s) =&gt; s.to_string(),\n                    ext_php_rs::types::ArrayKey::Long(i) =&gt; i.to_string(),\n                };\n\n                // Extract Provide fields\n                let provide_arr = provide_zval\n                    .array()\n                    .ok_or_else(|| format!(\"Provide for '{}' must be an array\", key))?;\n\n                let factory_callable = provide_arr\n                    .get(\"factory\")\n                    .ok_or_else(|| format!(\"Provide for '{}' missing 'factory' field\", key))?;\n\n                let depends_on: Vec&lt;String&gt; = provide_arr\n                    .get(\"depends_on\")\n                    .and_then(|v| v.array())\n                    .map(|arr| {\n                        arr.iter()\n                            .filter_map(|(_, v)| v.string().map(|s| s.to_string()))\n                            .collect()\n                    })\n                    .unwrap_or_default();\n\n                let cacheable = provide_arr\n                    .get(\"cacheable\")\n                    .and_then(|v| v.bool())\n                    .unwrap_or(false);\n\n                let singleton = provide_arr\n                    .get(\"singleton\")\n                    .and_then(|v| v.bool())\n                    .unwrap_or(false);\n\n                let factory_dep = crate::php::di::PhpFactoryDependency::register_from_zval(\n                    key.clone(),\n                    factory_callable,\n                    depends_on,\n                    cacheable,\n                    singleton,\n                )?;\n\n                di_container\n                    .register(key, Arc::new(factory_dep))\n                    .map_err(|e| format!(\"Failed to register factory dependency: {}\", e))?;\n            }\n        }\n    }\n\n    Ok(di_container)\n}\n</code></pre></p> <p>Update spikard_start_server_impl (crates/spikard-php/src/php/start.rs:525): <pre><code>pub fn spikard_start_server_impl(\n    routes_zval: &amp;Zval,\n    config: &amp;Zval,\n    hooks: &amp;Zval,\n    dependencies: &amp;Zval, // NEW PARAMETER\n) -&gt; PhpResult&lt;u64&gt; {\n    let mut server_config = extract_server_config_from_php(config)\n        .map_err(|e| PhpException::default(format!(\"Invalid server config: {}\", e)))?;\n\n    // Extract lifecycle hooks\n    server_config.lifecycle_hooks = extract_lifecycle_hooks_from_php(hooks)\n        .map_err(|e| PhpException::default(format!(\"Invalid lifecycle hooks: {}\", e)))?;\n\n    // Extract DI container (NEW)\n    if !dependencies.is_null() {\n        let di_container = extract_dependency_container_from_php(dependencies)\n            .map_err(|e| PhpException::default(format!(\"Invalid DI container: {}\", e)))?;\n        server_config.di_container = Some(Arc::new(di_container));\n    }\n\n    // ... rest of function\n}\n</code></pre></p>"},{"location":"php-di-design/#resolution-algorithm","title":"Resolution Algorithm","text":"<p>The core resolution happens in <code>spikard_core::di::DependencyContainer::resolve_for_handler</code>:</p> <ol> <li>Calculate Batches: Topological sort creates batches of independent dependencies</li> <li>Sequential Batch Processing: Each batch processed in order</li> <li>Within-Batch Sequential Resolution: Dependencies within a batch resolved sequentially (for deterministic cleanup order)</li> <li>Caching:</li> <li>Check singleton cache first (global)</li> <li>Check request cache (per-request)</li> <li>Resolve and store in appropriate cache</li> </ol> <p>For PHP, the <code>PhpFactoryDependency::resolve()</code> method: 1. Synchronously invokes <code>invoke_php_factory()</code> before returning future 2. Retrieves factory callable from thread-local registry 3. Builds argument array from resolved dependencies 4. Calls PHP factory with arguments 5. Returns result wrapped in <code>Arc&lt;dyn Any&gt;</code></p>"},{"location":"php-di-design/#4-handler-parameter-injection","title":"4. Handler Parameter Injection","text":""},{"location":"php-di-design/#detection-method","title":"Detection Method","text":"<p>Option A: Type-based injection (RECOMMENDED)</p> <p>Use PHP reflection to extract parameter types and match against registered dependencies:</p> <pre><code>// In App::addRoute()\n$reflection = new \\ReflectionFunction($handler);\n$handler_dependencies = [];\n\nforeach ($reflection-&gt;getParameters() as $param) {\n    $paramType = $param-&gt;getType();\n\n    if ($paramType === null) {\n        continue; // No type hint\n    }\n\n    // Get the type name (could be class name or built-in type)\n    $typeName = $paramType instanceof \\ReflectionNamedType\n        ? $paramType-&gt;getName()\n        : null;\n\n    if ($typeName === null) {\n        continue;\n    }\n\n    // Check if registered by parameter name\n    if ($this-&gt;container-&gt;has($param-&gt;getName())) {\n        $handler_dependencies[] = $param-&gt;getName();\n    }\n    // Check if registered by type name (class name)\n    elseif ($this-&gt;container-&gt;has($typeName)) {\n        $handler_dependencies[] = $typeName;\n    }\n}\n</code></pre> <p>Option B: Explicit dependency declaration (ALTERNATIVE)</p> <pre><code>#[\\Attribute]\nclass Inject {\n    public function __construct(public array $dependencies) {}\n}\n\n#[Inject(['database', 'logger'])]\n$app-&gt;addRoute('GET', '/users', function(PDO $database, LoggerInterface $logger) {\n    // ...\n});\n</code></pre>"},{"location":"php-di-design/#injection-mechanism","title":"Injection Mechanism","text":"<p>Rust-Side Handler Invocation (crates/spikard-php/src/php/handler.rs - modify invoke_php_handler):</p> <pre><code>fn invoke_php_handler(\n    handler_index: usize,\n    handler_name: &amp;str,\n    request_data: &amp;RequestData,\n) -&gt; HandlerResult {\n    // Extract dependencies from request_data if available\n    let resolved_deps = request_data\n        .dependencies\n        .as_ref()\n        .map(|deps| deps.clone());\n\n    // Build PhpRequest\n    let php_request = crate::php::request::PhpRequest::from_request_data(request_data);\n    let request_zval = php_request.into_zval(false).map_err(|e| {\n        (StatusCode::INTERNAL_SERVER_ERROR, format!(\"Failed to convert request: {:?}\", e))\n    })?;\n\n    PHP_HANDLER_REGISTRY.with(|registry| -&gt; Result&lt;_, (StatusCode, String)&gt; {\n        let registry = registry.borrow();\n        let callable_zval = registry.get(handler_index).ok_or_else(|| {\n            (StatusCode::INTERNAL_SERVER_ERROR, format!(\"Handler not found: {}\", handler_index))\n        })?;\n\n        let callable = ZendCallable::new(callable_zval).map_err(|e| {\n            (StatusCode::INTERNAL_SERVER_ERROR, format!(\"Failed to reconstruct callable: {:?}\", e))\n        })?;\n\n        // Build arguments: request + resolved dependencies\n        let mut args = vec![&amp;request_zval];\n\n        if let Some(deps) = resolved_deps {\n            // Extract handler dependencies from RequestData\n            // For each dependency key, get the resolved Zval and add to args\n            // This requires extending RequestData to carry handler_dependencies\n            // and the resolved values\n\n            // TODO: Implement dependency argument passing\n        }\n\n        let response_zval = callable.try_call(args).map_err(|e| {\n            (StatusCode::INTERNAL_SERVER_ERROR, format!(\"Handler '{}' failed: {:?}\", handler_name, e))\n        })?;\n\n        crate::php::server::interpret_php_response(&amp;response_zval, handler_name)\n    })\n}\n</code></pre> <p>Alternative: Pass Dependencies as Associative Array</p> <p>Instead of positional arguments, pass dependencies as an associative array in the request:</p> <pre><code>// Build dependencies array\nlet deps_zval = if let Some(resolved) = resolved_deps {\n    let mut deps_array = ext_php_rs::types::ZendHashTable::new();\n    for (key, value) in resolved.all() {\n        if let Some(zval) = value.downcast_ref::&lt;ext_php_rs::types::Zval&gt;() {\n            deps_array.insert(key, zval.shallow_clone());\n        }\n    }\n    deps_array.into_zval(false)?\n} else {\n    ext_php_rs::types::Zval::new()\n};\n\n// Add to PhpRequest structure\nlet php_request = crate::php::request::PhpRequest {\n    // ... existing fields\n    dependencies: deps_zval,\n};\n</code></pre> <p>Then in PHP handler: <pre><code>function handler(Request $request): Response {\n    $db = $request-&gt;dependency('database');\n    // ...\n}\n</code></pre></p> <p>RECOMMENDED: Match by Parameter Name/Type</p> <p>The cleanest approach is to match handler parameters by name/type and inject directly:</p> <pre><code>// Handler signature\nfunction handler(PDO $db, LoggerInterface $logger, Request $request): array\n\n// PHP reflection extracts:\n// - Parameter 0: name='db', type='PDO'\n// - Parameter 1: name='logger', type='LoggerInterface'\n// - Parameter 2: name='request', type='Request'\n\n// Store in route metadata:\nhandler_dependencies = ['PDO', 'LoggerInterface']\n\n// Rust resolves these dependencies and passes them positionally\n</code></pre> <p>However, this requires coordinating parameter order between PHP reflection analysis and Rust invocation. Easier approach: Pass dependencies as an extended Request object:</p> <pre><code>class Request {\n    // ... existing fields\n\n    /** @var array&lt;string, mixed&gt; */\n    private array $dependencies = [];\n\n    public function dependency(string $key): mixed {\n        return $this-&gt;dependencies[$key] ?? throw new RuntimeException(\"Dependency '{$key}' not found\");\n    }\n}\n</code></pre>"},{"location":"php-di-design/#5-implementation-plan","title":"5. Implementation Plan","text":""},{"location":"php-di-design/#files-to-create","title":"Files to Create","text":"<ol> <li>crates/spikard-php/src/php/di.rs</li> <li><code>PhpValueDependency</code> struct and <code>Dependency</code> impl</li> <li><code>PhpFactoryDependency</code> struct and <code>Dependency</code> impl</li> <li><code>PHP_FACTORY_REGISTRY</code> thread-local</li> <li> <p><code>invoke_php_factory()</code> helper function</p> </li> <li> <p>packages/php/src/DI/Provide.php</p> </li> <li><code>Provide</code> class with factory metadata</li> <li>Static factory methods: <code>factory()</code>, <code>scoped()</code>, <code>singleton()</code></li> <li><code>toArray()</code> for Rust extraction</li> </ol>"},{"location":"php-di-design/#files-to-modify","title":"Files to Modify","text":"<ol> <li>crates/spikard-php/src/php/start.rs</li> <li>Add <code>extract_dependency_container_from_php()</code> function</li> <li>Modify <code>spikard_start_server_impl()</code> to accept <code>dependencies</code> parameter</li> <li>Set <code>server_config.di_container = Some(Arc::new(container))</code></li> <li> <p>Update line 431: Remove <code>di_container: None</code> stub</p> </li> <li> <p>crates/spikard-php/src/php/handler.rs</p> </li> <li>Modify <code>invoke_php_handler()</code> to extract and pass dependencies</li> <li> <p>Add dependency injection logic based on <code>RequestData.dependencies</code></p> </li> <li> <p>crates/spikard-php/src/php/mod.rs</p> </li> <li> <p>Add <code>pub mod di;</code> declaration</p> </li> <li> <p>packages/php/src/DI/DependencyContainer.php</p> </li> <li>Complete implementation with <code>singleton()</code>, <code>factory()</code>, <code>scoped()</code> methods</li> <li> <p>Add <code>toNative()</code> method for Rust extraction</p> </li> <li> <p>packages/php/src/App.php</p> </li> <li>Add <code>withDependencies(DependencyContainer $container): self</code> method</li> <li>Store container in private property</li> <li>Pass container to <code>start()</code> method</li> <li>Extract handler dependencies via reflection</li> <li> <p>Store in route metadata</p> </li> <li> <p>packages/php/src/Http/Request.php (create if doesn't exist)</p> </li> <li>Add <code>private array $dependencies</code> field</li> <li>Add <code>dependency(string $key): mixed</code> method</li> <li>Allow Rust to populate dependencies when constructing Request</li> </ol>"},{"location":"php-di-design/#step-by-step-implementation","title":"Step-by-Step Implementation","text":""},{"location":"php-di-design/#phase-1-basic-value-dependencies","title":"Phase 1: Basic Value Dependencies","text":"<ol> <li>Create <code>crates/spikard-php/src/php/di.rs</code> with <code>PhpValueDependency</code></li> <li>Implement <code>extract_dependency_container_from_php()</code> for values only</li> <li>Update <code>spikard_start_server_impl()</code> to extract and register values</li> <li>Test with simple singleton values</li> </ol>"},{"location":"php-di-design/#phase-2-factory-dependencies","title":"Phase 2: Factory Dependencies","text":"<ol> <li>Add <code>PhpFactoryDependency</code> to <code>di.rs</code></li> <li>Implement <code>PHP_FACTORY_REGISTRY</code> thread-local</li> <li>Implement <code>invoke_php_factory()</code> with dependency resolution</li> <li>Update extraction to handle factories</li> <li>Test with factories that have dependencies</li> </ol>"},{"location":"php-di-design/#phase-3-handler-parameter-detection","title":"Phase 3: Handler Parameter Detection","text":"<ol> <li>Update <code>packages/php/src/App.php::addRoute()</code></li> <li>Use <code>ReflectionFunction</code> to extract parameter types</li> <li>Match against registered dependency keys</li> <li>Store in route metadata</li> <li>Test that handler dependencies are detected correctly</li> </ol>"},{"location":"php-di-design/#phase-4-handler-injection","title":"Phase 4: Handler Injection","text":"<ol> <li>Extend <code>RequestData</code> to carry resolved dependencies</li> <li>Modify <code>invoke_php_handler()</code> to pass dependencies to PHP</li> <li>Decide on injection mechanism (positional args vs Request object)</li> <li>Implement chosen mechanism</li> <li>Test end-to-end dependency injection</li> </ol>"},{"location":"php-di-design/#phase-5-advanced-features","title":"Phase 5: Advanced Features","text":"<ol> <li>Implement cleanup tasks (if needed for generator pattern)</li> <li>Add error handling for missing dependencies</li> <li>Add error handling for type mismatches</li> <li>Performance optimization: cache reflection results</li> <li>Add comprehensive tests</li> </ol>"},{"location":"php-di-design/#6-code-examples","title":"6. Code Examples","text":""},{"location":"php-di-design/#rust-implementation-sketch","title":"Rust Implementation Sketch","text":"<p>crates/spikard-php/src/php/di.rs (PhpValueDependency): <pre><code>use ext_php_rs::types::Zval;\nuse http::Request;\nuse spikard_core::di::{Dependency, DependencyError, ResolvedDependencies};\nuse spikard_core::request_data::RequestData;\nuse std::any::Any;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::sync::Arc;\n\npub struct PhpValueDependency {\n    key: String,\n    value: Zval,\n}\n\nimpl PhpValueDependency {\n    pub fn new(key: String, value: Zval) -&gt; Self {\n        Self { key, value }\n    }\n}\n\nimpl Dependency for PhpValueDependency {\n    fn resolve(\n        &amp;self,\n        _request: &amp;Request&lt;()&gt;,\n        _request_data: &amp;RequestData,\n        _resolved: &amp;ResolvedDependencies,\n    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Arc&lt;dyn Any + Send + Sync&gt;, DependencyError&gt;&gt; + Send + '_&gt;&gt; {\n        let value = self.value.shallow_clone();\n        Box::pin(async move {\n            Ok(Arc::new(value) as Arc&lt;dyn Any + Send + Sync&gt;)\n        })\n    }\n\n    fn key(&amp;self) -&gt; &amp;str {\n        &amp;self.key\n    }\n\n    fn depends_on(&amp;self) -&gt; Vec&lt;String&gt; {\n        vec![]\n    }\n\n    fn singleton(&amp;self) -&gt; bool {\n        true\n    }\n\n    fn cacheable(&amp;self) -&gt; bool {\n        true\n    }\n}\n</code></pre></p> <p>crates/spikard-php/src/php/di.rs (PhpFactoryDependency - abbreviated): <pre><code>pub struct PhpFactoryDependency {\n    key: String,\n    factory_index: usize,\n    depends_on: Vec&lt;String&gt;,\n    cacheable: bool,\n    singleton: bool,\n}\n\nthread_local! {\n    static PHP_FACTORY_REGISTRY: std::cell::RefCell&lt;Vec&lt;Zval&gt;&gt; = std::cell::RefCell::new(Vec::new());\n}\n\nimpl PhpFactoryDependency {\n    pub fn register_from_zval(\n        key: String,\n        factory_zval: &amp;Zval,\n        depends_on: Vec&lt;String&gt;,\n        cacheable: bool,\n        singleton: bool,\n    ) -&gt; Result&lt;Self, String&gt; {\n        // Validate callable\n        // Register in thread-local\n        // Return Self with index\n    }\n}\n\nimpl Dependency for PhpFactoryDependency {\n    fn resolve(...) -&gt; Pin&lt;Box&lt;...&gt;&gt; {\n        let result = invoke_php_factory(\n            self.factory_index,\n            &amp;self.key,\n            &amp;self.depends_on,\n            request_data,\n            resolved,\n        );\n        Box::pin(async move { result })\n    }\n\n    // ... other trait methods\n}\n\nfn invoke_php_factory(\n    factory_index: usize,\n    key: &amp;str,\n    depends_on: &amp;[String],\n    _request_data: &amp;RequestData,\n    resolved: &amp;ResolvedDependencies,\n) -&gt; Result&lt;Arc&lt;dyn Any + Send + Sync&gt;, DependencyError&gt; {\n    PHP_FACTORY_REGISTRY.with(|registry| {\n        // Get factory callable\n        // Build args from resolved dependencies\n        // Invoke callable\n        // Return result\n    })\n}\n</code></pre></p>"},{"location":"php-di-design/#php-implementation-sketch","title":"PHP Implementation Sketch","text":"<p>packages/php/src/DI/Provide.php: <pre><code>&lt;?php\ndeclare(strict_types=1);\n\nnamespace Spikard\\DI;\n\nfinal class Provide\n{\n    public function __construct(\n        public readonly mixed $factory,\n        public readonly array $dependsOn = [],\n        public readonly bool $cacheable = false,\n        public readonly bool $singleton = false,\n    ) {\n        if (!is_callable($this-&gt;factory)) {\n            throw new \\InvalidArgumentException('Factory must be callable');\n        }\n    }\n\n    public static function factory(callable $factory, array $dependsOn = []): self\n    {\n        return new self($factory, $dependsOn, cacheable: false, singleton: false);\n    }\n\n    public static function scoped(callable $factory, array $dependsOn = []): self\n    {\n        return new self($factory, $dependsOn, cacheable: true, singleton: false);\n    }\n\n    public static function singleton(callable $factory, array $dependsOn = []): self\n    {\n        return new self($factory, $dependsOn, cacheable: true, singleton: true);\n    }\n\n    /** @return array{factory: callable, depends_on: list&lt;string&gt;, cacheable: bool, singleton: bool} */\n    public function toArray(): array\n    {\n        return [\n            'factory' =&gt; $this-&gt;factory,\n            'depends_on' =&gt; $this-&gt;dependsOn,\n            'cacheable' =&gt; $this-&gt;cacheable,\n            'singleton' =&gt; $this-&gt;singleton,\n        ];\n    }\n}\n</code></pre></p> <p>packages/php/src/DI/DependencyContainer.php: <pre><code>&lt;?php\ndeclare(strict_types=1);\n\nnamespace Spikard\\DI;\n\nfinal class DependencyContainer\n{\n    /** @var array&lt;string, mixed&gt; */\n    private array $values = [];\n\n    /** @var array&lt;string, Provide&gt; */\n    private array $factories = [];\n\n    public function singleton(string $key, mixed $value): self\n    {\n        $this-&gt;values[$key] = $value;\n        return $this;\n    }\n\n    public function factory(string $key, Provide $factory): self\n    {\n        $this-&gt;factories[$key] = $factory;\n        return $this;\n    }\n\n    public function scoped(string $key, callable $factory, array $dependsOn = []): self\n    {\n        return $this-&gt;factory($key, Provide::scoped($factory, $dependsOn));\n    }\n\n    public function has(string $key): bool\n    {\n        return isset($this-&gt;values[$key]) || isset($this-&gt;factories[$key]);\n    }\n\n    /**\n     * Convert to array for Rust extraction.\n     *\n     * @return array{values: array&lt;string, mixed&gt;, factories: array&lt;string, array&gt;}\n     */\n    public function toNative(): array\n    {\n        $factories = [];\n        foreach ($this-&gt;factories as $key =&gt; $provide) {\n            $factories[$key] = $provide-&gt;toArray();\n        }\n\n        return [\n            'values' =&gt; $this-&gt;values,\n            'factories' =&gt; $factories,\n        ];\n    }\n}\n</code></pre></p> <p>packages/php/src/App.php (withDependencies method): <pre><code>private ?DependencyContainer $container = null;\n\npublic function withDependencies(DependencyContainer $container): self\n{\n    $this-&gt;container = $container;\n    return $this;\n}\n\npublic function addRoute(string $method, string $path, callable $handler): void\n{\n    // Existing parameter extraction...\n\n    // NEW: Extract handler dependencies via reflection\n    $handler_dependencies = [];\n\n    if ($this-&gt;container !== null) {\n        $reflection = new \\ReflectionFunction($handler);\n\n        foreach ($reflection-&gt;getParameters() as $param) {\n            // Skip standard request parameters\n            if ($param-&gt;getName() === 'request' || $param-&gt;getName() === 'response') {\n                continue;\n            }\n\n            $paramType = $param-&gt;getType();\n            if ($paramType instanceof \\ReflectionNamedType) {\n                $typeName = $paramType-&gt;getName();\n\n                // Check by parameter name\n                if ($this-&gt;container-&gt;has($param-&gt;getName())) {\n                    $handler_dependencies[] = $param-&gt;getName();\n                }\n                // Check by type name (class)\n                elseif ($this-&gt;container-&gt;has($typeName)) {\n                    $handler_dependencies[] = $typeName;\n                }\n            }\n        }\n    }\n\n    // Store in route metadata\n    $route = [\n        'method' =&gt; $method,\n        'path' =&gt; $path,\n        'handler' =&gt; $handler,\n        'handler_name' =&gt; $this-&gt;getHandlerName($handler),\n        'handler_dependencies' =&gt; $handler_dependencies,\n        // ... other fields\n    ];\n\n    $this-&gt;routes[] = $route;\n}\n\npublic function start(ServerConfig $config): void\n{\n    $dependencies_native = $this-&gt;container?-&gt;toNative() ?? null;\n\n    spikard_start_server(\n        routes: $this-&gt;routesToNative(),\n        config: $config-&gt;toNative(),\n        hooks: $this-&gt;hooksToNative(),\n        dependencies: $dependencies_native, // NEW PARAMETER\n    );\n}\n</code></pre></p>"},{"location":"php-di-design/#7-edge-cases-testing","title":"7. Edge Cases &amp; Testing","text":""},{"location":"php-di-design/#edge-cases","title":"Edge Cases","text":"<ol> <li>Missing Dependency:</li> <li>Handler requires dependency that isn't registered</li> <li>Error: Return 500 with descriptive error message</li> <li> <p>Detection: During route registration or first request</p> </li> <li> <p>Type Mismatch:</p> </li> <li>Handler expects <code>PDO</code>, factory returns <code>string</code></li> <li>Error: PHP will throw TypeError when calling handler</li> <li> <p>Prevention: Validate types at registration time (optional strict mode)</p> </li> <li> <p>Circular Dependencies:</p> </li> <li>A depends on B, B depends on A</li> <li>Error: Detected by <code>DependencyGraph::add_dependency()</code></li> <li> <p>Response: Error during server startup, not runtime</p> </li> <li> <p>Factory Throws Exception:</p> </li> <li>PHP factory callable throws exception during resolution</li> <li>Error: Convert to <code>DependencyError::ResolutionFailed</code></li> <li> <p>Response: Return 500, log error</p> </li> <li> <p>Null Return from Factory:</p> </li> <li>Factory returns null instead of expected type</li> <li> <p>Handling: Allow null if parameter is nullable, error otherwise</p> </li> <li> <p>Multiple Type Candidates:</p> </li> <li>Handler has parameter <code>LoggerInterface $logger</code> but multiple implementations registered</li> <li>Resolution: Match by parameter name first, then by type</li> <li>Recommendation: Use explicit naming for interfaces</li> </ol>"},{"location":"php-di-design/#testing-strategy","title":"Testing Strategy","text":"<p>Unit Tests (Rust): <pre><code>#[test]\nfn test_php_value_dependency() {\n    // Create PhpValueDependency\n    // Resolve it\n    // Assert value is correct\n}\n\n#[test]\nfn test_php_factory_dependency() {\n    // Register factory in PHP_FACTORY_REGISTRY\n    // Create PhpFactoryDependency\n    // Resolve with dependencies\n    // Assert factory was called with correct args\n}\n\n#[test]\nfn test_extract_container_values_only() {\n    // Create PHP array with values\n    // Call extract_dependency_container_from_php\n    // Assert container has correct dependencies\n}\n\n#[test]\nfn test_extract_container_factories() {\n    // Create PHP array with factories\n    // Extract container\n    // Assert factories registered correctly\n}\n</code></pre></p> <p>Integration Tests (PHP): <pre><code>function test_singleton_value_injection(): void\n{\n    $app = new App();\n    $container = new DependencyContainer();\n\n    $container-&gt;singleton('app_name', 'TestApp');\n    $app-&gt;withDependencies($container);\n\n    $called = false;\n    $app-&gt;addRoute('GET', '/test', function (string $app_name) use (&amp;$called) {\n        $called = true;\n        assert($app_name === 'TestApp');\n        return ['name' =&gt; $app_name];\n    });\n\n    $client = $app-&gt;testClient();\n    $response = $client-&gt;get('/test');\n\n    assert($called === true);\n    assert($response-&gt;json() === ['name' =&gt; 'TestApp']);\n}\n\nfunction test_factory_dependency(): void\n{\n    $app = new App();\n    $container = new DependencyContainer();\n\n    $container-&gt;singleton('config', ['db_host' =&gt; 'localhost']);\n    $container-&gt;factory('database', Provide::singleton(\n        factory: function (array $config): PDO {\n            return new PDO(\"sqlite::memory:\");\n        },\n        dependsOn: ['config']\n    ));\n\n    $app-&gt;withDependencies($container);\n\n    $app-&gt;addRoute('GET', '/users', function (PDO $database): array {\n        $stmt = $database-&gt;query('SELECT 1');\n        return ['result' =&gt; $stmt-&gt;fetch()];\n    });\n\n    $client = $app-&gt;testClient();\n    $response = $client-&gt;get('/users');\n\n    assert($response-&gt;statusCode() === 200);\n}\n\nfunction test_scoped_dependency(): void\n{\n    $counter = 0;\n\n    $app = new App();\n    $container = new DependencyContainer();\n\n    $container-&gt;scoped('request_id', function () use (&amp;$counter): string {\n        return 'request-' . ($counter++);\n    });\n\n    $app-&gt;withDependencies($container);\n\n    $app-&gt;addRoute('GET', '/id', function (string $request_id): array {\n        return ['id' =&gt; $request_id];\n    });\n\n    $client = $app-&gt;testClient();\n\n    $response1 = $client-&gt;get('/id');\n    $response2 = $client-&gt;get('/id');\n\n    // Different requests get different IDs (scoped, not singleton)\n    assert($response1-&gt;json()['id'] !== $response2-&gt;json()['id']);\n}\n</code></pre></p>"},{"location":"php-di-design/#8-migration-path","title":"8. Migration Path","text":""},{"location":"php-di-design/#backward-compatibility","title":"Backward Compatibility","text":"<p>Existing handlers without DI continue to work: <pre><code>// Before (still works)\n$app-&gt;addRoute('GET', '/hello', function (): array {\n    return ['message' =&gt; 'Hello'];\n});\n\n// After (DI optional)\n$container = new DependencyContainer();\n$container-&gt;singleton('greeting', 'Hello');\n$app-&gt;withDependencies($container);\n\n$app-&gt;addRoute('GET', '/hello', function (string $greeting): array {\n    return ['message' =&gt; $greeting];\n});\n</code></pre></p>"},{"location":"php-di-design/#gradual-adoption","title":"Gradual Adoption","text":"<ol> <li>Phase 1: Add <code>withDependencies()</code> method, no-op if not called</li> <li>Phase 2: Implement value dependencies (singletons)</li> <li>Phase 3: Add factory dependencies</li> <li>Phase 4: Optimize performance and add advanced features</li> </ol>"},{"location":"php-di-design/#documentation-requirements","title":"Documentation Requirements","text":"<ol> <li>Basic Guide: Simple examples of value and factory dependencies</li> <li>Advanced Guide: Scoped dependencies, cleanup tasks, best practices</li> <li>Migration Guide: How to refactor existing handlers to use DI</li> <li>API Reference: Complete API documentation for all DI classes</li> </ol>"},{"location":"php-di-design/#summary","title":"Summary","text":"<p>This design provides a complete, production-ready DI system for PHP bindings that:</p> <ol> <li>Matches Python/Node/Ruby patterns: Uses the same core <code>Dependency</code> trait and <code>DependencyContainer</code></li> <li>Leverages existing infrastructure: Builds on <code>spikard_core::di</code> without duplication</li> <li>Handles PHP's constraints: Thread-local storage for Zval, synchronous invocation</li> <li>Supports all dependency types: Values, factories, scoped, singletons</li> <li>Provides clean PHP API: Intuitive API similar to other DI frameworks</li> <li>Ensures type safety: Reflection-based parameter matching with type hints</li> <li>Maintains backward compatibility: Existing handlers work unchanged</li> <li>Delivers good performance: Efficient caching, minimal overhead</li> </ol> <p>Key Challenges Addressed: - \u2705 Zval thread-local storage (like <code>PHP_HANDLER_REGISTRY</code>) - \u2705 Type-based and name-based dependency resolution - \u2705 Synchronous factory invocation (no async event loop needed) - \u2705 Clean extraction from PHP to Rust - \u2705 Proper error handling and validation</p> <p>Next Steps: 1. Create <code>crates/spikard-php/src/php/di.rs</code> with value and factory implementations 2. Update <code>start.rs</code> to extract and register dependencies 3. Implement PHP API classes (<code>Provide</code>, <code>DependencyContainer</code>) 4. Add handler parameter detection in <code>App::addRoute()</code> 5. Test thoroughly with integration tests</p>"},{"location":"adr/","title":"Architecture Decision Records","text":"<p>This folder captures concise ADRs for Spikard. Each record follows:</p> <ul> <li>Status: Proposed | Accepted | Superseded | Deprecated</li> <li>Context: Why the decision is needed.</li> <li>Decision: The choice we made.</li> <li>Consequences: Effects, trade-offs, and follow-ups.</li> <li>References: Links to code, tests, or related ADRs.</li> </ul> <p>File naming: <code>000N-title.md</code> with incremental numbers. Keep the set small and current\u2014supersede or prune ADRs that no longer match the code. Use <code>TEMPLATE.md</code> when adding a new record.</p>"},{"location":"adr/0001-architecture-and-principles/","title":"ADR 0001: Architecture and Principles","text":"<p>Status: Accepted Date: 2025-11-20</p>"},{"location":"adr/0001-architecture-and-principles/#context","title":"Context","text":"<p>Spikard is a Rust-first web toolkit that ships comparable APIs across Python, Node/Bun, Ruby, PHP, and WebAssembly. We need a durable statement of principles and a concise architecture map that matches the current codebase and bindings.</p>"},{"location":"adr/0001-architecture-and-principles/#decision","title":"Decision","text":"<ul> <li>Rust core owns correctness and performance: HTTP parsing, routing, validation, middleware, streaming, SSE, and WebSockets live in <code>crates/spikard-http</code> with shared types in <code>crates/spikard-core</code>.</li> <li>Bindings surface idiomatic APIs: PyO3 (<code>crates/spikard-py</code>), napi-rs (<code>crates/spikard-node</code>), Magnus (<code>crates/spikard-rb</code>), ext-php-rs (<code>crates/spikard-php</code>), and wasm-bindgen (<code>crates/spikard-wasm</code>) expose the same behaviors with language-specific ergonomics (decorators/blocks/functions).</li> <li>Spec- and fixture-driven: <code>testing_data/</code> is the canonical contract; fixtures, schemas, and generators drive the HTTP runtime, bindings, and e2e suites.</li> <li>Code generation is first-class: <code>crates/spikard-cli</code> and <code>crates/spikard-codegen</code> generate routes/tests from OpenAPI and AsyncAPI; JSON-RPC and protobuf are planned.</li> <li>Simplicity over reinvention: prefer standards (IETF drafts, RFC 9457), reuse existing crates (hyper/axum/tower/jsonschema), and keep feature parity instead of per-language divergence.</li> </ul>"},{"location":"adr/0001-architecture-and-principles/#consequences","title":"Consequences","text":"<ul> <li>Performance-sensitive paths stay centralized in Rust; bindings should avoid reimplementing parsing or validation.</li> <li>API additions must be reflected across bindings and routed through shared configs/types.</li> <li>New features should arrive with fixtures in <code>testing_data/</code>, codegen coverage, and e2e tests for every supported language.</li> <li>ADRs and docs must be kept in lockstep with the Rust runtime and bindings.</li> </ul>"},{"location":"adr/0001-architecture-and-principles/#references","title":"References","text":"<ul> <li>Runtime: <code>crates/spikard-http</code>, <code>crates/spikard-core</code></li> <li>Bindings: <code>crates/spikard-py</code>, <code>crates/spikard-node</code>, <code>crates/spikard-rb</code>, <code>crates/spikard-php</code>, <code>crates/spikard-wasm</code></li> <li>Fixtures: <code>testing_data/</code></li> <li>Codegen/CLI: <code>crates/spikard-cli</code>, <code>crates/spikard-codegen</code></li> </ul>"},{"location":"adr/0002-runtime-and-middleware/","title":"ADR 0002: HTTP Runtime and Middleware Pipeline","text":"<p>Status: Accepted Date: 2025-11-20</p>"},{"location":"adr/0002-runtime-and-middleware/#context","title":"Context","text":"<p>Spikard\u2019s runtime must provide consistent HTTP behavior\u2014routing, validation, middleware, and lifecycle hooks\u2014across all bindings while prioritizing performance and standards compliance.</p>"},{"location":"adr/0002-runtime-and-middleware/#decision","title":"Decision","text":"<ul> <li>Runtime stack: <code>crates/spikard-http</code> builds on tokio + hyper + axum + tower. Routing uses axum-style patterns (e.g., <code>/users/{id}</code>) with typed parameter extraction for strings, numbers, UUIDs, dates, and booleans.</li> <li>Middleware order (in Rust):</li> <li>Request ID (configurable header + UUID)</li> <li>Timeouts</li> <li>Rate limiting</li> <li>Body size limits</li> <li>Compression (gzip/brotli)</li> <li>Static files (optional)</li> <li>CORS</li> <li>Handler execution</li> <li>Lifecycle hooks: on_request, pre_validation, pre_handler, on_response, on_error\u2014executed in Rust with optional short-circuit to a response. Bindings register hooks and forward closures/function pointers into the runtime.</li> <li>Problem details: Errors use RFC 9457-compatible payloads and align with <code>testing_data/validation_errors</code>.</li> <li>Static files: Served via tower-http with ETag/Last-Modified and optional precompressed assets when configured.</li> </ul>"},{"location":"adr/0002-runtime-and-middleware/#consequences","title":"Consequences","text":"<ul> <li>All bindings must forward <code>ServerConfig</code> and related middleware configs without altering order or defaults.</li> <li>Hook registration in bindings must avoid overhead when no hooks are registered (Rust keeps fast-path checks).</li> <li>Middleware additions must update fixtures, configs, and e2e suites across languages.</li> </ul>"},{"location":"adr/0002-runtime-and-middleware/#references","title":"References","text":"<ul> <li>Runtime: <code>crates/spikard-http</code></li> <li>Configs: <code>crates/spikard-core/src/config.rs</code>, language wrappers in <code>packages/*/</code></li> <li>Fixtures: <code>testing_data/validation_errors</code>, <code>testing_data/*_limits</code>, <code>testing_data/cors</code>, <code>testing_data/static_files</code>, <code>testing_data/rate_limit</code></li> </ul>"},{"location":"adr/0003-validation-and-fixtures/","title":"ADR 0003: Validation and Fixture Source of Truth","text":"<p>Status: Accepted Date: 2025-11-20</p>"},{"location":"adr/0003-validation-and-fixtures/#context","title":"Context","text":"<p>Spikard relies on shared fixtures to guarantee consistent behavior across bindings. Validation must mirror those fixtures and schemas, and generators/tests must consume the same source.</p>"},{"location":"adr/0003-validation-and-fixtures/#decision","title":"Decision","text":"<ul> <li>Canonical source: <code>testing_data/</code> holds all REST and streaming fixtures plus category schemas (JSON Schema Draft 2020-12).</li> <li>Validation engine: <code>crates/spikard-http</code> uses the Rust <code>jsonschema</code> crate to validate request bodies, parameters, and response payloads where applicable.</li> <li>Categories: Query params, path params, headers, cookies, json_bodies, url_encoded, multipart, content_types, status_codes, validation_errors, lifecycle_hooks, background, streaming, sse/websockets, and middleware-specific sets (rate_limit, request_timeout, request_id, body_limits).</li> <li>Parity: Each binding consumes the same fixtures for e2e tests (<code>e2e/{python,node,wasm,ruby,rust}</code>) and test clients mirror the runtime encoders/decoders.</li> <li>Problem details: Structured errors adhere to <code>testing_data/validation_errors/schema.json</code> and are returned by the runtime for validation failures.</li> </ul>"},{"location":"adr/0003-validation-and-fixtures/#consequences","title":"Consequences","text":"<ul> <li>Changes to validation behavior must start with fixture/schema updates and propagate to all bindings and generated tests.</li> <li>New categories require a schema, fixtures, and generator support before being exposed in bindings.</li> <li>CI and local tasks should run fixture validation scripts (<code>testing_data/scripts/validate.py</code>) when fixtures change.</li> </ul>"},{"location":"adr/0003-validation-and-fixtures/#references","title":"References","text":"<ul> <li>Fixtures: <code>testing_data/</code></li> <li>Validation schemas: <code>testing_data/*/schema.json</code></li> <li>Runtime validation path: <code>crates/spikard-http/src/validation.rs</code> and parameter extraction modules</li> <li>E2E suites: <code>e2e/*/tests</code></li> </ul>"},{"location":"adr/0004-code-generation/","title":"ADR 0004: Code Generation Strategy","text":"<p>Status: Accepted Date: 2025-11-20</p>"},{"location":"adr/0004-code-generation/#context","title":"Context","text":"<p>Spec-driven workflows are a first-class goal. Spikard ships a CLI that turns OpenAPI/AsyncAPI plus fixtures into runnable apps and tests across languages.</p>"},{"location":"adr/0004-code-generation/#decision","title":"Decision","text":"<ul> <li>CLI: <code>crates/spikard-cli</code> exposes <code>spikard generate openapi|asyncapi</code> and related commands. <code>crates/spikard-codegen</code> holds the generation logic.</li> <li>Inputs: OpenAPI 3.\u2153.0 specs (REST) and AsyncAPI (SSE/WebSocket). Fixtures from <code>testing_data/</code> shape DTOs, routes, and streaming payloads.</li> <li>Outputs: Language-specific apps and tests for Python, Node/Bun, Ruby, PHP, WASM, and Rust harnesses. Generated tests target the same e2e clients used in <code>e2e/</code>.</li> <li>DTOs: Structured DTO generation is aligned with schemas extracted from fixtures/specs; serialization preferences follow each language\u2019s ecosystem (msgspec in Python, TS types in Node/WASM, Ruby objects).</li> <li>Planned: JSON-RPC and protobuf pipelines will re-use the same generator surfaces.</li> </ul>"},{"location":"adr/0004-code-generation/#consequences","title":"Consequences","text":"<ul> <li>Any change to generator surfaces requires updating templates for all languages and regenerating fixture-based tests.</li> <li>Spec parsing must stay aligned with the runtime\u2019s validation and routing rules to avoid divergence.</li> <li>New protocols should integrate with the same CLI UX (<code>spikard generate &lt;protocol&gt;</code>).</li> </ul>"},{"location":"adr/0004-code-generation/#references","title":"References","text":"<ul> <li>CLI: <code>crates/spikard-cli</code></li> <li>Generators: <code>crates/spikard-codegen</code>, <code>tools/test-generator</code></li> <li>Fixtures/spec inputs: <code>testing_data/</code>, <code>openapi-specs/</code></li> <li>Tasks: <code>Taskfile.yaml</code> generation targets</li> </ul>"},{"location":"adr/0005-lifecycle-hooks/","title":"ADR 0005: Lifecycle Hooks","text":"<p>Status: Accepted Date: 2025-11-20</p>"},{"location":"adr/0005-lifecycle-hooks/#context","title":"Context","text":"<p>Spikard exposes request lifecycle hooks that must be consistent across bindings and cheap when unused. Hooks are used for logging, auth/rate limiting, response shaping, and error handling.</p>"},{"location":"adr/0005-lifecycle-hooks/#decision","title":"Decision","text":"<ul> <li>Hook stages (in order): <code>on_request</code> \u2192 <code>pre_validation</code> \u2192 <code>pre_handler</code> \u2192 handler \u2192 <code>on_response</code> \u2192 <code>on_error</code> (error path).</li> <li>Runtime location: Implemented in <code>crates/spikard-http</code>; hooks are stored as optional Arc\u2019d callbacks. Fast-path skips allocation when no hooks are registered.</li> <li>Binding surface:</li> <li>Python: callbacks registered through <code>Spikard</code> methods; async supported via <code>pyo3_async_runtimes</code>.</li> <li>Node/WASM: functions registered via <code>Spikard</code> hook arrays; async supported through napi/wasm glue.</li> <li>Ruby: blocks registered on <code>Spikard::App</code>; Magnus handles calling back into Ruby.</li> <li>Short-circuiting: Hooks may return a Response to stop the pipeline. Otherwise they return the (possibly mutated) request/response.</li> <li>Testing: Fixture-driven scenarios under <code>testing_data/lifecycle_hooks</code> with e2e coverage in all language suites.</li> </ul>"},{"location":"adr/0005-lifecycle-hooks/#consequences","title":"Consequences","text":"<ul> <li>Hook registration must remain optional to keep the zero-overhead fast path.</li> <li>New hook behavior requires updating fixtures and cross-language e2e tests.</li> <li>Bindings must translate hook return types into the runtime\u2019s <code>Continue|ShortCircuit</code> contract.</li> </ul>"},{"location":"adr/0005-lifecycle-hooks/#references","title":"References","text":"<ul> <li>Runtime: <code>crates/spikard-http/src/lifecycle</code></li> <li>Fixtures: <code>testing_data/lifecycle_hooks/*</code></li> <li>Tests: <code>e2e/*/tests/*lifecycle_hooks*</code></li> </ul>"},{"location":"adr/0006-streaming-and-async-protocols/","title":"ADR 0006: Streaming, SSE, and WebSockets","text":"<p>Status: Accepted Date: 2025-11-20</p>"},{"location":"adr/0006-streaming-and-async-protocols/#context","title":"Context","text":"<p>Spikard supports streaming HTTP responses, Server-Sent Events, and WebSockets across languages. Behavior must stay aligned with shared fixtures and the Rust runtime.</p>"},{"location":"adr/0006-streaming-and-async-protocols/#decision","title":"Decision","text":"<ul> <li>Streaming HTTP: Chunked responses supported in the Rust runtime; bindings expose <code>StreamingResponse</code> (Python/Node/WASM/Ruby) that forwards to the Rust encoder.</li> <li>SSE: SSE producers are registered per-path; runtime manages event serialization and retry headers. Fixtures live in <code>testing_data/sse</code>.</li> <li>WebSockets: Handlers are registered per-path; runtime upgrades connections and forwards frames to language handlers. Fixtures live in <code>testing_data/websockets</code>.</li> <li>Test clients: Language test clients reuse the same encoders/decoders as the runtime to avoid divergence; e2e suites cover streaming, SSE, and WebSockets for each binding.</li> <li>Codegen: AsyncAPI-driven generators produce SSE/WebSocket examples and tests using the same fixtures.</li> </ul>"},{"location":"adr/0006-streaming-and-async-protocols/#consequences","title":"Consequences","text":"<ul> <li>Any protocol change requires fixture updates, regenerated tests, and parity across bindings.</li> <li>Handlers must avoid buffering entire payloads; keep streaming interfaces lean.</li> <li>SSE/WebSocket helpers in bindings must map cleanly onto runtime types (no language-specific quirks).</li> </ul>"},{"location":"adr/0006-streaming-and-async-protocols/#references","title":"References","text":"<ul> <li>Runtime: <code>crates/spikard-http</code> streaming/SSE/WebSocket modules</li> <li>Fixtures: <code>testing_data/streaming</code>, <code>testing_data/sse</code>, <code>testing_data/websockets</code></li> <li>E2E: <code>e2e/*/tests/*stream*</code>, <code>*sse*</code>, <code>*websocket*</code></li> <li>Codegen: <code>crates/spikard-cli</code>, <code>crates/spikard-codegen</code>, <code>tools/test-generator</code></li> </ul>"},{"location":"adr/0007-observability-and-otel/","title":"ADR 0007: Observability and OpenTelemetry","text":"<p>Status: Accepted Date: 2025-11-20</p>"},{"location":"adr/0007-observability-and-otel/#context","title":"Context","text":"<p>Spikard ships a Rust-first runtime with built-in observability. Today the core instrumentation is in Rust; bindings should configure it without reimplementing telemetry. We want consistent traces/metrics/logs across languages with minimal setup and no vendor lock-in.</p>"},{"location":"adr/0007-observability-and-otel/#decision","title":"Decision","text":"<ul> <li>Tracing backend: Use <code>tracing</code> and <code>tracing-subscriber</code> in <code>crates/spikard-http</code> for spans and structured logs. Attach request IDs, route names, status codes, and error contexts.</li> <li>OTel export: Provide optional OpenTelemetry exporters (HTTP/gRPC) wired through <code>tracing-opentelemetry</code>. Defaults to a no-op subscriber; enabling OTEL is opt-in via server config (endpoint, protocol, headers, sampler, resource/service metadata).</li> <li>Scope of instrumentation:</li> <li>Server startup/shutdown spans.</li> <li>Per-request span with attributes: method, path pattern, status, duration, request_id, remote_addr (if available), rate_limit decisions, timeout/body-limit hits, compression result, static file cache hits/misses.</li> <li>Middleware spans for CORS, rate limiting, timeouts, compression, static files.</li> <li>Lifecycle hooks and handler execution span; errors mapped to RFC 9457 payloads include trace context.</li> <li>Binding configuration: Expose telemetry options through <code>ServerConfig</code> (and per-language wrappers) so Python/Node/Ruby/WASM enable OTEL by toggling config, not custom code.</li> <li>Sampling/log levels: Respect user-specified sampling; default to parent/always-on in dev and parent/trace-id-based in prod. Log level configurable separately from trace sampling.</li> </ul>"},{"location":"adr/0007-observability-and-otel/#consequences","title":"Consequences","text":"<ul> <li>Bindings must forward telemetry config to the Rust runtime; no per-language exporters.</li> <li>Adding new middleware or handlers requires adding span attributes for observability parity.</li> <li>Exporters must fail closed (fallback to stdout/logger) without crashing the server if endpoints are unreachable or misconfigured.</li> <li>Tests and examples should keep OTEL disabled by default to avoid network dependency; feature flags or env-driven toggles gate exporters.</li> </ul>"},{"location":"adr/0007-observability-and-otel/#references","title":"References","text":"<ul> <li>Runtime tracing: <code>crates/spikard-http</code> (tracing layers and middleware spans)</li> <li>Config surface: <code>ServerConfig</code> telemetry/otel options in <code>crates/spikard-core</code> and language wrappers</li> </ul>"},{"location":"adr/0008-dependency-injection/","title":"ADR-0008: Dependency Injection System","text":"<p>Status: Proposed Date: 2025-11-23 Authors: Spikard Team Deciders: Core maintainers</p>"},{"location":"adr/0008-dependency-injection/#context-and-problem-statement","title":"Context and Problem Statement","text":"<p>Spikard currently lacks a dependency injection (DI) system, requiring developers to manually manage service instantiation, configuration, and lifecycle. This leads to:</p> <ol> <li>Boilerplate code - Manual service creation in every handler</li> <li>Tight coupling - Handlers directly depend on concrete implementations</li> <li>Testing difficulty - Hard to mock dependencies without extensive setup</li> <li>Resource management - No standard pattern for cleanup (database connections, file handles, etc.)</li> <li>Cross-language inconsistency - Each binding (Python, Node, Ruby, PHP) implements its own patterns</li> </ol> <p>We need a DI system that is: - Simple - Minimal API surface (like Fastify's decoration pattern) - Powerful - Type-driven resolution with nested dependencies (like Litestar) - Cross-language - Same semantics across Python, TypeScript, Ruby, PHP, WASM - Zero-cost - No overhead when not used - Rust-first - Resolution logic in Rust core, not bindings</p>"},{"location":"adr/0008-dependency-injection/#decision-drivers","title":"Decision Drivers","text":"<ol> <li>Simplicity over features - Prefer minimal API over comprehensive DI framework</li> <li>Performance - Zero-cost abstraction when DI not used, minimal overhead when used</li> <li>Type safety - Leverage Rust's type system for compile-time guarantees</li> <li>Cross-language parity - Same DI semantics across all bindings</li> <li>Existing ecosystem - Build on Axum State pattern (already in our stack)</li> <li>Testability - Easy to mock dependencies in tests</li> <li>Resource management - First-class support for cleanup (generators, Drop)</li> </ol>"},{"location":"adr/0008-dependency-injection/#considered-options","title":"Considered Options","text":""},{"location":"adr/0008-dependency-injection/#option-1-external-di-crate-shaku","title":"Option 1: External DI Crate (Shaku)","text":"<p>Description: Use shaku, a compile-time DI library with Axum integration.</p> <p>Pros: - \u2705 Battle-tested (559 GitHub stars, 123K downloads) - \u2705 Compile-time resolution (zero runtime overhead) - \u2705 Direct Axum integration via <code>shaku_axum</code> - \u2705 Module system for organization - \u2705 MIT/Apache-2.0 dual license</p> <p>Cons: - \u274c Macro-heavy API doesn't translate well to other languages - \u274c Module-based registration differs from Fastify/Litestar patterns - \u274c Limited async support (no async factories) - \u274c External dependency to maintain - \u274c Opinionated design (components vs providers)</p> <p>Verdict: \u274c Rejected - Doesn't align with cross-language goals</p>"},{"location":"adr/0008-dependency-injection/#option-2-custom-di-on-axum-state-chosen","title":"Option 2: Custom DI on Axum State (CHOSEN)","text":"<p>Description: Build lightweight DI system on Axum's <code>State&lt;T&gt;</code> pattern, inspired by Fastify (simplicity) + Litestar (power).</p> <p>Pros: - \u2705 No external dependencies - \u2705 Full control over API design - \u2705 Can match Fastify/Litestar patterns exactly - \u2705 Zero-cost when not used (<code>Option&lt;Arc&lt;Container&gt;&gt;</code>) - \u2705 Already using Axum State - \u2705 Cross-language bindings can share Container type - \u2705 Incremental complexity (start simple, add features)</p> <p>Cons: - \u26a0\ufe0f Must implement ourselves (initial development time) - \u26a0\ufe0f Need to maintain (but we control API)</p> <p>Verdict: \u2705 CHOSEN - Best fit for requirements</p>"},{"location":"adr/0008-dependency-injection/#option-3-axum-state-shaku-hybrid","title":"Option 3: Axum State + Shaku Hybrid","text":"<p>Description: Use Axum State for simple dependencies, Shaku for complex DI scenarios.</p> <p>Pros: - \u2705 Best of both worlds - \u2705 Proven framework for advanced use cases</p> <p>Cons: - \u274c Two different DI patterns to learn - \u274c Confusing for users (\"when to use which?\") - \u274c External dependency still required</p> <p>Verdict: \u274c Rejected - Adds complexity without sufficient benefit</p>"},{"location":"adr/0008-dependency-injection/#decision-outcome","title":"Decision Outcome","text":"<p>Chosen option: Option 2 - Custom DI on Axum State</p> <p>We will implement a custom dependency injection system built on Axum's <code>State&lt;T&gt;</code> pattern, combining: - Fastify's simplicity - Minimal API (<code>provide_value</code>, <code>provide_factory</code>) - Litestar's power - Type-driven resolution, dependency graphs, batched parallel execution - Rust's type safety - Compile-time checks, zero-cost abstractions - Axum's patterns - State, FromRef, extractors</p>"},{"location":"adr/0008-dependency-injection/#architecture-design","title":"Architecture Design","text":""},{"location":"adr/0008-dependency-injection/#core-abstractions","title":"Core Abstractions","text":""},{"location":"adr/0008-dependency-injection/#1-dependency-trait","title":"1. Dependency Trait","text":"<pre><code>/// Core trait for injectable dependencies\npub trait Dependency: Send + Sync {\n    /// Resolve the dependency asynchronously\n    fn resolve(\n        &amp;self,\n        request: &amp;Request&lt;Body&gt;,\n        request_data: &amp;RequestData,\n        resolved: &amp;ResolvedDependencies,\n    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Arc&lt;dyn Any + Send + Sync&gt;, DependencyError&gt;&gt; + Send&gt;&gt;;\n\n    /// Unique key for this dependency\n    fn key(&amp;self) -&gt; &amp;str;\n\n    /// Dependencies that must be resolved before this one\n    fn depends_on(&amp;self) -&gt; Vec&lt;String&gt;;\n\n    /// Should this dependency be cached per-request?\n    fn cacheable(&amp;self) -&gt; bool { false }\n\n    /// Should this dependency be cached globally (singleton)?\n    fn singleton(&amp;self) -&gt; bool { false }\n}\n</code></pre> <p>Design rationale: - <code>Send + Sync</code> required for async/multi-threaded handlers - Returns <code>Arc&lt;dyn Any&gt;</code> for type erasure (containers store heterogeneous types) - Takes <code>resolved</code> dependencies for nested resolution - Separate <code>cacheable</code> and <code>singleton</code> for flexibility</p>"},{"location":"adr/0008-dependency-injection/#2-dependencycontainer","title":"2. DependencyContainer","text":"<pre><code>pub struct DependencyContainer {\n    dependencies: HashMap&lt;String, Arc&lt;dyn Dependency&gt;&gt;,\n    dependency_graph: DependencyGraph,\n    singleton_cache: Arc&lt;RwLock&lt;HashMap&lt;String, Arc&lt;dyn Any + Send + Sync&gt;&gt;&gt;&gt;,\n}\n</code></pre> <p>Key methods: - <code>register(key, dependency)</code> - Add dependency, detect cycles - <code>resolve_for_handler(deps, request, data)</code> - Resolve batches in parallel - <code>get&lt;T&gt;(key)</code> - Type-safe retrieval with downcast</p> <p>Design rationale: - <code>DependencyGraph</code> enables topological sorting for parallel resolution - Singleton cache shared across requests (Arc&lt;RwLock&lt;&gt;&gt;) - Cycle detection at registration time (fail fast)</p>"},{"location":"adr/0008-dependency-injection/#3-dependencygraph","title":"3. DependencyGraph","text":"<pre><code>struct DependencyGraph {\n    graph: HashMap&lt;String, Vec&lt;String&gt;&gt;,\n}\n</code></pre> <p>Key methods: - <code>add_dependency(key, depends_on)</code> - Add edge, check for cycles - <code>calculate_batches(keys)</code> - Topological sort into parallel batches - <code>has_cycle_with(new_key, new_deps)</code> - DFS cycle detection</p> <p>Design rationale: - Batched resolution enables parallelism (like Litestar) - Dependencies with no sub-deps resolve in first batch - Each batch can execute concurrently (tokio::spawn tasks)</p>"},{"location":"adr/0008-dependency-injection/#4-built-in-dependency-types","title":"4. Built-in Dependency Types","text":"<pre><code>/// Simple value dependency (like Fastify's decorate)\npub struct ValueDependency&lt;T: Clone + Send + Sync + 'static&gt; {\n    key: String,\n    value: Arc&lt;T&gt;,\n}\n\n/// Factory dependency (like Litestar's Provide)\npub struct FactoryDependency {\n    key: String,\n    factory: Arc&lt;dyn Fn(&amp;Request, &amp;RequestData, &amp;ResolvedDependencies) -&gt; BoxFuture&lt;...&gt;&gt;,\n    dependencies: Vec&lt;String&gt;,\n    cacheable: bool,\n    singleton: bool,\n}\n</code></pre> <p>Design rationale: - <code>ValueDependency</code> for static values (config, constants) - <code>FactoryDependency</code> for dynamic creation (DB connections, sessions) - Factory can be async and depend on other dependencies - Configurable caching strategy</p>"},{"location":"adr/0008-dependency-injection/#handler-integration","title":"Handler Integration","text":""},{"location":"adr/0008-dependency-injection/#dependencyinjectinghandler-wrapper","title":"DependencyInjectingHandler Wrapper","text":"<pre><code>pub struct DependencyInjectingHandler {\n    inner: Arc&lt;dyn Handler&gt;,\n    container: Arc&lt;DependencyContainer&gt;,\n    required_dependencies: Vec&lt;String&gt;,\n}\n\nimpl Handler for DependencyInjectingHandler {\n    fn call(&amp;self, request: Request&lt;Body&gt;, mut request_data: RequestData)\n        -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = HandlerResult&gt; + Send + '_&gt;&gt;\n    {\n        Box::pin(async move {\n            // 1. Resolve dependencies in parallel batches\n            let resolved = self.container\n                .resolve_for_handler(&amp;self.required_dependencies, &amp;request, &amp;request_data)\n                .await?;\n\n            // 2. Attach to request_data\n            request_data.dependencies = Some(Arc::new(resolved));\n\n            // 3. Call inner handler\n            let result = self.inner.call(request, request_data).await;\n\n            // 4. Cleanup (async Drop pattern)\n            if let Some(deps) = request_data.dependencies.take() {\n                if let Ok(deps) = Arc::try_unwrap(deps) {\n                    deps.cleanup().await;\n                }\n            }\n\n            result\n        })\n    }\n}\n</code></pre> <p>Design rationale: - Wraps existing handler (composition over inheritance) - Follows <code>ValidatingHandler</code> pattern already in codebase - Cleanup happens after handler completes (generator pattern) - Integrates with existing <code>RequestData</code> struct</p>"},{"location":"adr/0008-dependency-injection/#serverconfig-integration","title":"ServerConfig Integration","text":"<pre><code>pub struct ServerConfig {\n    // ... existing fields ...\n    pub dependency_container: Option&lt;Arc&lt;DependencyContainer&gt;&gt;,\n}\n\nimpl ServerConfigBuilder {\n    /// Register a value dependency (like Fastify decorate)\n    pub fn provide_value&lt;T: Clone + Send + Sync + 'static&gt;(\n        mut self,\n        key: impl Into&lt;String&gt;,\n        value: T,\n    ) -&gt; Self {\n        let dep = ValueDependency::new(key, value);\n        self.dependency(dep)\n    }\n\n    /// Register a factory dependency (like Litestar Provide)\n    pub fn provide_factory&lt;F, Fut, T&gt;(\n        mut self,\n        key: impl Into&lt;String&gt;,\n        factory: F,\n    ) -&gt; Self\n    where\n        F: Fn(&amp;Request&lt;Body&gt;, &amp;RequestData, &amp;ResolvedDependencies) -&gt; Fut + Send + Sync + 'static,\n        Fut: Future&lt;Output = Result&lt;T, String&gt;&gt; + Send + 'static,\n        T: Send + Sync + 'static,\n    {\n        let dep = FactoryDependency::new(key, factory);\n        self.dependency(dep)\n    }\n}\n</code></pre> <p>Design rationale: - Builder pattern for ergonomic registration - Two simple methods match Fastify/Litestar patterns - Type inference reduces boilerplate</p>"},{"location":"adr/0008-dependency-injection/#language-binding-apis","title":"Language Binding APIs","text":""},{"location":"adr/0008-dependency-injection/#python","title":"Python","text":"<pre><code>from spikard import Server, Provide\n\napp = Server()\n\n# Simple value\napp.provide(\"db_url\", \"postgresql://localhost/mydb\")\n\n# Factory (sync or async)\nasync def get_db_session(db_url: str):\n    async with sessionmaker(db_url) as session:\n        yield session  # Cleanup after handler\n\napp.provide(\"db\", Provide(get_db_session, depends_on=[\"db_url\"]))\n\n# Handler with auto-injection\n@app.get(\"/users\")\nasync def get_users(db: AsyncSession) -&gt; list[User]:\n    # db is injected by matching type or name\n    return await db.query(User).all()\n</code></pre> <p>Design rationale: - <code>Provide</code> wrapper matches Litestar API - Generator pattern for cleanup (Pythonic) - Type hints enable auto-injection - Parameter name or type annotation for matching</p>"},{"location":"adr/0008-dependency-injection/#typescriptnode","title":"TypeScript/Node","text":"<pre><code>import { Server, Provide } from '@spikard/node';\n\nconst app = new Server();\n\n// Simple value\napp.provide('dbUrl', 'postgresql://localhost/mydb');\n\n// Factory\napp.provide('db', Provide(async (dbUrl: string) =&gt; {\n  return await createConnection(dbUrl);\n}, { dependsOn: ['dbUrl'], singleton: true }));\n\n// Handler with destructuring\napp.get('/users', async (request, { db }: { db: Database }) =&gt; {\n  return await db.query('SELECT * FROM users');\n});\n</code></pre> <p>Design rationale: - Object destructuring for dependency access - TypeScript types for safety - Optional decorator support (future)</p>"},{"location":"adr/0008-dependency-injection/#ruby","title":"Ruby","text":"<pre><code>app = Spikard::Server.new\n\n# Simple value\napp.provide(:db_url, 'postgresql://localhost/mydb')\n\n# Factory with block\napp.provide(:db, Spikard::Provide.new(\n  -&gt; (db_url) { DBConnection.new(db_url) },\n  depends_on: [:db_url]\n))\n\n# Handler with keyword args\napp.get('/users') do |request, db:|\n  { users: db.query('SELECT * FROM users') }\nend\n</code></pre> <p>Design rationale: - Keyword arguments (idiomatic Ruby) - Blocks and procs supported - Symbol keys (Ruby convention)</p>"},{"location":"adr/0008-dependency-injection/#php","title":"PHP","text":"<pre><code>&lt;?php\nuse Spikard\\App;\nuse Spikard\\DI\\Provide;\n\n$app = new App();\n\n// Simple value\n$app-&gt;provide('dbUrl', 'postgresql://localhost/mydb');\n\n// Factory with closure\n$app-&gt;provide('db', new Provide(\n    fn(string $dbUrl) =&gt; new PDO($dbUrl),\n    dependsOn: ['dbUrl'],\n    singleton: true\n));\n\n// Handler with dependency injection\n$app-&gt;addRoute('GET', '/users', function (Request $req, PDO $db) {\n    $stmt = $db-&gt;query('SELECT * FROM users');\n    return Response::json($stmt-&gt;fetchAll(PDO::FETCH_ASSOC));\n});\n</code></pre> <p>Design rationale: - Constructor property promotion (modern PHP) - Typed parameters for type safety - Closure-based factories - PSR-compliant (PSR-7 for HTTP, PSR-11 for containers)</p>"},{"location":"adr/0008-dependency-injection/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"adr/0008-dependency-injection/#zero-cost-when-unused","title":"Zero-Cost When Unused","text":"<pre><code>// No DI container registered\nlet config = ServerConfig::builder().build();\n// dependency_container = None, zero overhead\n\n// With DI\nlet config = ServerConfig::builder()\n    .provide_value(\"config\", AppConfig::load())\n    .build();\n// dependency_container = Some(Arc&lt;Container&gt;), minimal overhead\n</code></pre>"},{"location":"adr/0008-dependency-injection/#batched-parallel-resolution","title":"Batched Parallel Resolution","text":"<pre><code>// Given dependency graph:\n//   db -&gt; config\n//   cache -&gt; config\n//   auth -&gt; db, cache\n//\n// Batch 1 (parallel): config\n// Batch 2 (parallel): db, cache\n// Batch 3 (sequential): auth\n</code></pre> <p>Performance characteristics: - Independent dependencies resolve concurrently - Singleton cache eliminates repeated resolution (Arc clone only) - Per-request cache avoids duplicate work within request</p>"},{"location":"adr/0008-dependency-injection/#benchmarking-plan","title":"Benchmarking Plan","text":"<p>Compare: 1. Handler without DI (baseline) 2. Handler with DI but no dependencies (overhead check) 3. Handler with 1 dependency (simple case) 4. Handler with 5 nested dependencies (complex case) 5. Handler with singleton vs per-request caching</p> <p>Target: &lt;1% overhead for simple cases, &lt;5% for complex cases</p>"},{"location":"adr/0008-dependency-injection/#testing-strategy","title":"Testing Strategy","text":""},{"location":"adr/0008-dependency-injection/#unit-tests-rust","title":"Unit Tests (Rust)","text":"<ul> <li><code>DependencyGraph::calculate_batches()</code> correctness</li> <li>Cycle detection with various graph shapes</li> <li><code>ValueDependency</code> and <code>FactoryDependency</code> resolution</li> <li>Singleton caching behavior</li> <li>Per-request caching behavior</li> <li>Cleanup task execution</li> </ul>"},{"location":"adr/0008-dependency-injection/#integration-tests-python","title":"Integration Tests (Python)","text":"<ul> <li>Value injection in handlers</li> <li>Factory injection (sync and async)</li> <li>Nested dependency resolution</li> <li>Error handling (missing dependency)</li> <li>Error handling (circular dependency)</li> <li>Cleanup after request completes</li> <li>Type-based injection</li> <li>Name-based injection</li> </ul>"},{"location":"adr/0008-dependency-injection/#fixture-driven-tests","title":"Fixture-Driven Tests","text":"<p>Create <code>testing_data/di/</code> fixtures: - <code>basic_value/</code> - Simple value injection - <code>factory/</code> - Factory dependency - <code>singleton/</code> - Singleton caching - <code>nested/</code> - Multi-level dependencies - <code>circular_error/</code> - Cycle detection - <code>cleanup/</code> - Generator cleanup</p> <p>Each fixture includes: - <code>schema.json</code> - Expected structure - <code>input.json</code> - Request data - <code>expected.json</code> - Expected response</p>"},{"location":"adr/0008-dependency-injection/#coverage-targets","title":"Coverage Targets","text":"<ul> <li>Rust core: 95% minimum</li> <li>Python binding: 80% minimum</li> <li>Node binding: 80% minimum</li> <li>Ruby binding: 80% minimum</li> <li>PHP binding: 80% minimum</li> </ul>"},{"location":"adr/0008-dependency-injection/#consequences","title":"Consequences","text":""},{"location":"adr/0008-dependency-injection/#positive","title":"Positive","text":"<p>\u2705 Simple API - Two methods to learn (<code>provide_value</code>, <code>provide_factory</code>) \u2705 Type-safe - Rust's type system enforces correctness \u2705 Cross-language consistency - Same semantics across all bindings \u2705 Zero-cost - No overhead when not used \u2705 Testable - Easy to mock dependencies in tests \u2705 Resource management - First-class cleanup support \u2705 No external dependencies - Built on Axum State (already in stack) \u2705 Incremental adoption - Can add DI to existing apps gradually \u2705 Performance - Batched parallel resolution, caching</p>"},{"location":"adr/0008-dependency-injection/#negative","title":"Negative","text":"<p>\u26a0\ufe0f Custom implementation - We maintain it (not a third-party crate) \u26a0\ufe0f Initial development time - ~2 months for full cross-language support \u26a0\ufe0f Learning curve - Users must learn DI patterns \u26a0\ufe0f Complexity - Adds conceptual overhead to framework</p>"},{"location":"adr/0008-dependency-injection/#neutral","title":"Neutral","text":"<p>\ud83d\udd37 Not as feature-rich as enterprise DI frameworks (NestJS, Spring) \ud83d\udd37 Simpler than those frameworks (intentional trade-off)</p>"},{"location":"adr/0008-dependency-injection/#migration-path","title":"Migration Path","text":""},{"location":"adr/0008-dependency-injection/#adding-di-to-existing-app","title":"Adding DI to Existing App","text":"<p>Before: <pre><code>#[derive(Clone)]\nstruct AppState {\n    db: Arc&lt;DatabasePool&gt;,\n}\n\nasync fn handler(State(state): State&lt;AppState&gt;) -&gt; String {\n    let users = state.db.query(\"SELECT * FROM users\").await?;\n    format!(\"{:?}\", users)\n}\n\nlet app = Router::new()\n    .route(\"/\", get(handler))\n    .with_state(AppState { db: Arc::new(pool) });\n</code></pre></p> <p>After: <pre><code>let config = ServerConfig::builder()\n    .provide_value(\"db\", Arc::new(DatabasePool::new()))\n    .build();\n\n// Handler signature unchanged if using State pattern\n// Or use DI for cleaner separation:\nasync fn handler(db: Arc&lt;DatabasePool&gt;) -&gt; String {\n    let users = db.query(\"SELECT * FROM users\").await?;\n    format!(\"{:?}\", users)\n}\n</code></pre></p>"},{"location":"adr/0008-dependency-injection/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>Existing <code>State&lt;T&gt;</code> pattern continues to work</li> <li>DI is opt-in via <code>ServerConfig::provide_*()</code></li> <li>Handlers can mix State and DI extractors</li> </ul>"},{"location":"adr/0008-dependency-injection/#open-questions","title":"Open Questions","text":"<ol> <li>Scoped dependencies - Should we support request/singleton/transient scopes explicitly?</li> <li> <p>Proposal: Start with singleton/per-request, add more later if needed</p> </li> <li> <p>Type-based resolution - Should dependencies be resolvable by type without a key?</p> </li> <li> <p>Proposal: Require keys initially, add type-based as optional feature</p> </li> <li> <p>Automatic registration - Should we auto-register common types (Request, State, etc.)?</p> </li> <li> <p>Proposal: Manual registration only (explicit &gt; implicit)</p> </li> <li> <p>Streaming/SSE/WebSocket - How does DI work with long-lived connections?</p> </li> <li>Proposal: Resolve dependencies at connection start, cleanup at close</li> </ol>"},{"location":"adr/0008-dependency-injection/#implementation-timeline","title":"Implementation Timeline","text":"<ul> <li>Week 1-2: Rust core DI system + built-in types</li> <li>Week 2-3: Handler integration + router updates</li> <li>Week 3-4: ServerConfig integration + fixtures</li> <li>Week 4-5: Integration tests + Python binding</li> <li>Week 5-6: Python binding complete + examples</li> <li>Week 6-7: Node/TypeScript binding + examples</li> <li>Week 7-8: Ruby binding + examples</li> <li>Week 8: PHP binding + examples</li> <li>Week 9: WASM binding + examples</li> <li>Week 10: Documentation + polish</li> <li>Week 11: Review + merge</li> </ul> <p>Total: ~11 weeks for full cross-language DI system</p>"},{"location":"adr/0008-dependency-injection/#references","title":"References","text":"<ul> <li>Litestar Dependency Injection</li> <li>Fastify Decorators</li> <li>Axum State Extractors</li> <li>Shaku Compile-Time DI</li> <li>ADR-0001: Architecture and Principles</li> <li>ADR-0002: HTTP Runtime and Middleware Pipeline</li> <li>ADR-0003: Validation and Fixture Source of Truth</li> <li>ADR-0005: Lifecycle Hooks</li> </ul>"},{"location":"adr/0008-dependency-injection/#appendix-comparison-with-other-solutions","title":"Appendix: Comparison with Other Solutions","text":""},{"location":"adr/0008-dependency-injection/#vs-litestar-di","title":"vs Litestar DI","text":"<p>Similarities: - Type-driven resolution - Dependency graph with batched execution - Generator pattern for cleanup - <code>Provide</code> wrapper class</p> <p>Differences: - Spikard: Rust-first (cross-language) - Litestar: Python-only (runtime reflection) - Spikard: Explicit keys + optional type-based - Litestar: Primarily type-based</p>"},{"location":"adr/0008-dependency-injection/#vs-fastify-decorators","title":"vs Fastify Decorators","text":"<p>Similarities: - Simple API (<code>decorate</code> \u2248 <code>provide_value</code>) - Plugin-based encapsulation - Property-based access</p> <p>Differences: - Spikard: Dependency graph, nested resolution - Fastify: Flat decoration (no nesting) - Spikard: Type-safe extractors - Fastify: Property access (<code>fastify.db</code>)</p>"},{"location":"adr/0008-dependency-injection/#vs-shaku","title":"vs Shaku","text":"<p>Similarities: - Compile-time DI - Components (singletons) + Providers (factories) - Module organization</p> <p>Differences: - Spikard: Runtime resolution with compile-time types - Shaku: Compile-time resolution (macro expansion) - Spikard: Cross-language bindings - Shaku: Rust-only - Spikard: Axum State-based - Shaku: Module-based</p> <p>Decision: Proceed with custom DI system on Axum State foundation</p>"},{"location":"adr/TEMPLATE/","title":"ADR 000X: Title","text":"<p>Status: Proposed Date: YYYY-MM-DD</p>"},{"location":"adr/TEMPLATE/#context","title":"Context","text":"<p>Explain the problem, constraints, and stakeholders.</p>"},{"location":"adr/TEMPLATE/#decision","title":"Decision","text":"<p>The choice made, including scope and boundaries.</p>"},{"location":"adr/TEMPLATE/#consequences","title":"Consequences","text":"<ul> <li>Immediate effects</li> <li>Risks and mitigations</li> <li>Follow-up work</li> </ul>"},{"location":"adr/TEMPLATE/#references","title":"References","text":"<ul> <li>Related ADRs</li> <li>Code/tests</li> <li>Specs or external sources</li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Spikard includes a comprehensive benchmarking system for measuring and comparing HTTP framework performance across multiple languages and platforms.</p>"},{"location":"benchmarks/#overview","title":"Overview","text":"<p>The benchmark harness provides rigorous, reproducible performance measurements to help you:</p> <ul> <li>Understand Spikard's performance characteristics across different language bindings</li> <li>Compare frameworks within the same language ecosystem (Python, Node.js, Ruby, PHP)</li> <li>Measure validation overhead by testing validated vs raw implementations</li> <li>Track performance regressions through automated CI benchmarks</li> <li>Optimize your applications with detailed profiling data</li> </ul>"},{"location":"benchmarks/#quick-start","title":"Quick Start","text":"<p>Run a basic benchmark:</p> <pre><code>cd tools/benchmark-harness\ncargo build --release\n\n# Benchmark Spikard Python\n./target/release/benchmark-harness run \\\n  --framework spikard-python \\\n  --app-dir apps/spikard-python\n</code></pre> <p>Compare multiple frameworks:</p> <pre><code># Compare Python frameworks\n./target/release/benchmark-harness compare \\\n  --frameworks spikard-python,fastapi,litestar \\\n  --suite all \\\n  --output results/comparison\n</code></pre>"},{"location":"benchmarks/#what-we-measure","title":"What We Measure","text":""},{"location":"benchmarks/#throughput","title":"Throughput","text":"<ul> <li>Requests per second (RPS): Primary performance indicator</li> <li>Bytes per second: Network throughput</li> <li>Success rate: Percentage of successful requests</li> </ul>"},{"location":"benchmarks/#latency-distribution","title":"Latency Distribution","text":"<ul> <li>Mean and median latency: Average and typical request times</li> <li>Percentiles: p50, p90, p95, p99, p99.9 for understanding tail latency</li> <li>Min/max latency: Latency range</li> </ul>"},{"location":"benchmarks/#resource-utilization","title":"Resource Utilization","text":"<ul> <li>CPU usage: Average, peak, and p95 CPU percentage</li> <li>Memory consumption: Resident set size in MB</li> <li>Startup metrics: Process spawn time, time to first response</li> </ul>"},{"location":"benchmarks/#language-specific-profiling","title":"Language-Specific Profiling","text":"<ul> <li>Python: GIL wait time, GIL contention, FFI overhead, GC statistics</li> <li>Node.js: V8 heap usage, event loop lag, GC time</li> <li>Ruby: GC count and time, heap pages, live objects</li> <li>Rust: Heap allocation size</li> </ul>"},{"location":"benchmarks/#benchmark-modes","title":"Benchmark Modes","text":""},{"location":"benchmarks/#profile-mode","title":"Profile Mode","text":"<p>Deep analysis of a single framework implementation across multiple workload suites.</p> <pre><code>./target/release/benchmark-harness profile \\\n  --framework spikard-python \\\n  --app-dir apps/spikard-python \\\n  --suite all \\\n  --profiler python \\\n  --output results/profile.json\n</code></pre> <p>Use for: - Optimizing framework performance - Identifying bottlenecks - Measuring validation overhead - Comparing framework variants</p>"},{"location":"benchmarks/#compare-mode","title":"Compare Mode","text":"<p>Statistical comparison of multiple frameworks with significance testing.</p> <pre><code>./target/release/benchmark-harness compare \\\n  --frameworks spikard-python,fastapi,robyn \\\n  --suite json-bodies \\\n  --significance 0.05 \\\n  --output results/comparison\n</code></pre> <p>Use for: - Framework selection decisions - Validating performance claims - Cross-framework comparisons - Regression detection</p>"},{"location":"benchmarks/#workload-suites","title":"Workload Suites","text":"<p>Benchmarks test realistic HTTP patterns:</p> Suite Workloads What It Tests <code>all</code> 18 Complete benchmark across all categories <code>json-bodies</code> 4 JSON serialization (86 bytes to 150 KB) <code>path-params</code> 6 Path parameter extraction and validation <code>query-params</code> 3 Query string parsing (3 to 15+ parameters) <code>forms</code> 2 URL-encoded form data handling <code>multipart</code> 3 File upload performance (1 KB to 100 KB) <p>Each workload tests a specific HTTP pattern against all framework implementations to ensure fair comparison.</p>"},{"location":"benchmarks/#validation-overhead-analysis","title":"Validation Overhead Analysis","text":"<p>A key feature of the benchmark system is measuring the cost of runtime type validation through paired implementations:</p> <ul> <li>Validated: Full type checking with schema validation (msgspec, Zod, Pydantic)</li> <li>Raw: Direct JSON parsing without validation</li> </ul> <p>Example pairs: - <code>spikard-python</code> vs <code>spikard-raw</code> - <code>fastapi</code> vs <code>fastapi-raw</code> - <code>express</code> vs <code>express-raw</code></p> <p>Typical validation overhead: - msgspec (Spikard, Litestar): ~15% overhead - Pydantic (FastAPI): ~40% overhead - Zod (Express): ~25% overhead - Ajv (Fastify): ~10% overhead</p>"},{"location":"benchmarks/#benchmarked-frameworks","title":"Benchmarked Frameworks","text":"<p>The suite includes 34+ framework implementations across five language ecosystems:</p> <p>Python: FastAPI, Litestar, Robyn, Spikard Python (+ raw variants)</p> <p>Node.js: Express, Fastify, Hono, Elysia, Spikard Node (+ raw variants)</p> <p>Ruby: Roda, Hanami API, Spikard Ruby (+ raw variants)</p> <p>PHP: Phalcon, Trongate, Spikard PHP</p> <p>Rust: Axum baseline, Spikard Rust</p> <p>View complete framework list \u2192</p>"},{"location":"benchmarks/#statistical-methodology","title":"Statistical Methodology","text":"<p>Results undergo rigorous statistical analysis:</p> <ul> <li>Welch's t-test: Tests for significant performance differences</li> <li>Significance threshold: p-value &lt; 0.05 (configurable)</li> <li>Effect size: Cohen's d measures practical significance</li> <li>Multiple comparison correction: Baseline comparison reduces false positives</li> </ul> <p>Results are marked \"statistically significant\" only when both statistical and practical significance criteria are met.</p>"},{"location":"benchmarks/#reproducibility","title":"Reproducibility","text":"<p>Every benchmark result includes complete metadata:</p> <ul> <li>Git commit hash and branch</li> <li>Host information (CPU model, cores, RAM)</li> <li>Framework and runtime versions</li> <li>Benchmark configuration (duration, concurrency)</li> <li>ISO 8601 timestamp</li> </ul> <p>This enables comparison of historical results and identification of environment-related variations.</p>"},{"location":"benchmarks/#results-format","title":"Results Format","text":"<p>Benchmarks produce structured JSON output for automated analysis:</p> <pre><code>{\n  \"mode\": \"profile\",\n  \"metadata\": {\n    \"framework\": \"spikard-python\",\n    \"timestamp\": \"2024-11-29T10:00:00Z\",\n    \"git_commit\": \"abc123\",\n    \"host\": {\"cpu_model\": \"Apple M2 Pro\", \"cpu_cores\": 12}\n  },\n  \"suites\": [{\n    \"name\": \"json-bodies\",\n    \"workloads\": [{\n      \"name\": \"json-small\",\n      \"results\": {\n        \"throughput\": {\"requests_per_sec\": 59358.24},\n        \"latency\": {\"p99_ms\": 2.87},\n        \"resources\": {\"cpu\": {\"avg_percent\": 78.5}}\n      }\n    }]\n  }]\n}\n</code></pre> <p>This schema supports: - Historical trend analysis - Performance regression detection - Automated report generation - Cross-version comparison</p>"},{"location":"benchmarks/#performance-baselines","title":"Performance Baselines","text":"<p>Current performance targets:</p> <ul> <li>Spikard Rust: 100k+ RPS for small JSON payloads</li> <li>Spikard Python: 70%+ of FastAPI performance with full validation</li> <li>Spikard Node: Competitive with Express, within 90% of Fastify</li> <li>Validation overhead: &lt;20% throughput reduction for validated vs raw</li> </ul> <p>These baselines are continuously tracked through automated CI benchmarks.</p>"},{"location":"benchmarks/#documentation","title":"Documentation","text":"<ul> <li>Methodology: Detailed explanation of benchmark approach and workload design</li> <li>Frameworks: Complete list of benchmarked frameworks with descriptions</li> <li>Running Benchmarks: Guide to running benchmarks locally and adding new frameworks</li> <li>Harness Design: Technical design document with JSON schema definitions</li> </ul>"},{"location":"benchmarks/#getting-started","title":"Getting Started","text":"<ol> <li>Install prerequisites</li> <li>Build the harness</li> <li>Run your first benchmark</li> <li>Understand the results</li> </ol>"},{"location":"benchmarks/#contributing","title":"Contributing","text":"<p>To add a new framework to the benchmark suite:</p> <ol> <li>Create app directory in <code>tools/benchmark-harness/apps/</code></li> <li>Implement all required workload endpoints</li> <li>Match request/response schemas exactly</li> <li>Create <code>-raw</code> variant if validation can be disabled</li> <li>Test locally with the benchmark harness</li> <li>Submit PR with documentation</li> </ol> <p>Detailed instructions \u2192</p>"},{"location":"benchmarks/#load-generators","title":"Load Generators","text":"<p>The harness automatically detects and uses available load generators:</p> <ul> <li>oha (preferred): Rust-based HTTP load tester with percentile latency</li> <li>bombardier: Go-based alternative with similar features</li> </ul> <p>Install oha: <pre><code>cargo install oha\n</code></pre></p> <p>Or bombardier: <pre><code>go install github.com/codesenberg/bombardier@latest\n</code></pre></p>"},{"location":"benchmarks/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about benchmark methodology</li> <li>Review benchmarked frameworks</li> <li>Run benchmarks locally</li> <li>Read technical design</li> </ul>"},{"location":"benchmarks/frameworks/","title":"Benchmarked Frameworks","text":"<p>This document catalogs all frameworks included in the Spikard benchmark suite, organized by language ecosystem.</p>"},{"location":"benchmarks/frameworks/#framework-categories","title":"Framework Categories","text":""},{"location":"benchmarks/frameworks/#spikard-variants","title":"Spikard Variants","text":"<p>Core Spikard implementations across different language bindings.</p> Framework Language Runtime Validation Description <code>spikard-rust</code> Rust Native Tower middleware Pure Rust implementation, baseline performance <code>spikard-python</code> Python CPython 3.12+ msgspec PyO3 bindings with msgspec validation <code>spikard-node</code> TypeScript Node 20+ Zod napi-rs bindings with optional Zod validation <code>spikard-ruby</code> Ruby Ruby 3.2+ RBS magnus bindings with RBS type definitions <code>spikard-php</code> PHP PHP 8.2+ Native types ext-php-rs bindings with typed properties <code>spikard-wasm</code> JavaScript WASM runtime None WebAssembly bindings via wasm-bindgen"},{"location":"benchmarks/frameworks/#python-ecosystem","title":"Python Ecosystem","text":"<p>Python frameworks with ASGI/WSGI servers.</p> Framework Version Server Validation Description <code>fastapi</code> 0.115+ Uvicorn Pydantic v2 Popular async framework with OpenAPI generation <code>fastapi-granian</code> 0.115+ Granian Pydantic v2 FastAPI with Rust-based Granian ASGI server <code>litestar</code> 2.x Uvicorn msgspec Performance-focused FastAPI alternative <code>litestar-granian</code> 2.x Granian msgspec Litestar with Granian server <code>robyn</code> 0.x Native Rust None Rust-based Python framework (similar architecture to Spikard)"},{"location":"benchmarks/frameworks/#raw-variants-no-validation","title":"Raw Variants (No Validation)","text":"Framework Description <code>fastapi-raw</code> FastAPI with Pydantic validation disabled <code>fastapi-granian-raw</code> FastAPI + Granian without validation <code>litestar-raw</code> Litestar with msgspec validation disabled <code>litestar-granian-raw</code> Litestar + Granian without validation <code>spikard-raw</code> Spikard Python with msgspec validation disabled <p>Purpose: Measure validation overhead by comparing validated vs raw variants.</p>"},{"location":"benchmarks/frameworks/#nodejs-ecosystem","title":"Node.js Ecosystem","text":"<p>JavaScript/TypeScript frameworks on Node.js, Bun, and Deno runtimes.</p> Framework Runtime Validation Description <code>express</code> Node 20+ Zod Traditional Node.js framework, most popular <code>express-raw</code> Node 20+ None Express without validation <code>fastify</code> Node 20+ Ajv (JSON Schema) High-performance Node framework <code>fastify-raw</code> Node 20+ None Fastify without validation <code>hono</code> Node/Bun/Deno Zod Ultra-lightweight framework, multi-runtime <code>hono-raw</code> Node/Bun/Deno None Hono without validation <code>elysia</code> Bun 1.x TypeBox Bun-optimized framework with first-class TypeScript <code>morojs</code> Node 20+ None Minimalist routing framework"},{"location":"benchmarks/frameworks/#ruby-ecosystem","title":"Ruby Ecosystem","text":"<p>Ruby frameworks with Rack-compatible servers.</p> Framework Server Validation Description <code>roda</code> Puma Dry-validation Lightweight routing tree framework <code>roda-raw</code> Puma None Roda without validation <code>hanami-api</code> Puma Dry-validation Modern Ruby framework from Hanami ecosystem <code>hanami-api-raw</code> Puma None Hanami API without validation"},{"location":"benchmarks/frameworks/#php-ecosystem","title":"PHP Ecosystem","text":"<p>PHP frameworks using traditional and modern architectures.</p> Framework Version Validation Description <code>phalcon</code> 5.x Built-in C-extension framework, compiled for performance <code>trongate</code> Latest Manual Lightweight MVC framework"},{"location":"benchmarks/frameworks/#baseline-comparisons","title":"Baseline Comparisons","text":"<p>Reference implementations for performance comparison.</p> Framework Language Description <code>axum-baseline</code> Rust Pure Rust Axum framework, theoretical maximum performance"},{"location":"benchmarks/frameworks/#framework-details","title":"Framework Details","text":""},{"location":"benchmarks/frameworks/#python","title":"Python","text":""},{"location":"benchmarks/frameworks/#fastapi","title":"FastAPI","text":"<p>Version: 0.115+ Validation: Pydantic v2 Server: Uvicorn (default) or Granian</p> <p>The most popular async Python framework. Generates OpenAPI schemas automatically. Uses Pydantic for request/response validation with runtime type checking.</p> <p>Key features: - Automatic OpenAPI documentation - Type hints for editor support - Dependency injection system - OAuth2 and JWT support</p> <p>Performance characteristics: - ~40% validation overhead (Pydantic) - Good async performance with Uvicorn - 15-25% improvement with Granian server - Slower than Litestar due to heavier validation</p>"},{"location":"benchmarks/frameworks/#litestar","title":"Litestar","text":"<p>Version: 2.x Validation: msgspec Server: Uvicorn (default) or Granian</p> <p>FastAPI-inspired framework optimized for performance. Uses msgspec instead of Pydantic for 5x faster validation.</p> <p>Key features: - OpenAPI generation - Dependency injection - Plugin system - msgspec for fast serialization</p> <p>Performance characteristics: - ~15% validation overhead (msgspec) - Faster than FastAPI in all workloads - Excellent JSON performance - 10-20% improvement with Granian</p>"},{"location":"benchmarks/frameworks/#robyn","title":"Robyn","text":"<p>Version: 0.x Validation: None Server: Native Rust (actix-web based)</p> <p>Experimental framework with Rust core and Python bindings. Similar architecture to Spikard but less mature.</p> <p>Key features: - Rust-based HTTP server - Minimal Python overhead - Simple decorator-based routing</p> <p>Performance characteristics: - Very high RPS (~2-3x FastAPI) - No built-in validation - Limited middleware ecosystem - Immature error handling</p>"},{"location":"benchmarks/frameworks/#nodejs","title":"Node.js","text":""},{"location":"benchmarks/frameworks/#express","title":"Express","text":"<p>Version: 4.x Validation: Zod (when added) Server: Node HTTP module</p> <p>The most widely-used Node.js framework. Mature ecosystem with thousands of middleware packages.</p> <p>Key features: - Massive ecosystem - Flexible routing - Template engine support - Simple API</p> <p>Performance characteristics: - Moderate performance - ~25% validation overhead with Zod - Single-threaded (typical Node limitation) - Well-optimized for I/O-bound tasks</p>"},{"location":"benchmarks/frameworks/#fastify","title":"Fastify","text":"<p>Version: 4.x Validation: Ajv (JSON Schema) Server: Node HTTP module</p> <p>Performance-focused Express alternative. Uses JSON Schema for validation with pre-compiled validators.</p> <p>Key features: - Schema-based validation (Ajv) - Plugin architecture - Request/response lifecycle hooks - Logging built-in (pino)</p> <p>Performance characteristics: - 2-3x faster than Express - ~10% validation overhead (compiled schemas) - Optimized JSON serialization (fast-json-stringify) - Lower memory usage</p>"},{"location":"benchmarks/frameworks/#hono","title":"Hono","text":"<p>Version: 4.x Validation: Zod Server: Node/Bun/Deno/Cloudflare Workers</p> <p>Ultra-lightweight framework designed for edge runtimes. Runs on Node, Bun, Deno, and Cloudflare Workers.</p> <p>Key features: - Multi-runtime support - Tiny bundle size (&lt;13KB) - Edge-optimized - Middleware system</p> <p>Performance characteristics: - Comparable to Fastify on Node - 20-30% faster on Bun runtime - Low memory footprint - Excellent cold start times</p>"},{"location":"benchmarks/frameworks/#elysia","title":"Elysia","text":"<p>Version: 1.x Validation: TypeBox Server: Bun native</p> <p>Framework designed specifically for Bun. Takes advantage of Bun's JavaScriptCore engine and fast I/O.</p> <p>Key features: - Bun-optimized - End-to-end type safety - Eden Treaty (type-safe client) - Plugin system</p> <p>Performance characteristics: - 3-5x faster than Express - Fastest Node.js ecosystem framework - Requires Bun runtime - Very low latency</p>"},{"location":"benchmarks/frameworks/#ruby","title":"Ruby","text":""},{"location":"benchmarks/frameworks/#roda","title":"Roda","text":"<p>Version: 3.x Validation: Dry-validation Server: Puma</p> <p>Lightweight routing tree framework. Emphasizes simplicity and plugin-based architecture.</p> <p>Key features: - Routing tree (efficient matching) - Plugin system - Minimal dependencies - Flexible architecture</p> <p>Performance characteristics: - Fast for Ruby ecosystem - ~15% validation overhead - Scales well with request complexity - Lower memory than Rails</p>"},{"location":"benchmarks/frameworks/#hanami-api","title":"Hanami API","text":"<p>Version: 2.x Validation: Dry-validation Server: Puma</p> <p>Modern Ruby framework focused on HTTP APIs. Part of the larger Hanami ecosystem.</p> <p>Key features: - Dry-rb integration - Action-based architecture - Immutable objects - Clean separation of concerns</p> <p>Performance characteristics: - Similar to Roda - Slightly higher memory usage - Good JSON performance - Well-suited for APIs</p>"},{"location":"benchmarks/frameworks/#php","title":"PHP","text":""},{"location":"benchmarks/frameworks/#phalcon","title":"Phalcon","text":"<p>Version: 5.x Validation: Built-in validators Server: PHP-FPM or Swoole</p> <p>High-performance PHP framework implemented as C extension. Compiled for maximum speed.</p> <p>Key features: - C extension (compiled code) - Full-stack framework - ORM built-in - Volt template engine</p> <p>Performance characteristics: - Fastest PHP framework - 5-10x faster than Laravel - Low memory overhead - Requires C extension installation</p>"},{"location":"benchmarks/frameworks/#trongate","title":"Trongate","text":"<p>Version: Latest Validation: Manual Server: Apache/Nginx</p> <p>Lightweight MVC framework with minimal dependencies.</p> <p>Key features: - No composer dependencies - Rapid development focus - Built-in code generator - Simple architecture</p> <p>Performance characteristics: - Moderate performance - Low resource usage - Traditional PHP architecture</p>"},{"location":"benchmarks/frameworks/#rust","title":"Rust","text":""},{"location":"benchmarks/frameworks/#axum","title":"Axum","text":"<p>Version: 0.7+ Validation: Tower middleware Server: Tokio runtime</p> <p>Modern Rust web framework built on Tower middleware and Hyper.</p> <p>Key features: - Type-safe extractors - Tower middleware ecosystem - Excellent compile-time guarantees - First-class async support</p> <p>Performance characteristics: - 100k+ RPS baseline - Minimal runtime overhead - Zero-cost abstractions - Sub-millisecond latencies</p>"},{"location":"benchmarks/frameworks/#validation-overhead-summary","title":"Validation Overhead Summary","text":"<p>Framework pairs showing validation cost:</p> Framework Raw RPS Validated RPS Overhead FastAPI (Pydantic) 35,000 21,000 ~40% Litestar (msgspec) 45,000 38,000 ~15% Spikard (msgspec) 50,000 42,000 ~16% Express (Zod) 25,000 18,000 ~28% Fastify (Ajv) 60,000 54,000 ~10% Roda (Dry-validation) 15,000 12,500 ~17% <p>Key insight: msgspec (Litestar, Spikard) and compiled schemas (Fastify Ajv) have the lowest validation overhead.</p>"},{"location":"benchmarks/frameworks/#framework-selection-guide","title":"Framework Selection Guide","text":""},{"location":"benchmarks/frameworks/#choose-fastapi-if-you-need","title":"Choose FastAPI if you need:","text":"<ul> <li>Automatic OpenAPI documentation</li> <li>Large ecosystem and community</li> <li>Mature production deployments</li> <li>Type safety with Pydantic</li> </ul>"},{"location":"benchmarks/frameworks/#choose-litestar-if-you-need","title":"Choose Litestar if you need:","text":"<ul> <li>FastAPI-like DX with better performance</li> <li>msgspec's speed advantage</li> <li>Modern async patterns</li> <li>Plugin extensibility</li> </ul>"},{"location":"benchmarks/frameworks/#choose-spikard-if-you-need","title":"Choose Spikard if you need:","text":"<ul> <li>Maximum Python performance</li> <li>Rust-level safety with Python DX</li> <li>Multi-language consistency (also using Spikard in Node/Ruby)</li> <li>Minimal validation overhead</li> </ul>"},{"location":"benchmarks/frameworks/#choose-express-if-you-need","title":"Choose Express if you need:","text":"<ul> <li>Maximum compatibility and ecosystem</li> <li>Stable, well-understood patterns</li> <li>Extensive middleware options</li> <li>Traditional Node.js development</li> </ul>"},{"location":"benchmarks/frameworks/#choose-fastify-if-you-need","title":"Choose Fastify if you need:","text":"<ul> <li>High-performance Node.js</li> <li>Schema-based validation</li> <li>Built-in logging and lifecycle hooks</li> <li>Production-grade plugin system</li> </ul>"},{"location":"benchmarks/frameworks/#choose-hono-if-you-need","title":"Choose Hono if you need:","text":"<ul> <li>Edge deployment (Cloudflare Workers)</li> <li>Multi-runtime support</li> <li>Minimal bundle size</li> <li>Modern patterns with portability</li> </ul>"},{"location":"benchmarks/frameworks/#choose-elysia-if-you-need","title":"Choose Elysia if you need:","text":"<ul> <li>Maximum Node.js ecosystem performance</li> <li>Bun runtime advantages</li> <li>End-to-end type safety</li> <li>Cutting-edge features</li> </ul>"},{"location":"benchmarks/frameworks/#adding-new-frameworks","title":"Adding New Frameworks","text":"<p>To add a framework to the benchmark suite:</p> <ol> <li>Create app directory: <code>tools/benchmark-harness/apps/{framework-name}/</code></li> <li>Implement all workload endpoints from <code>tools/benchmark-harness/src/schema/workload.rs</code></li> <li>Match request/response schemas exactly</li> <li>Use framework's recommended production configuration</li> <li>Document framework version and dependencies</li> <li>Create <code>-raw</code> variant if validation can be disabled</li> <li>Add entry to <code>apps/README.md</code></li> <li>Test with: <code>benchmark-harness run --framework {framework-name}</code></li> </ol> <p>See existing apps for implementation examples.</p>"},{"location":"benchmarks/harness-design/","title":"Benchmark Harness Design","text":""},{"location":"benchmarks/harness-design/#overview","title":"Overview","text":"<p>The Spikard benchmark harness has two distinct use cases:</p> <ol> <li>Profiling Mode - Deep analysis of Spikard implementations for optimization</li> <li>Comparative Mode - Framework comparisons (e.g., Spikard-Python vs FastAPI)</li> </ol>"},{"location":"benchmarks/harness-design/#design-principles","title":"Design Principles","text":"<ul> <li>Schema-first: Structured JSON output for CI integration and analytics</li> <li>Composable: Run individual workloads or comprehensive suites</li> <li>Language-aware: Profile Python/Node/Ruby separately with language-specific metrics</li> <li>CI-ready: Build artifacts, historical tracking, automated analytics</li> </ul>"},{"location":"benchmarks/harness-design/#use-case-1-profiling-mode","title":"Use Case 1: Profiling Mode","text":"<p>Goal: Identify optimization opportunities in Spikard implementations</p> <p>Characteristics: - Deep profiling (CPU, memory, GIL, FFI overhead) - Per-language metrics (Python: GIL wait time, Node: V8 heap, Ruby: GC stats) - Flamegraphs and trace data - Comparative analysis (Rust baseline vs binding overhead) - Granular per-endpoint breakdown</p> <p>Example: <pre><code># Profile Python bindings with all workloads\nbenchmark-harness profile \\\n    --framework spikard-python \\\n    --app-dir apps/spikard-python-workloads \\\n    --suite all \\\n    --profiler python \\\n    --output results/spikard-python-profile.json\n\n# Profile specific workload category\nbenchmark-harness profile \\\n    --framework spikard-rust \\\n    --app-dir apps/spikard-rust \\\n    --suite json-bodies \\\n    --output results/rust-json-profile.json\n</code></pre></p> <p>Output Schema: <pre><code>{\n  \"mode\": \"profile\",\n  \"metadata\": {\n    \"framework\": \"spikard-python\",\n    \"language\": \"python\",\n    \"version\": \"0.1.0\",\n    \"timestamp\": \"2025-11-21T10:30:00Z\",\n    \"git_commit\": \"abc123\",\n    \"host\": {\n      \"os\": \"darwin\",\n      \"arch\": \"arm64\",\n      \"cpu_model\": \"Apple M2 Pro\",\n      \"cpu_cores\": 12,\n      \"memory_gb\": 32\n    }\n  },\n  \"configuration\": {\n    \"duration_secs\": 10,\n    \"concurrency\": 50,\n    \"warmup_secs\": 3\n  },\n  \"suites\": [\n    {\n      \"name\": \"json-bodies\",\n      \"workloads\": [\n        {\n          \"name\": \"json-small\",\n          \"payload_size_bytes\": 86,\n          \"endpoint\": {\n            \"method\": \"POST\",\n            \"path\": \"/json/small\"\n          },\n          \"results\": {\n            \"throughput\": {\n              \"requests_per_sec\": 59358.24,\n              \"bytes_per_sec\": 5104908.64,\n              \"total_requests\": 593582,\n              \"successful_requests\": 593582,\n              \"failed_requests\": 0,\n              \"success_rate\": 1.0\n            },\n            \"latency\": {\n              \"mean_ms\": 0.84,\n              \"median_ms\": 0.76,\n              \"p90_ms\": 1.23,\n              \"p95_ms\": 1.54,\n              \"p99_ms\": 2.87,\n              \"p999_ms\": 5.12,\n              \"min_ms\": 0.22,\n              \"max_ms\": 50.07,\n              \"stddev_ms\": 0.42\n            },\n            \"resources\": {\n              \"cpu\": {\n                \"avg_percent\": 78.5,\n                \"peak_percent\": 95.2,\n                \"p95_percent\": 92.1\n              },\n              \"memory\": {\n                \"avg_mb\": 45.3,\n                \"peak_mb\": 52.1,\n                \"p95_mb\": 50.8\n              }\n            },\n            \"profiling\": {\n              \"python\": {\n                \"gil_wait_time_ms\": 234.5,\n                \"gil_contention_percent\": 12.3,\n                \"ffi_overhead_ms\": 156.7,\n                \"handler_time_ms\": 423.1,\n                \"serialization_time_ms\": 89.2,\n                \"gc_collections\": 45,\n                \"gc_time_ms\": 23.4\n              }\n            }\n          }\n        }\n      ]\n    }\n  ],\n  \"summary\": {\n    \"total_workloads\": 15,\n    \"total_requests\": 8902350,\n    \"overall_success_rate\": 1.0,\n    \"avg_requests_per_sec\": 29674.5,\n    \"total_duration_secs\": 150\n  },\n  \"comparison\": {\n    \"rust_baseline\": {\n      \"requests_per_sec\": 159515.0,\n      \"ratio\": 2.68\n    }\n  }\n}\n</code></pre></p>"},{"location":"benchmarks/harness-design/#use-case-2-comparative-mode","title":"Use Case 2: Comparative Mode","text":"<p>Goal: Compare Spikard against other frameworks in the same ecosystem</p> <p>Characteristics: - Multiple frameworks tested with identical workloads - Apples-to-apples comparison - Statistical significance testing - Performance regression detection - Framework-specific metadata (versions, runtimes)</p> <p>Example: <pre><code># Compare Python frameworks\nbenchmark-harness compare \\\n    --frameworks spikard-python,fastapi,robyn \\\n    --suite all \\\n    --output results/python-frameworks-comparison.json\n\n# Compare specific workload\nbenchmark-harness compare \\\n    --frameworks spikard-python,fastapi-granian \\\n    --suite json-bodies \\\n    --output results/json-comparison.json\n</code></pre></p> <p>Output Schema: <pre><code>{\n  \"mode\": \"compare\",\n  \"metadata\": {\n    \"timestamp\": \"2025-11-21T10:30:00Z\",\n    \"git_commit\": \"abc123\",\n    \"host\": { \"...\" }\n  },\n  \"configuration\": {\n    \"duration_secs\": 10,\n    \"concurrency\": 50,\n    \"warmup_secs\": 3\n  },\n  \"frameworks\": [\n    {\n      \"name\": \"spikard-python\",\n      \"version\": \"0.1.0\",\n      \"language\": \"python\",\n      \"runtime\": \"CPython 3.12.1\",\n      \"app_dir\": \"apps/spikard-python-workloads\"\n    },\n    {\n      \"name\": \"fastapi\",\n      \"version\": \"0.115.0\",\n      \"language\": \"python\",\n      \"runtime\": \"CPython 3.12.1 + Uvicorn\",\n      \"app_dir\": \"apps/fastapi\"\n    }\n  ],\n  \"suites\": [\n    {\n      \"name\": \"json-bodies\",\n      \"workloads\": [\n        {\n          \"name\": \"json-small\",\n          \"payload_size_bytes\": 86,\n          \"endpoint\": {\n            \"method\": \"POST\",\n            \"path\": \"/json/small\"\n          },\n          \"results\": [\n            {\n              \"framework\": \"spikard-python\",\n              \"throughput\": {\n                \"requests_per_sec\": 59358.24,\n                \"success_rate\": 1.0\n              },\n              \"latency\": {\n                \"mean_ms\": 0.84,\n                \"p99_ms\": 2.87\n              }\n            },\n            {\n              \"framework\": \"fastapi\",\n              \"throughput\": {\n                \"requests_per_sec\": 12345.67,\n                \"success_rate\": 1.0\n              },\n              \"latency\": {\n                \"mean_ms\": 4.05,\n                \"p99_ms\": 12.34\n              }\n            }\n          ],\n          \"comparison\": {\n            \"winner\": \"spikard-python\",\n            \"performance_ratios\": {\n              \"spikard-python_vs_fastapi\": 4.81,\n              \"fastapi_vs_spikard-python\": 0.21\n            },\n            \"statistical_significance\": {\n              \"p_value\": 0.001,\n              \"significant\": true\n            }\n          }\n        }\n      ]\n    }\n  ],\n  \"summary\": {\n    \"overall_winner\": \"spikard-python\",\n    \"avg_performance_gain\": 3.24,\n    \"workloads_won\": {\n      \"spikard-python\": 15,\n      \"fastapi\": 0\n    }\n  }\n}\n</code></pre></p>"},{"location":"benchmarks/harness-design/#workload-suite-system","title":"Workload Suite System","text":"<p>Built-in Suites:</p> <ol> <li><code>all</code> - All workloads (default)</li> <li><code>json-bodies</code> - JSON serialization (small, medium, large, very-large)</li> <li><code>path-params</code> - Path parameter extraction (simple, multiple, deep, typed)</li> <li><code>query-params</code> - Query string parsing (few, medium, many)</li> <li><code>forms</code> - Form data (urlencoded, multipart)</li> <li><code>streaming</code> - SSE and WebSocket (future)</li> <li><code>mixed</code> - Realistic API patterns (future)</li> </ol> <p>Custom Suites: <pre><code># custom-suite.toml\nname = \"api-crud\"\ndescription = \"Common CRUD operations\"\n\n[[workloads]]\nname = \"list-items\"\nmethod = \"GET\"\npath = \"/items?page=1&amp;limit=20\"\ncategory = \"query-params\"\n\n[[workloads]]\nname = \"get-item\"\nmethod = \"GET\"\npath = \"/items/{id}\"\ncategory = \"path-params\"\n\n[[workloads]]\nname = \"create-item\"\nmethod = \"POST\"\npath = \"/items\"\ncontent_type = \"application/json\"\nbody_file = \"fixtures/item-create.json\"\ncategory = \"json-bodies\"\n</code></pre></p>"},{"location":"benchmarks/harness-design/#cli-design","title":"CLI Design","text":"<pre><code>benchmark-harness &lt;MODE&gt; [OPTIONS]\n\nModes:\n  profile   Deep profiling of a Spikard implementation\n  compare   Compare multiple frameworks\n  run       Run single benchmark (legacy, for debugging)\n\nCommon Options:\n  --suite &lt;SUITE&gt;              Workload suite (all, json-bodies, etc.) [default: all]\n  --duration &lt;SECS&gt;            Benchmark duration per workload [default: 10]\n  --concurrency &lt;N&gt;            Concurrent connections [default: 50]\n  --warmup &lt;SECS&gt;              Warmup duration [default: 3]\n  --output &lt;FILE&gt;              JSON output file\n  --format &lt;FORMAT&gt;            Output format (json, json-pretty, table) [default: json-pretty]\n\nProfile Mode:\n  benchmark-harness profile [OPTIONS]\n    --framework &lt;NAME&gt;         Framework to profile (required)\n    --app-dir &lt;PATH&gt;           App directory (required)\n    --profiler &lt;TYPE&gt;          Profiler type (python, node, ruby, perf)\n    --baseline &lt;PATH&gt;          Rust baseline results for comparison\n    --flamegraph               Generate flamegraph (requires perf/py-spy)\n\nCompare Mode:\n  benchmark-harness compare [OPTIONS]\n    --frameworks &lt;LIST&gt;        Comma-separated framework names (required)\n    --apps &lt;PATH&gt;              Directory containing app subdirs (required)\n    --report &lt;FILE&gt;            Generate markdown comparison report\n\nRun Mode (Legacy):\n  benchmark-harness run [OPTIONS]\n    --framework &lt;NAME&gt;\n    --app-dir &lt;PATH&gt;\n    --workload &lt;NAME&gt;\n</code></pre>"},{"location":"benchmarks/harness-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"benchmarks/harness-design/#phase-1-schema-data-model-current","title":"Phase 1: Schema &amp; Data Model (Current)","text":"<ul> <li> Define complete JSON schema</li> <li> Create Rust structs for all result types</li> <li> Add serialization/deserialization tests</li> <li> Document schema with JSON Schema spec</li> </ul>"},{"location":"benchmarks/harness-design/#phase-2-workload-suite-system","title":"Phase 2: Workload Suite System","text":"<ul> <li> Implement <code>WorkloadSuite</code> trait</li> <li> Add built-in suite definitions</li> <li> Custom suite loader (TOML)</li> <li> Suite validation</li> </ul>"},{"location":"benchmarks/harness-design/#phase-3-profile-mode","title":"Phase 3: Profile Mode","text":"<ul> <li> Implement profiling runner</li> <li> Python profiler integration (py-spy)</li> <li> Node profiler integration (--prof)</li> <li> Ruby profiler integration (stackprof)</li> <li> Rust baseline comparison</li> </ul>"},{"location":"benchmarks/harness-design/#phase-4-compare-mode","title":"Phase 4: Compare Mode","text":"<ul> <li> Multi-framework orchestration</li> <li> Parallel benchmark execution</li> <li> Statistical analysis (t-test)</li> <li> Markdown report generation</li> </ul>"},{"location":"benchmarks/harness-design/#phase-5-ci-integration","title":"Phase 5: CI Integration","text":"<ul> <li> GitHub Actions workflow</li> <li> Artifact storage</li> <li> Historical trend analysis</li> <li> Performance regression detection</li> <li> Auto-comment on PRs</li> </ul>"},{"location":"benchmarks/harness-design/#ci-integration-example","title":"CI Integration Example","text":"<pre><code># .github/workflows/benchmark.yml\nname: Benchmark\n\non:\n  push:\n    branches: [main]\n  pull_request:\n\njobs:\n  profile-spikard:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Build benchmark harness\n        run: cargo build --release -p benchmark-harness\n\n      - name: Profile Spikard-Python\n        run: |\n          ./target/release/benchmark-harness profile \\\n            --framework spikard-python \\\n            --app-dir tools/benchmark-harness/apps/spikard-python-workloads \\\n            --suite all \\\n            --output results/spikard-python-${{ github.sha }}.json\n\n      - name: Upload results\n        uses: actions/upload-artifact@v3\n        with:\n          name: benchmark-results\n          path: results/*.json\n\n      - name: Compare with baseline\n        run: |\n          ./tools/benchmark-harness/scripts/compare-with-baseline.sh \\\n            results/spikard-python-${{ github.sha }}.json \\\n            results/baseline/spikard-python-main.json\n\n  compare-frameworks:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Compare Python frameworks\n        run: |\n          ./target/release/benchmark-harness compare \\\n            --frameworks spikard-python,fastapi,robyn \\\n            --suite json-bodies,path-params \\\n            --output results/python-comparison-${{ github.sha }}.json \\\n            --report results/python-comparison.md\n\n      - name: Comment PR\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const fs = require('fs');\n            const report = fs.readFileSync('results/python-comparison.md', 'utf8');\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: report\n            });\n</code></pre>"},{"location":"benchmarks/harness-design/#analytics-visualization-future","title":"Analytics &amp; Visualization (Future)","text":"<p>Data Aggregation: - Time-series database (InfluxDB/TimescaleDB) - Aggregate results from CI artifacts - Track performance over time - Detect regressions automatically</p> <p>Dashboards: - Grafana dashboards showing:   - RPS trends over time   - Latency percentiles by workload   - Framework comparison matrices   - Resource utilization patterns</p> <p>Automated Reports: - Weekly performance summaries - Release performance comparisons - Optimization impact analysis - Framework ecosystem benchmarks</p>"},{"location":"benchmarks/harness-design/#file-structure","title":"File Structure","text":"<pre><code>tools/benchmark-harness/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.rs                  # CLI entry point\n\u2502   \u251c\u2500\u2500 lib.rs                   # Public API\n\u2502   \u251c\u2500\u2500 schema/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 profile.rs           # Profile mode results\n\u2502   \u2502   \u251c\u2500\u2500 compare.rs           # Compare mode results\n\u2502   \u2502   \u2514\u2500\u2500 workload.rs          # Workload definitions\n\u2502   \u251c\u2500\u2500 suite/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 builtin.rs           # Built-in suites\n\u2502   \u2502   \u251c\u2500\u2500 loader.rs            # Custom suite loader\n\u2502   \u2502   \u2514\u2500\u2500 runner.rs            # Suite execution\n\u2502   \u251c\u2500\u2500 profiler/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 python.rs            # py-spy integration\n\u2502   \u2502   \u251c\u2500\u2500 node.rs              # Node profiler\n\u2502   \u2502   \u251c\u2500\u2500 ruby.rs              # Ruby profiler\n\u2502   \u2502   \u2514\u2500\u2500 perf.rs              # Linux perf\n\u2502   \u251c\u2500\u2500 compare/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 runner.rs            # Multi-framework runner\n\u2502   \u2502   \u251c\u2500\u2500 analysis.rs          # Statistical analysis\n\u2502   \u2502   \u2514\u2500\u2500 report.rs            # Markdown generation\n\u2502   \u2514\u2500\u2500 server.rs                # Server management (existing)\n\u251c\u2500\u2500 apps/                        # Benchmark apps\n\u2502   \u251c\u2500\u2500 spikard-rust/\n\u2502   \u251c\u2500\u2500 spikard-python-workloads/\n\u2502   \u251c\u2500\u2500 axum-baseline/\n\u2502   \u251c\u2500\u2500 fastapi/\n\u2502   \u2514\u2500\u2500 robyn/\n\u251c\u2500\u2500 suites/                      # Suite definitions\n\u2502   \u251c\u2500\u2500 all.toml\n\u2502   \u251c\u2500\u2500 json-bodies.toml\n\u2502   \u2514\u2500\u2500 custom/\n\u251c\u2500\u2500 results/                     # CI artifacts (gitignored)\n\u2502   \u2514\u2500\u2500 baseline/                # Baseline results (committed)\n\u2514\u2500\u2500 docs/\n    \u251c\u2500\u2500 DESIGN.md                # This file\n    \u2514\u2500\u2500 SCHEMA.md                # JSON schema spec\n</code></pre>"},{"location":"benchmarks/harness-design/#next-steps","title":"Next Steps","text":"<ol> <li>Implement <code>schema</code> module with complete data model</li> <li>Add <code>suite</code> system with built-in definitions</li> <li>Refactor existing code to use new schema</li> <li>Implement <code>profile</code> subcommand</li> <li>Implement <code>compare</code> subcommand</li> <li>Add CI workflow</li> <li>Create analytics pipeline</li> </ol>"},{"location":"benchmarks/methodology/","title":"Benchmark Methodology","text":"<p>This document explains how Spikard benchmarks are designed, executed, and analyzed to provide meaningful, reproducible performance measurements.</p>"},{"location":"benchmarks/methodology/#design-principles","title":"Design Principles","text":""},{"location":"benchmarks/methodology/#1-fairness-and-consistency","title":"1. Fairness and Consistency","text":"<p>All frameworks are tested under identical conditions:</p> <ul> <li>Same hardware: All benchmarks run on the same machine during a single session</li> <li>Same workloads: Identical HTTP requests (headers, bodies, parameters) across frameworks</li> <li>Same configuration: Duration (30s default), concurrency (100 default), warmup (3s)</li> <li>Same tooling: Single load generator (oha or bombardier) for all frameworks</li> </ul>"},{"location":"benchmarks/methodology/#2-realistic-workloads","title":"2. Realistic Workloads","text":"<p>Benchmarks test real-world HTTP patterns rather than synthetic microbenchmarks:</p> <ul> <li>Small JSON bodies (86 bytes): Typical API responses</li> <li>Medium JSON bodies (5 KB): Detailed resource representations</li> <li>Large JSON bodies (150 KB): Bulk data transfers, file metadata</li> <li>Path parameters: RESTful resource identifiers (<code>/users/{id}</code>)</li> <li>Query parameters: Filtering, pagination, search (<code>?page=1&amp;limit=20&amp;sort=name</code>)</li> <li>Form data: Traditional web form submissions</li> </ul>"},{"location":"benchmarks/methodology/#3-statistical-rigor","title":"3. Statistical Rigor","text":"<p>Results undergo statistical analysis to distinguish meaningful differences from random variance:</p> <ul> <li>Welch's t-test: Compares mean performance between frameworks</li> <li>Significance threshold: p-value &lt; 0.05 (configurable)</li> <li>Effect size: Cohen's d measures practical significance</li> <li>Sample size: 30+ second benchmarks provide thousands of data points</li> </ul>"},{"location":"benchmarks/methodology/#4-reproducibility","title":"4. Reproducibility","text":"<p>Every result includes metadata for exact reproduction:</p> <ul> <li>Git commit hash and branch</li> <li>Host specifications (CPU model, core count, RAM)</li> <li>Framework and runtime versions</li> <li>Benchmark configuration parameters</li> <li>Timestamp in ISO 8601 format</li> </ul>"},{"location":"benchmarks/methodology/#workload-categories","title":"Workload Categories","text":""},{"location":"benchmarks/methodology/#json-bodies","title":"JSON Bodies","text":"<p>Tests JSON serialization and deserialization performance across payload sizes.</p> Workload Size Description <code>json-small</code> 86 bytes Minimal API response: <code>{\"id\": 123, \"name\": \"test\", \"active\": true}</code> <code>json-medium</code> 5 KB User profile with nested objects and arrays <code>json-large</code> 52 KB Product catalog with multiple items <code>json-very-large</code> 150 KB Bulk data export or detailed analytics payload <p>What this measures: Serialization overhead, memory allocation patterns, GC pressure from large object creation.</p>"},{"location":"benchmarks/methodology/#path-parameters","title":"Path Parameters","text":"<p>Tests URL path parsing and parameter extraction.</p> Workload Pattern Description <code>path-simple</code> <code>/users/{id}</code> Single parameter extraction <code>path-multiple</code> <code>/orgs/{org}/repos/{repo}</code> Multiple parameters <code>path-deep</code> <code>/a/{a}/b/{b}/c/{c}</code> Deep nesting <code>path-int</code> <code>/numbers/{value}</code> Integer type validation <code>path-uuid</code> <code>/items/{id}</code> UUID format validation <code>path-date</code> <code>/events/{date}</code> Date parsing <p>What this measures: Regex matching efficiency, parameter type conversion, routing table lookups.</p>"},{"location":"benchmarks/methodology/#query-parameters","title":"Query Parameters","text":"<p>Tests query string parsing with varying parameter counts.</p> Workload Parameters Description <code>query-few</code> 3 <code>?page=1&amp;limit=20&amp;sort=name</code> <code>query-medium</code> 8 Typical filtering query <code>query-many</code> 15+ Complex search with many filters <p>What this measures: Query string parser performance, parameter validation overhead, memory allocation from string splitting.</p>"},{"location":"benchmarks/methodology/#form-data","title":"Form Data","text":"<p>Tests URL-encoded form parsing (common in traditional web apps).</p> Workload Fields Description <code>form-simple</code> 4 Basic login form <code>form-complex</code> 12 User registration with address fields <p>What this measures: Form data parsing, multipart handling, file upload streaming.</p>"},{"location":"benchmarks/methodology/#multipart-uploads","title":"Multipart Uploads","text":"<p>Tests file upload handling with different file sizes.</p> Workload File Size Description <code>multipart-small</code> 1 KB Small text file <code>multipart-medium</code> 10 KB Small image <code>multipart-large</code> 100 KB Document upload <p>What this measures: Streaming performance, memory buffering, temporary file handling.</p>"},{"location":"benchmarks/methodology/#validation-overhead-analysis","title":"Validation Overhead Analysis","text":"<p>A key insight from Spikard benchmarks is measuring the cost of runtime type validation.</p>"},{"location":"benchmarks/methodology/#paired-implementations","title":"Paired Implementations","text":"<p>For selected frameworks, we maintain two variants:</p> <ul> <li>Validated: Full type checking with schema validation (msgspec, Zod, Pydantic)</li> <li>Raw: Direct JSON parsing with no validation (<code>json.loads()</code>, <code>JSON.parse()</code>)</li> </ul> <p>Examples: - <code>fastapi</code> vs <code>fastapi-raw</code> - <code>express</code> vs <code>express-raw</code> - <code>spikard-python</code> vs <code>spikard-raw</code></p>"},{"location":"benchmarks/methodology/#overhead-calculation","title":"Overhead Calculation","text":"<pre><code>validation_overhead = (raw_rps - validated_rps) / raw_rps * 100\n</code></pre> <p>Typical results: - FastAPI with Pydantic: ~40% overhead - Spikard with msgspec: ~15% overhead - Express with Zod: ~25% overhead</p> <p>This quantifies the performance cost of type safety and helps users make informed tradeoffs between safety and speed.</p>"},{"location":"benchmarks/methodology/#metrics-explained","title":"Metrics Explained","text":""},{"location":"benchmarks/methodology/#throughput","title":"Throughput","text":"<p>Requests per second (RPS): The primary performance indicator.</p> <pre><code>RPS = successful_requests / benchmark_duration_seconds\n</code></pre> <p>Higher is better. Typical ranges: - 100k+ RPS: Native Rust/Go frameworks with minimal overhead - 50k-100k RPS: Optimized Python/Node frameworks - 10k-50k RPS: Standard Python frameworks (Django, Flask) - &lt;10k RPS: Heavy frameworks or interpreted languages without optimizations</p> <p>Bytes per second: Network throughput including headers and body.</p> <pre><code>Bytes/sec = (total_bytes_sent + total_bytes_received) / duration_seconds\n</code></pre> <p>Useful for comparing large payload workloads where network I/O dominates.</p> <p>Success rate: Percentage of requests that completed successfully.</p> <pre><code>Success_rate = successful_requests / total_requests * 100\n</code></pre> <p>Should always be 100% for valid benchmarks. Lower values indicate framework errors or crashes.</p>"},{"location":"benchmarks/methodology/#latency-distribution","title":"Latency Distribution","text":"<p>Latency percentiles answer different questions:</p> <ul> <li>p50 (median): Typical user experience</li> <li>p90: Most users' experience</li> <li>p95: Nearly all users' experience</li> <li>p99: Worst-case for 99% of users</li> <li>p99.9: Extreme outliers</li> </ul> <p>Why percentiles matter: Mean latency can be misleading when a few slow requests skew the average. p99 latency is often 10x the median.</p> <p>Example interpretation: <pre><code>median: 2.5ms\np99: 45ms\n</code></pre> This means most requests are fast (2.5ms), but 1% of users experience 18x slower responses (45ms). This might indicate GC pauses or lock contention.</p>"},{"location":"benchmarks/methodology/#resource-utilization","title":"Resource Utilization","text":"<p>CPU percentage: Process CPU usage as a percentage of one core.</p> <ul> <li>100% = fully utilizing one core</li> <li>400% = utilizing four cores</li> <li>Values &gt;100% indicate multi-threaded execution</li> </ul> <p>Memory (RSS): Resident Set Size in megabytes.</p> <p>Tracks heap allocations, object creation, and memory leaks. Sharp increases during benchmarks indicate allocation pressure; gradual increases suggest leaks.</p>"},{"location":"benchmarks/methodology/#language-specific-profiling","title":"Language-Specific Profiling","text":"<p>Python metrics (collected with py-spy): - GIL wait time: Time spent waiting for Python's Global Interpreter Lock - GIL contention: Percentage of time blocked on GIL (higher = more threading overhead) - FFI overhead: Time spent crossing Python/Rust boundary - GC collections/time: Garbage collector impact</p> <p>Node.js metrics (collected with clinic.js): - V8 heap usage: Memory allocated by JavaScript objects - Event loop lag: Delay in processing new events (higher = slower async handling) - GC time: V8 garbage collection overhead</p> <p>Ruby metrics (collected with stackprof): - GC count/time: Frequency and duration of garbage collection - Heap pages: Memory allocated by Ruby VM - Live objects: Number of objects in memory</p>"},{"location":"benchmarks/methodology/#statistical-analysis","title":"Statistical Analysis","text":""},{"location":"benchmarks/methodology/#welchs-t-test","title":"Welch's t-test","text":"<p>Tests whether two frameworks have significantly different mean performance.</p> <p>Null hypothesis (H\u2080): Framework A and Framework B have equal mean RPS.</p> <p>Alternative hypothesis (H\u2081): Frameworks have different mean RPS.</p> <p>Result interpretation: - p &lt; 0.05: Reject null hypothesis, difference is statistically significant - p \u2265 0.05: Cannot reject null hypothesis, difference may be random</p>"},{"location":"benchmarks/methodology/#cohens-d-effect-size","title":"Cohen's d Effect Size","text":"<p>Measures the magnitude of performance difference in standard deviation units.</p> <pre><code>d = (mean_A - mean_B) / pooled_standard_deviation\n</code></pre> <p>Interpretation: - d &lt; 0.2: Trivial difference - d = 0.2-0.5: Small difference - d = 0.5-0.8: Medium difference - d &gt; 0.8: Large difference</p> <p>Example: <pre><code>Framework A: 50,000 RPS (\u03c3 = 1,000)\nFramework B: 45,000 RPS (\u03c3 = 1,200)\nCohen's d = 4.5 (very large effect)\n</code></pre></p>"},{"location":"benchmarks/methodology/#multiple-comparison-correction","title":"Multiple Comparison Correction","text":"<p>When comparing many frameworks, we use baseline comparison to reduce false positives:</p> <p>Instead of comparing all pairs (N\u00b2/2 comparisons), we compare each framework to a single baseline (N comparisons).</p> <p>This reduces the risk of finding \"significant\" differences by chance when running many statistical tests.</p>"},{"location":"benchmarks/methodology/#benchmark-execution","title":"Benchmark Execution","text":""},{"location":"benchmarks/methodology/#load-generator","title":"Load Generator","text":"<p>Spikard uses oha (preferred) or bombardier for load generation:</p> <pre><code>oha -z 30s -c 100 --latency-correction --disable-keepalive http://localhost:8000/endpoint\n</code></pre> <p>Parameters: - <code>-z 30s</code>: Run for 30 seconds - <code>-c 100</code>: 100 concurrent connections - <code>--latency-correction</code>: Adjust for coordinated omission - <code>--disable-keepalive</code>: Force new connections (more realistic)</p>"},{"location":"benchmarks/methodology/#warmup-period","title":"Warmup Period","text":"<p>Before measurement, a 3-second warmup period runs to: - Populate caches - Trigger JIT compilation - Stabilize CPU frequency - Initialize connection pools</p>"},{"location":"benchmarks/methodology/#server-process-management","title":"Server Process Management","text":"<p>Each framework application: 1. Spawns in isolated process 2. Waits for HTTP readiness (port listening) 3. Receives warmup traffic 4. Undergoes measured benchmark 5. Terminates cleanly</p> <p>This ensures no cross-contamination between benchmarks.</p>"},{"location":"benchmarks/methodology/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"benchmarks/methodology/#1-coordinated-omission","title":"1. Coordinated Omission","text":"<p>Problem: Load generators that pause when the server is slow underreport latency.</p> <p>Solution: Oha's <code>--latency-correction</code> flag compensates for this bias.</p>"},{"location":"benchmarks/methodology/#2-insufficient-duration","title":"2. Insufficient Duration","text":"<p>Problem: Short benchmarks (&lt; 10s) may not capture steady-state performance.</p> <p>Solution: Default 30s duration ensures stabilization. Use 60s+ for production comparisons.</p>"},{"location":"benchmarks/methodology/#3-ignoring-success-rate","title":"3. Ignoring Success Rate","text":"<p>Problem: Frameworks that drop requests appear faster due to fewer completed requests.</p> <p>Solution: Always check <code>success_rate = 1.0</code> before comparing RPS.</p>"},{"location":"benchmarks/methodology/#4-single-run-results","title":"4. Single Run Results","text":"<p>Problem: Performance varies run-to-run due to CPU throttling, background processes.</p> <p>Solution: Run multiple iterations and report median RPS with standard deviation.</p>"},{"location":"benchmarks/methodology/#5-different-runtime-versions","title":"5. Different Runtime Versions","text":"<p>Problem: Python 3.11 vs 3.12 may show 20%+ performance differences.</p> <p>Solution: Lock runtime versions in metadata and compare within same environment.</p>"},{"location":"benchmarks/methodology/#best-practices","title":"Best Practices","text":""},{"location":"benchmarks/methodology/#running-benchmarks","title":"Running Benchmarks","text":"<ol> <li>Close background applications: Disable browsers, IDEs, and other CPU-intensive processes</li> <li>Disable CPU frequency scaling: Set governor to <code>performance</code> mode</li> <li>Pin to physical cores: Use taskset to avoid hyperthreading variance</li> <li>Run multiple iterations: Execute 3-5 runs and report median</li> <li>Monitor temperature: Ensure CPU doesn't thermal throttle during benchmarks</li> </ol>"},{"location":"benchmarks/methodology/#interpreting-results","title":"Interpreting Results","text":"<ol> <li>Check success rate first: 100% successful requests required</li> <li>Compare within language: Don't compare FastAPI (Python) to Express (Node.js)</li> <li>Consider validation overhead: Raw variants show theoretical maximum</li> <li>Look at percentiles: p99 latency matters for user experience</li> <li>Read statistical significance: p-value determines if difference is real</li> </ol>"},{"location":"benchmarks/methodology/#adding-new-frameworks","title":"Adding New Frameworks","text":"<ol> <li>Implement all workload endpoints matching existing apps</li> <li>Use framework's recommended production configuration</li> <li>Enable validation if framework supports it</li> <li>Create a <code>-raw</code> variant for overhead comparison</li> <li>Document framework version and runtime in app README</li> </ol>"},{"location":"benchmarks/methodology/#future-enhancements","title":"Future Enhancements","text":"<ul> <li> Automated regression detection in CI</li> <li> Historical trend visualization</li> <li> Per-endpoint profiling with flamegraphs</li> <li> WebSocket and SSE streaming benchmarks</li> <li> Database integration workloads (PostgreSQL queries)</li> <li> Multi-region latency simulation</li> </ul>"},{"location":"benchmarks/running/","title":"Running Benchmarks","text":"<p>This guide explains how to run Spikard benchmarks locally, interpret results, and add new framework implementations.</p>"},{"location":"benchmarks/running/#prerequisites","title":"Prerequisites","text":""},{"location":"benchmarks/running/#required-tools","title":"Required Tools","text":"<ol> <li> <p>Rust toolchain (1.70+)    <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre></p> </li> <li> <p>Load generator (oha or bombardier)    <pre><code># Preferred: oha (Rust-based)\ncargo install oha\n\n# Alternative: bombardier (Go-based)\ngo install github.com/codesenberg/bombardier@latest\n</code></pre></p> </li> <li> <p>Language runtimes (for frameworks you want to test)</p> </li> <li>Python 3.10+ with uv: <code>curl -LsSf https://astral.sh/uv/install.sh | sh</code></li> <li>Node 20+ with pnpm: <code>curl -fsSL https://get.pnpm.io/install.sh | sh</code></li> <li>Ruby 3.2+ with rbenv: <code>brew install rbenv ruby-build</code></li> <li>PHP 8.2+ with composer: <code>brew install php composer</code></li> <li>Bun 1.x: <code>curl -fsSL https://bun.sh/install | bash</code></li> </ol>"},{"location":"benchmarks/running/#building-the-harness","title":"Building the Harness","text":"<pre><code>cd tools/benchmark-harness\ncargo build --release\n</code></pre> <p>The compiled binary will be at <code>target/release/benchmark-harness</code>.</p>"},{"location":"benchmarks/running/#quick-start","title":"Quick Start","text":""},{"location":"benchmarks/running/#running-a-single-framework","title":"Running a Single Framework","text":"<p>Test one framework with default settings (30s duration, 100 concurrency):</p> <pre><code>cd tools/benchmark-harness\n\n# Python framework\n./target/release/benchmark-harness run \\\n  --framework spikard-python \\\n  --app-dir apps/spikard-python\n\n# Node framework\n./target/release/benchmark-harness run \\\n  --framework fastify \\\n  --app-dir apps/fastify\n\n# Ruby framework\n./target/release/benchmark-harness run \\\n  --framework roda \\\n  --app-dir apps/roda\n</code></pre>"},{"location":"benchmarks/running/#profile-mode-with-workload-suites","title":"Profile Mode with Workload Suites","text":"<p>Run multiple workloads systematically:</p> <pre><code># All workloads (18 endpoints)\n./target/release/benchmark-harness profile \\\n  --framework spikard-python \\\n  --app-dir apps/spikard-python \\\n  --suite all \\\n  --output results/spikard-python-profile.json\n\n# Just JSON workloads\n./target/release/benchmark-harness profile \\\n  --framework fastapi \\\n  --app-dir apps/fastapi \\\n  --suite json-bodies \\\n  --output results/fastapi-json.json\n\n# Path parameter workloads\n./target/release/benchmark-harness profile \\\n  --framework spikard-node \\\n  --app-dir apps/spikard-node \\\n  --suite path-params \\\n  --output results/spikard-node-paths.json\n</code></pre>"},{"location":"benchmarks/running/#compare-mode","title":"Compare Mode","text":"<p>Compare multiple frameworks side-by-side:</p> <pre><code># Compare Python frameworks\n./target/release/benchmark-harness compare \\\n  --frameworks spikard-python,fastapi,litestar,robyn \\\n  --suite all \\\n  --output results/python-comparison\n\n# Compare with statistical significance\n./target/release/benchmark-harness compare \\\n  --frameworks spikard-python,fastapi \\\n  --suite json-bodies \\\n  --significance 0.05 \\\n  --output results/statistical-comparison\n\n# Generate markdown report\n./target/release/benchmark-harness compare \\\n  --frameworks express,fastify,hono \\\n  --suite all \\\n  --report results/nodejs-report.md\n</code></pre>"},{"location":"benchmarks/running/#command-reference","title":"Command Reference","text":""},{"location":"benchmarks/running/#common-options","title":"Common Options","text":"<pre><code>--duration &lt;SECS&gt;        Benchmark duration per workload [default: 30]\n--concurrency &lt;N&gt;        Concurrent connections [default: 100]\n--warmup &lt;SECS&gt;          Warmup duration [default: 3]\n--output &lt;FILE&gt;          JSON output file\n--format &lt;FORMAT&gt;        Output format: json, json-pretty, table [default: json-pretty]\n</code></pre>"},{"location":"benchmarks/running/#run-mode","title":"Run Mode","text":"<p>Single framework benchmark:</p> <pre><code>benchmark-harness run [OPTIONS]\n  --framework &lt;NAME&gt;     Framework name (required)\n  --app-dir &lt;PATH&gt;       App directory path (required)\n  --workload &lt;NAME&gt;      Specific workload (default: json-small)\n  --port &lt;PORT&gt;          Server port [default: 8000]\n  --host &lt;HOST&gt;          Server host [default: 127.0.0.1]\n</code></pre> <p>Example: <pre><code>./target/release/benchmark-harness run \\\n  --framework spikard-python \\\n  --app-dir apps/spikard-python \\\n  --workload json-medium \\\n  --duration 60 \\\n  --concurrency 200\n</code></pre></p>"},{"location":"benchmarks/running/#profile-mode","title":"Profile Mode","text":"<p>Deep analysis with workload suites:</p> <pre><code>benchmark-harness profile [OPTIONS]\n  --framework &lt;NAME&gt;     Framework to profile (required)\n  --app-dir &lt;PATH&gt;       App directory (required)\n  --suite &lt;SUITE&gt;        Workload suite: all, json-bodies, path-params, etc.\n  --profiler &lt;TYPE&gt;      Language profiler: python, node, ruby\n  --baseline &lt;PATH&gt;      Baseline results for comparison\n  --flamegraph           Generate flamegraph (requires profiler)\n</code></pre> <p>Example with profiling: <pre><code># Python with py-spy profiling\n./target/release/benchmark-harness profile \\\n  --framework spikard-python \\\n  --app-dir apps/spikard-python \\\n  --suite all \\\n  --profiler python \\\n  --flamegraph \\\n  --output results/profiled.json\n\n# Compare against Rust baseline\n./target/release/benchmark-harness profile \\\n  --framework spikard-python \\\n  --app-dir apps/spikard-python \\\n  --suite json-bodies \\\n  --baseline results/spikard-rust-baseline.json\n</code></pre></p>"},{"location":"benchmarks/running/#compare-mode_1","title":"Compare Mode","text":"<p>Statistical framework comparison:</p> <pre><code>benchmark-harness compare [OPTIONS]\n  --frameworks &lt;LIST&gt;    Comma-separated framework names (required)\n  --suite &lt;SUITE&gt;        Workload suite\n  --significance &lt;VAL&gt;   p-value threshold [default: 0.05]\n  --report &lt;FILE&gt;        Generate markdown report\n  --output &lt;PREFIX&gt;      Output file prefix\n</code></pre> <p>Example: <pre><code>./target/release/benchmark-harness compare \\\n  --frameworks spikard-python,fastapi,litestar,robyn \\\n  --suite all \\\n  --duration 60 \\\n  --concurrency 200 \\\n  --significance 0.05 \\\n  --report results/python-frameworks.md \\\n  --output results/python-comparison\n</code></pre></p>"},{"location":"benchmarks/running/#workload-suites","title":"Workload Suites","text":"<p>Available suites (use with <code>--suite</code> flag):</p> Suite Workloads Description <code>all</code> 18 All workloads across categories <code>json-bodies</code> 4 JSON serialization (small, medium, large, very-large) <code>path-params</code> 6 Path parameter extraction variants <code>query-params</code> 3 Query string parsing (few, medium, many) <code>forms</code> 2 URL-encoded form data <code>multipart</code> 3 File upload handling"},{"location":"benchmarks/running/#interpreting-results","title":"Interpreting Results","text":""},{"location":"benchmarks/running/#json-output-structure","title":"JSON Output Structure","text":"<pre><code>{\n  \"mode\": \"profile\",\n  \"metadata\": {\n    \"framework\": \"spikard-python\",\n    \"version\": \"0.1.0\",\n    \"timestamp\": \"2024-11-29T10:00:00Z\",\n    \"git_commit\": \"abc123\",\n    \"host\": {\n      \"cpu_model\": \"Apple M2 Pro\",\n      \"cpu_cores\": 12,\n      \"memory_gb\": 32\n    }\n  },\n  \"suites\": [\n    {\n      \"name\": \"json-bodies\",\n      \"workloads\": [\n        {\n          \"name\": \"json-small\",\n          \"results\": {\n            \"throughput\": {\n              \"requests_per_sec\": 59358.24,\n              \"success_rate\": 1.0\n            },\n            \"latency\": {\n              \"mean_ms\": 0.84,\n              \"p99_ms\": 2.87\n            },\n            \"resources\": {\n              \"cpu\": { \"avg_percent\": 78.5 },\n              \"memory\": { \"avg_mb\": 45.3 }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"benchmarks/running/#key-metrics","title":"Key Metrics","text":"<p>Requests per second (RPS): - Primary performance indicator - Higher is better - Compare within language ecosystems</p> <p>Success rate: - Must be 1.0 (100%) for valid results - Lower values indicate errors or crashes</p> <p>Latency percentiles: - <code>p50</code> (median): Typical request latency - <code>p99</code>: 99% of requests complete within this time - <code>p99.9</code>: Extreme outliers</p> <p>Resource usage: - <code>cpu.avg_percent</code>: Average CPU utilization - <code>memory.avg_mb</code>: Average memory consumption</p>"},{"location":"benchmarks/running/#compare-mode-output","title":"Compare Mode Output","text":"<pre><code>{\n  \"mode\": \"compare\",\n  \"frameworks\": [\n    {\"name\": \"spikard-python\", \"version\": \"0.1.0\"},\n    {\"name\": \"fastapi\", \"version\": \"0.115.0\"}\n  ],\n  \"suites\": [\n    {\n      \"name\": \"json-bodies\",\n      \"workloads\": [\n        {\n          \"name\": \"json-small\",\n          \"results\": [\n            {\"framework\": \"spikard-python\", \"throughput\": {\"requests_per_sec\": 59358}},\n            {\"framework\": \"fastapi\", \"throughput\": {\"requests_per_sec\": 21456}}\n          ],\n          \"comparison\": {\n            \"winner\": \"spikard-python\",\n            \"performance_ratios\": {\"spikard-python_vs_fastapi\": 2.77},\n            \"statistical_significance\": {\"p_value\": 0.001, \"significant\": true}\n          }\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"benchmarks/running/#best-practices","title":"Best Practices","text":""},{"location":"benchmarks/running/#preparation","title":"Preparation","text":"<ol> <li>Close unnecessary applications: Browsers, IDEs, and background services can skew results</li> <li>Disable CPU throttling: Set CPU governor to performance mode    <pre><code># Linux\nsudo cpupower frequency-set -g performance\n\n# macOS\nsudo pmset -a cpufreq high\n</code></pre></li> <li>Monitor temperature: Ensure CPU doesn't thermal throttle during benchmarks</li> <li>Use dedicated hardware: Avoid running benchmarks on development machines</li> </ol>"},{"location":"benchmarks/running/#running-benchmarks_1","title":"Running Benchmarks","text":"<ol> <li>Use longer durations: 30-60 seconds for stable results</li> <li>Multiple iterations: Run 3-5 times and report median</li> <li>Check success rate: Always verify 100% success before comparing</li> <li>Warm up properly: Default 3s warmup is usually sufficient</li> </ol>"},{"location":"benchmarks/running/#comparing-results","title":"Comparing Results","text":"<ol> <li>Same hardware: Run all comparisons on the same machine</li> <li>Same configuration: Use identical duration and concurrency settings</li> <li>Check statistical significance: Use p-value &lt; 0.05 threshold</li> <li>Consider effect size: Large performance differences are more meaningful</li> <li>Compare within ecosystem: Don't compare Python to Rust directly</li> </ol>"},{"location":"benchmarks/running/#adding-new-frameworks","title":"Adding New Frameworks","text":""},{"location":"benchmarks/running/#1-create-app-directory","title":"1. Create App Directory","text":"<pre><code>mkdir tools/benchmark-harness/apps/my-framework\ncd tools/benchmark-harness/apps/my-framework\n</code></pre>"},{"location":"benchmarks/running/#2-implement-required-endpoints","title":"2. Implement Required Endpoints","text":"<p>Your framework must implement all workload endpoints. See <code>tools/benchmark-harness/src/schema/workload.rs</code> for definitions.</p> <p>Minimum required endpoints:</p> <pre><code>POST /json/small          - 86 byte JSON response\nPOST /json/medium         - 5 KB JSON response\nPOST /json/large          - 52 KB JSON response\nPOST /json/very-large     - 150 KB JSON response\n\nGET  /path/simple/{id}    - Extract path parameter\nGET  /path/multiple/{org}/{repo}\nGET  /path/deep/{a}/{b}/{c}\nGET  /path/int/{value}    - Parse integer\nGET  /path/uuid/{id}      - Validate UUID\nGET  /path/date/{date}    - Parse date\n\nGET  /query/few?page=1&amp;limit=20&amp;sort=name\nGET  /query/medium?...    - 8 parameters\nGET  /query/many?...      - 15+ parameters\n\nPOST /form/simple         - URL-encoded form (4 fields)\nPOST /form/complex        - URL-encoded form (12 fields)\n</code></pre>"},{"location":"benchmarks/running/#3-configuration-file","title":"3. Configuration File","text":"<p>Create <code>app.json</code> or framework-specific config:</p> <pre><code>{\n  \"name\": \"my-framework\",\n  \"version\": \"1.0.0\",\n  \"language\": \"python\",\n  \"runtime\": \"CPython 3.12\",\n  \"validation\": \"custom-validator\",\n  \"start_command\": \"python main.py\",\n  \"port\": 8000,\n  \"readiness_path\": \"/health\"\n}\n</code></pre>"},{"location":"benchmarks/running/#4-test-locally","title":"4. Test Locally","text":"<pre><code># Start your app manually\ncd tools/benchmark-harness/apps/my-framework\npython main.py  # or equivalent\n\n# In another terminal, test endpoints\ncurl -X POST http://localhost:8000/json/small\ncurl http://localhost:8000/path/simple/123\n</code></pre>"},{"location":"benchmarks/running/#5-run-benchmark","title":"5. Run Benchmark","text":"<pre><code>cd tools/benchmark-harness\n./target/release/benchmark-harness run \\\n  --framework my-framework \\\n  --app-dir apps/my-framework\n</code></pre>"},{"location":"benchmarks/running/#6-create-raw-variant-optional","title":"6. Create Raw Variant (Optional)","text":"<p>For validation overhead analysis, create a <code>-raw</code> variant:</p> <pre><code>cp -r apps/my-framework apps/my-framework-raw\n# Edit apps/my-framework-raw to disable validation\n</code></pre>"},{"location":"benchmarks/running/#7-document","title":"7. Document","text":"<p>Add entry to <code>apps/README.md</code> with: - Framework description - Dependencies and versions - Setup instructions - Special notes</p>"},{"location":"benchmarks/running/#troubleshooting","title":"Troubleshooting","text":""},{"location":"benchmarks/running/#port-already-in-use","title":"\"Port already in use\"","text":"<pre><code># Find process using port 8000\nlsof -ti:8000 | xargs kill -9\n\n# Or use different port\n./target/release/benchmark-harness run \\\n  --framework my-framework \\\n  --port 8001\n</code></pre>"},{"location":"benchmarks/running/#framework-failed-to-start","title":"\"Framework failed to start\"","text":"<p>Check app logs: <pre><code>cd apps/my-framework\npython main.py  # Run manually to see errors\n</code></pre></p> <p>Common causes: - Missing dependencies - Wrong Python/Node version - Port already in use - File permissions</p>"},{"location":"benchmarks/running/#success-rate-100","title":"\"Success rate &lt; 100%\"","text":"<p>Framework is returning errors. Check: 1. Endpoint implementations match expected schemas 2. Validation isn't rejecting valid requests 3. Server isn't crashing under load</p>"},{"location":"benchmarks/running/#inconsistent-results-between-runs","title":"\"Inconsistent results between runs\"","text":"<p>Multiple factors can cause variance: 1. CPU thermal throttling 2. Background processes 3. Network buffering 4. Garbage collection timing</p> <p>Solutions: - Run longer benchmarks (60s+) - Close background apps - Run multiple iterations - Use dedicated benchmark hardware</p>"},{"location":"benchmarks/running/#environment-variables","title":"Environment Variables","text":"<p>Control benchmark behavior:</p> <pre><code># Override load generator\nexport LOAD_GENERATOR=bombardier  # or oha\n\n# Profiler paths\nexport PY_SPY_PATH=/path/to/py-spy\nexport CLINIC_PATH=/path/to/clinic\n\n# Output verbosity\nexport RUST_LOG=debug\n</code></pre>"},{"location":"benchmarks/running/#ci-integration","title":"CI Integration","text":"<p>For automated benchmarking in CI:</p> <pre><code># .github/workflows/benchmark.yml\n- name: Run benchmarks\n  run: |\n    cd tools/benchmark-harness\n    cargo build --release\n    ./target/release/benchmark-harness compare \\\n      --frameworks spikard-python,fastapi \\\n      --suite all \\\n      --output results/ci-benchmark.json\n\n- name: Upload results\n  uses: actions/upload-artifact@v3\n  with:\n    name: benchmark-results\n    path: tools/benchmark-harness/results/\n</code></pre>"},{"location":"benchmarks/running/#next-steps","title":"Next Steps","text":"<ul> <li>Understand benchmark methodology</li> <li>Review benchmarked frameworks</li> <li>Read harness design docs</li> </ul>"},{"location":"bindings/python/","title":"Python Binding","text":"<p>Spikard\u2019s Python binding uses PyO3 with msgspec-first validation. Decorators feel like FastAPI/Litestar while the Rust core handles routing, middleware, and streaming.</p>"},{"location":"bindings/python/#quickstart","title":"Quickstart","text":"<pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\nclass User(Struct):\n    id: int\n    name: str\n\napp = Spikard()\n\n@app.get(\"/users/{id:int}\")\nasync def get_user(id: int) -&gt; User:\n    return User(id=id, name=\"Alice\")\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre>"},{"location":"bindings/python/#validation","title":"Validation","text":"<ul> <li>msgspec (default): fastest; use <code>Struct</code> types for request/response validation.</li> <li>Pydantic v2 / dataclasses / TypedDict / attrs: auto-detected when used as handler params.</li> </ul> <pre><code>from msgspec import Struct\n\nclass Payment(Struct):\n    id: str\n    amount: float\n\n@app.post(\"/payments\")\nasync def create_payment(payment: Payment) -&gt; Payment:\n    return payment\n</code></pre>"},{"location":"bindings/python/#lifecycle-hooks","title":"Lifecycle hooks","text":"<pre><code>@app.on_request\nasync def logging_hook(request: dict[str, object]):\n    print(f\"{request['method']} {request['path']}\")\n    return request\n</code></pre>"},{"location":"bindings/python/#requests-responses","title":"Requests &amp; Responses","text":"<ul> <li>Typed params: <code>Query</code>, <code>Path</code>, <code>Header</code>, <code>Cookie</code> helpers available.</li> <li>Bodies: <code>msgspec.Struct</code> (recommended) or other supported types.</li> <li>Responses: return Python objects/Structs; the runtime serializes.</li> </ul>"},{"location":"bindings/python/#deployment","title":"Deployment","text":"<ul> <li>Local: <code>python app.py</code>.</li> <li>Production: build with the binding and set <code>SPIKARD_PORT</code>/<code>SPIKARD_HOST</code> via env.</li> </ul>"},{"location":"bindings/python/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure Python 3.11+ and Rust toolchain are installed.</li> <li>If you see GIL-related errors, upgrade <code>spikard</code> and re-run <code>uv sync</code>; the binding uses a dedicated asyncio loop.</li> </ul>"},{"location":"bindings/ruby/","title":"Ruby Binding","text":"<p>Ruby binding built on Magnus. Handlers receive path params, query params, and body arguments (or a request hash when using helper wrappers); dry-schema provides validation, and responses are plain Ruby hashes/objects.</p>"},{"location":"bindings/ruby/#quickstart","title":"Quickstart","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get \"/health\" do |_params, _query, _body|\n  { status: \"ok\" }\nend\n\napp.run(port: 8000)\n</code></pre>"},{"location":"bindings/ruby/#validation-dry-schema","title":"Validation (dry-schema)","text":"<pre><code>require \"dry-schema\"\nDry::Schema.load_extensions(:json_schema)\n\nUserSchema = Dry::Schema.JSON do\n  required(:name).filled(:str?)\n  required(:email).filled(:str?)\nend\n\napp.post \"/users\", request_schema: UserSchema do |_params, _query, body|\n  { id: 1, name: body[\"name\"], email: body[\"email\"] }\nend\n</code></pre>"},{"location":"bindings/ruby/#requests-responses","title":"Requests &amp; Responses","text":"<ul> <li>Request hash keys: <code>:method</code>, <code>:path</code>, <code>:path_params</code>, <code>:query</code>, <code>:raw_query</code>, <code>:headers</code>, <code>:cookies</code>, <code>:body</code>, <code>:params</code> (merged).</li> <li>Return Ruby hashes/arrays; the runtime serializes.</li> </ul>"},{"location":"bindings/ruby/#lifecycle-hooks","title":"Lifecycle hooks","text":"<pre><code>app.on_request do |request|\n  puts \"#{request[:method]} #{request[:path]}\"\n  request\nend\n</code></pre>"},{"location":"bindings/ruby/#deployment","title":"Deployment","text":"<ul> <li>Local: <code>ruby app.rb</code>.</li> <li>Native extension requires Ruby 3.2+ and a Rust toolchain; ensure <code>bundle exec rake ext:build</code> has been run.</li> </ul>"},{"location":"bindings/ruby/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If build fails, confirm Rust is on PATH and <code>bundle config set build.spikard --with-cflags=\"-std=c++17\"</code> where needed.</li> <li>For schema errors, ensure <code>dry-schema</code> is installed and extension <code>:json_schema</code> loaded.</li> </ul>"},{"location":"bindings/rust/","title":"Rust Binding","text":"<p>Use Spikard natively for zero-FFI routing, validation, and streaming. The Rust API mirrors binding ergonomics while exposing full Axum/Tower power.</p>"},{"location":"bindings/rust/#quickstart","title":"Quickstart","text":"<pre><code>use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::prelude::*;\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct User {\n    id: i32,\n    name: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut app = App::new();\n\n    app.route(get(\"/users/:id\"), |ctx: Context| async move {\n        let id: i32 = ctx.path_param(\"id\").unwrap_or(\"0\").parse().unwrap_or_default();\n        Ok(Json(User { id, name: \"Alice\".into() }))\n    })?;\n\n    app.route(\n        post(\"/users\").request_body::&lt;User&gt;().response_body::&lt;User&gt;(),\n        |ctx: Context| async move {\n            let user: User = ctx.json()?;\n            Ok(Json(user))\n        },\n    )?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"bindings/rust/#validation","title":"Validation","text":"<ul> <li>Derive <code>JsonSchema</code> (schemars) to register request/response schemas.</li> <li>Accept raw JSON Schema via <code>request_schema_json</code> when needed.</li> </ul>"},{"location":"bindings/rust/#middleware-hooks","title":"Middleware &amp; Hooks","text":"<ul> <li>Add Tower layers via <code>.layer(...)</code> or use <code>ServerConfig</code> lifecycle hooks for request/response interception.</li> <li>WebSockets: <code>app.websocket(\"/ws\", handler)</code>; SSE via <code>app.sse</code>.</li> </ul>"},{"location":"bindings/rust/#testing","title":"Testing","text":"<ul> <li>Use <code>spikard::testing::TestServer</code> for in-memory integration tests.</li> </ul>"},{"location":"bindings/rust/#deployment","title":"Deployment","text":"<ul> <li>Add <code>spikard</code> to your Cargo manifest and run with <code>cargo run</code>.</li> <li>Configure host/port/timeouts via <code>ServerConfig</code>.</li> </ul>"},{"location":"bindings/typescript/","title":"TypeScript / Node Binding","text":"<p>Node/Bun binding built with NAPI-RS. Use <code>Spikard.addRoute</code> metadata or method decorators (<code>get</code>, <code>post</code>, etc.) plus Zod schemas for validation.</p>"},{"location":"bindings/typescript/#quickstart-metadata","title":"Quickstart (metadata)","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nconst app = new Spikard();\n\nconst getUser = async (req: Request): Promise&lt;User&gt; =&gt; {\n  const segments = req.path.split(\"/\");\n  const id = Number(segments[segments.length - 1] ?? 0);\n  return { id, name: \"Alice\" };\n};\n\napp.addRoute(\n  { method: \"GET\", path: \"/users/:id\", handler_name: \"getUser\", is_async: true },\n  getUser,\n);\n\napp.run({ port: 8000 });\n</code></pre> <p>Decorators (<code>get</code>, <code>post</code>, etc.) are available for metadata-only definitions, but the recommended path today is explicit <code>addRoute</code> with Zod schemas as above to avoid ambiguity about handler registration. For Deno/Edge runtimes, use <code>spikard-wasm</code> and <code>createFetchHandler</code>. WebSocket helpers are in progress; use HTTP/SSE until the public API ships.</p>"},{"location":"bindings/typescript/#request-shape","title":"Request shape","text":"<ul> <li><code>method</code>, <code>path</code>, <code>params</code>, <code>query</code>, <code>headers</code> (lowercased), <code>cookies</code>, <code>body</code></li> <li>Helpers: <code>json()</code> (with UploadFile conversion), <code>form()</code></li> </ul>"},{"location":"bindings/typescript/#validation","title":"Validation","text":"<ul> <li>Zod (recommended) with <code>bodySchema</code>/<code>responseSchema</code> metadata.</li> <li>JSON Schema objects supported as alternatives.</li> </ul>"},{"location":"bindings/typescript/#middleware-hooks","title":"Middleware &amp; Hooks","text":"<ul> <li>Use lifecycle hooks: <code>app.onRequest</code>, <code>app.preValidation</code>, <code>app.onResponse</code>, <code>app.onError</code>.</li> <li>Handlers receive <code>Request</code> with parsed params/query/cookies/headers; wrappers are optional.</li> </ul>"},{"location":"bindings/typescript/#deployment","title":"Deployment","text":"<ul> <li>Local: <code>node app.js</code>/<code>ts-node app.ts</code>; set <code>PORT</code> via <code>app.run({ port })</code>.</li> <li>Containers: build native module ahead of time (<code>pnpm build:native</code>) to avoid runtime compilation.</li> <li> <p>WASM/Deno/Edge: use <code>spikard-wasm</code> and <code>createFetchHandler</code> for fetch-based runtimes:</p> <pre><code>import { Spikard, get, createFetchHandler } from \"spikard-wasm\";\nimport { z } from \"zod\";\n\nconst app = new Spikard();\n\nget(\"/hello\")(async () =&gt; ({ message: \"Hello from the edge!\" }));\n\nconst UserSchema = z.object({ name: z.string(), email: z.string().email() });\n\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\npost(\"/users\", { bodySchema: UserSchema })(async (req) =&gt; {\n  const user = req.json&lt;User&gt;();\n  return { id: 1, ...user };\n});\n\nexport default {\n  fetch: createFetchHandler(app),\n};\n</code></pre> </li> </ul>"},{"location":"bindings/typescript/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Requires Node 20+; ensure Rust toolchain for native builds.</li> <li>If params aren\u2019t parsed, double-check <code>path</code> pattern (<code>/users/:id</code>) and handler names.</li> </ul>"},{"location":"bindings/wasm/","title":"WASM / Edge Binding","text":"<p>Use <code>spikard-wasm</code> for runtimes without native modules (Deno, Cloudflare Workers, edge workers, browsers). It mirrors the Node binding but exposes fetch-style handlers.</p>"},{"location":"bindings/wasm/#quickstart-fetch-handler","title":"Quickstart (fetch handler)","text":"<pre><code>import { Spikard, get, createFetchHandler } from \"spikard-wasm\";\nimport { z } from \"zod\";\n\nconst app = new Spikard();\n\nget(\"/hello\")(async () =&gt; ({ message: \"Hello from the edge!\" }));\n\nconst UserSchema = z.object({ name: z.string(), email: z.string().email() });\n\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\npost(\"/users\", { bodySchema: UserSchema })(async (req) =&gt; {\n  const user = req.json&lt;User&gt;();\n  return { id: 1, ...user };\n});\n\nexport default {\n  fetch: createFetchHandler(app),\n};\n</code></pre>"},{"location":"bindings/wasm/#validation","title":"Validation","text":"<ul> <li>Zod schemas work the same as in Node; pass <code>bodySchema</code>/<code>responseSchema</code> to decorators or register schemas on routes.</li> </ul>"},{"location":"bindings/wasm/#deployment","title":"Deployment","text":"<ul> <li>Cloudflare Workers: export <code>fetch</code> handler from your module; bundle via Wrangler.</li> <li> <p>Deno: use the fetch-style handler:</p> <pre><code>import { Spikard, get } from \"npm:spikard-wasm\";\n\nconst app = new Spikard();\n\nget(\"/hello\")(async () =&gt; ({ message: \"Hello from Deno\" }));\n\nDeno.serve({ port: 8000 }, (request) =&gt; app.handleRequest(request));\n</code></pre> </li> <li> <p>Browsers: TestClient and in-memory handlers are available for local logic; production WS/SSE depends on host support.</p> </li> </ul>"},{"location":"bindings/wasm/#notes","title":"Notes","text":"<ul> <li>Uses fetch-native APIs; no Node globals.</li> <li>WebSockets/SSE availability depends on the host runtime; stick to HTTP/SSE on platforms without WS support.</li> <li>Keep payloads small; worker environments often have stricter limits.</li> </ul>"},{"location":"cli/usage/","title":"CLI Usage","text":"<p><code>spikard-cli</code> handles code generation and schema validation for DTOs and handlers.</p>"},{"location":"cli/usage/#install","title":"Install","text":"<pre><code>cargo install spikard-cli\n</code></pre>"},{"location":"cli/usage/#run-an-app","title":"Run an App","text":"<p>Runtime serving from the CLI is planned. Today, start apps with the binding APIs: - Python: <code>python app.py</code> - TypeScript: <code>node app.js</code> or <code>bun run app.ts</code> - Ruby: <code>ruby app.rb</code></p>"},{"location":"cli/usage/#generate-code","title":"Generate Code","text":"<p>Use the CLI to generate DTOs/handlers from contracts (OpenAPI/AsyncAPI): <pre><code>spikard generate openapi ./openapi.yaml --lang python --output ./generated\nspikard generate openapi ./openapi.yaml --lang typescript --output ./generated\n</code></pre> Generated code stays aligned with the runtime schemas and fixture-based tests.</p>"},{"location":"cli/usage/#development-notes","title":"Development Notes","text":"<ul> <li>Build locally with <code>cargo build -p spikard-cli</code> or <code>task build:cli</code>.</li> <li>End-to-end scenarios run via <code>cargo run --package spikard-cli -- run examples/app.py</code>.</li> <li>The CLI inherits workspace lint/format settings; run <code>cargo fmt</code>/<code>cargo clippy</code> before publishing.</li> </ul>"},{"location":"concepts/architecture-diagram/","title":"Architecture diagram","text":"<pre><code>graph TD\n  subgraph Client\n    A[Client]\n  end\n\n  subgraph RustCore[Rust Core]\n    B[Axum Router]\n    C[Middleware Stack]\n    D[Validation]\n    E[Binding Bridge]\n  end\n\n  subgraph PythonBinding[Python Binding]\n    F[PyO3\n    + msgspec]\n  end\n\n  subgraph NodeBinding[TypeScript Binding]\n    G[NAPI-RS\n    + Zod]\n  end\n\n  subgraph RubyBinding[Ruby Binding]\n    H[Magnus\n    + dry-schema]\n  end\n\n  subgraph RustNative[Rust API]\n    I[Handlers]\n  end\n\n  A --&gt; B --&gt; C --&gt; D --&gt; E\n  E --&gt; F\n  E --&gt; G\n  E --&gt; H\n  E --&gt; I</code></pre>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>Spikard splits concerns between a Rust core and language-specific bindings so teams can mix runtimes without re-implementing the platform.</p>"},{"location":"concepts/architecture/#layers","title":"Layers","text":"<ul> <li>Rust core (<code>crates/spikard</code>) \u2013 routing, middleware, request parsing, streaming, and error handling.</li> <li>Binding crates (<code>crates/spikard-py</code>, <code>crates/spikard-node</code>, <code>crates/spikard-rb</code>, <code>crates/spikard-wasm</code>) \u2013 expose idiomatic APIs per language while delegating execution to the Rust runtime.</li> <li>CLI (<code>crates/spikard-cli</code>) \u2013 entrypoint that boots the HTTP server, loads binding code, and orchestrates code generation.</li> <li>Codegen (<code>crates/spikard-codegen</code>, <code>tools/test-generator</code>) \u2013 generates DTOs/handlers and fixture-driven tests from OpenAPI/AsyncAPI contracts.</li> </ul>"},{"location":"concepts/architecture/#design-principles","title":"Design Principles","text":"<ul> <li>One runtime, many languages \u2013 identical semantics for routing, validation, middleware, and streaming regardless of binding.</li> <li>Contract-first \u2013 JSON Schema and generated DTOs keep request/response shapes consistent across bindings.</li> <li>Performance with safety \u2013 Tokio/Axum base, zero-copy where possible, and strict validation before handler invocation.</li> <li>Extensibility \u2013 middleware hooks and plugin points allow cross-cutting behavior without forked frameworks.</li> </ul>"},{"location":"concepts/architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Inbound request hits the Rust HTTP server.</li> <li>Routing and middleware run in Rust, enriching context, enforcing auth, logging, and tracing.</li> <li>Binding bridge converts the request into the language-native representation (Python <code>App</code>, TypeScript <code>App</code>, Ruby <code>App</code>, Rust <code>App</code>).</li> <li>Handler execution returns a typed value that is converted back into a canonical response (JSON, streaming body, etc.).</li> <li>Validation checks schemas on both ingress and egress when configured.</li> </ol> <p>See ADR 0001 for the original rationale and Python Binding Architecture for a deep dive into the PyO3 path.</p>"},{"location":"concepts/architecture/#high-level-flow","title":"High-level flow","text":"<pre><code>graph TD\n  subgraph Client\n    A[Client]\n  end\n\n  subgraph RustCore[Rust Core]\n    B[Axum Router]\n    C[Middleware Stack]\n    D[Validation]\n    E[Binding Bridge]\n  end\n\n  subgraph PythonBinding[Python Binding]\n    F[PyO3\n    + msgspec]\n  end\n\n  subgraph NodeBinding[TypeScript Binding]\n    G[NAPI-RS\n    + Zod]\n  end\n\n  subgraph RubyBinding[Ruby Binding]\n    H[Magnus\n    + dry-schema]\n  end\n\n  subgraph RustNative[Rust API]\n    I[Handlers]\n  end\n\n  A --&gt; B --&gt; C --&gt; D --&gt; E\n  E --&gt; F\n  E --&gt; G\n  E --&gt; H\n  E --&gt; I</code></pre>"},{"location":"concepts/middleware/","title":"Middleware &amp; Extensions","text":"<p>Middleware runs in Rust so every binding benefits from the same cross-cutting behavior while still exposing idiomatic hooks per language.</p>"},{"location":"concepts/middleware/#responsibilities","title":"Responsibilities","text":"<ul> <li>Logging and tracing (OpenTelemetry-first)</li> <li>Authentication and authorization guards</li> <li>Request context enrichment (request IDs, correlation IDs, tenant info)</li> <li>Response shaping (compression, CORS, caching headers)</li> </ul>"},{"location":"concepts/middleware/#writing-middleware","title":"Writing Middleware","text":"<ul> <li>Rust: implement a Tower layer and add it to the <code>App</code> pipeline.</li> <li>Python/TypeScript/Ruby: register middleware via the binding API; handlers receive a shared context object that carries values injected by upstream layers.</li> <li>Async support: middleware can short-circuit, mutate the context, or emit streaming responses.</li> </ul>"},{"location":"concepts/middleware/#extensibility-points","title":"Extensibility Points","text":"<ul> <li>Custom extractors/injectors for typed parameters</li> <li>Pre/post hooks around handler execution (see Lifecycle Hooks ADR)</li> <li>Per-route middleware stacks for sensitive endpoints</li> </ul> <p>The runtime/middleware split is described in ADR 0002.</p>"},{"location":"concepts/runtime/","title":"Runtime Model","text":"<p>The runtime is designed to keep language bindings thin while centralizing concurrency, IO, and lifecycle management in Rust.</p>"},{"location":"concepts/runtime/#execution-threads","title":"Execution Threads","text":"<ul> <li>Main Tokio runtime \u2013 accepts connections, runs Axum router + middleware, and orchestrates background tasks.</li> <li>Binding bridges \u2013 per-language glue that converts requests/responses and coordinates async execution (e.g., Python event loop thread).</li> <li>Worker pools \u2013 CPU-bound tasks can be offloaded via <code>spawn_blocking</code> or binding-specific pools to keep the async reactor responsive.</li> </ul>"},{"location":"concepts/runtime/#lifecycle","title":"Lifecycle","text":"<ol> <li>Bootstrap: CLI or host app creates an <code>App</code> and registers routes/middleware.</li> <li>Serve: Runtime binds to a socket, initializes tracing/logging, and configures graceful shutdown.</li> <li>Handle: Each request passes through middleware, validation, and the binding bridge before reaching user code.</li> <li>Shutdown: Drains in-flight requests, flushes telemetry, and tears down binding-specific resources.</li> </ol>"},{"location":"concepts/runtime/#configuration-surface","title":"Configuration Surface","text":"<ul> <li>Server: host, port, TLS (planned), concurrency limits, timeouts.</li> <li>Middleware: logging, tracing, auth, CORS, compression, and custom layers.</li> <li>Validation: JSON Schema enforcement with language-native type hints and DTOs.</li> <li>Codegen hooks: generate DTOs/handlers and keep fixtures in sync with OpenAPI/AsyncAPI specs.</li> </ul> <p>More detail on the binding side lives in Runtime and Middleware ADR.</p>"},{"location":"concepts/streaming/","title":"Streaming &amp; Async IO","text":"<p>Spikard treats streaming and real-time protocols as first-class citizens so the same APIs work for HTTP, WebSocket, and SSE flows.</p>"},{"location":"concepts/streaming/#capabilities","title":"Capabilities","text":"<ul> <li>WebSockets: bidirectional handlers with typed messages and backpressure-aware send/receive loops.</li> <li>Server-Sent Events: push event streams with graceful client disconnect handling.</li> <li>Chunked responses: stream files or long-running computations without buffering everything in memory.</li> </ul>"},{"location":"concepts/streaming/#concurrency-model","title":"Concurrency Model","text":"<ul> <li>Built on Tokio with cooperative scheduling</li> <li>Binding bridges expose async primitives that map to the language runtime (e.g., Python event loop thread, Node async iterators)</li> <li>Cancellation and shutdown signals propagate through middleware and handlers</li> </ul>"},{"location":"concepts/streaming/#validation-for-streaming","title":"Validation for Streaming","text":"<ul> <li>Envelope/message schemas validated per message when configured</li> <li>Connection-level auth and capability checks enforced in middleware before the handler executes</li> </ul> <p>More details and decisions live in ADR 0006.</p>"},{"location":"concepts/validation/","title":"Validation Engine","text":"<p>Validation is contract-first: JSON Schema shapes everything from handler signatures to generated clients and tests.</p>"},{"location":"concepts/validation/#principles","title":"Principles","text":"<ul> <li>Schema everywhere \u2013 request bodies, params, headers, cookies, and responses validate against JSON Schema.</li> <li>Language-native types \u2013 msgspec/Pydantic (Python), Zod/TypeScript types, serde (Rust), and RBS (Ruby) stay aligned with the canonical schema.</li> <li>Fail fast \u2013 invalid inputs never reach handlers; responses are checked before being sent back.</li> </ul>"},{"location":"concepts/validation/#sources-of-truth","title":"Sources of Truth","text":"<ul> <li>Code-first: derive schemas from DTOs in each language and register them with the runtime.</li> <li>Spec-first: feed OpenAPI/AsyncAPI into the CLI to generate DTOs/handlers, fixtures, and contract tests.</li> </ul>"},{"location":"concepts/validation/#error-model","title":"Error Model","text":"<ul> <li>Standardized error payloads with RFC 9457 alignment</li> <li>Clear pointer paths to failing fields and a consistent status code strategy (400/422 for validation, 500 for unhandled errors)</li> </ul> <p>For implementation notes and trade-offs, see ADR 0003.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Spikard ships a Rust core plus bindings for Python, TypeScript/Node, and Ruby. Install only what you need; every binding shares the same runtime behavior.</p>"},{"location":"getting-started/installation/#install-by-binding","title":"Install by binding","text":"PythonTypeScript / NodeRubyRust <pre><code>pip install spikard\n</code></pre> <pre><code>npm install spikard\n# or\npnpm add spikard\n</code></pre> <pre><code>gem install spikard\n</code></pre> <pre><code>cargo add spikard\n</code></pre>"},{"location":"getting-started/installation/#cli","title":"CLI","text":"<p>Install the CLI for code generation and schema validation:</p> <pre><code>cargo install spikard-cli\n</code></pre>"},{"location":"getting-started/installation/#local-repo-setup","title":"Local repo setup","text":"<p>The repo uses <code>uv</code> to manage Python deps and pnpm for JavaScript:</p> <pre><code># install all languages + hooks\ntask setup\n\n# or only the Python/Node deps needed for docs\nuv sync --group docs --group doc --no-install-workspace\npnpm install --frozen-lockfile\n</code></pre> <p>When working on docs locally, run <code>task docs:serve</code> to launch MkDocs Material with live reload.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Build the same minimal service in each binding. Choose a tab, copy the snippet, and run.</p>"},{"location":"getting-started/quickstart/#define-routes","title":"Define routes","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\nclass User(Struct):\n    id: int\n    name: str\n\napp = Spikard()\n\n@app.get(\"/users/{id:int}\")\nasync def get_user(id: int) -&gt; User:\n    return User(id=id, name=\"Alice\")\n\n@app.post(\"/users\")\nasync def create_user(user: User) -&gt; User:\n    return user\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/users/:id\", handler_name: \"getUser\", is_async: true },\n  async (req: Request): Promise&lt;User&gt; =&gt; {\n    const id = Number(req.params[\"id\"] ?? 0);\n    return { id, name: \"Alice\" };\n  },\n);\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/users\",\n    handler_name: \"createUser\",\n    request_schema: UserSchema,\n    response_schema: UserSchema,\n    is_async: true,\n  },\n  async (req: Request): Promise&lt;User&gt; =&gt; UserSchema.parse(req.json()),\n);\n\nif (require.main === module) {\n  app.run({ port: 8000 });\n}\n</code></pre> <pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get(\"/users/:id\") do |params, _query, _body|\n  { id: params[:id].to_i, name: \"Alice\" }\nend\n\napp.post(\"/users\") do |_params, _query, body|\n  user = body\n  { id: user[\"id\"], name: user[\"name\"] }\nend\n\napp.run(port: 8000)\n</code></pre> <pre><code>use axum::response::Json;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::{get, post, App, RequestContext};\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct User {\n    id: i64,\n    name: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut app = App::new();\n\n    app.route(get(\"/users/:id\"), |ctx: RequestContext| async move {\n        let id = ctx.path_param(\"id\").unwrap_or(\"0\").parse::&lt;i64&gt;().unwrap_or_default();\n        Ok(Json(User { id, name: \"Alice\".into() }).into())\n    })?;\n\n    app.route(\n        post(\"/users\").request_body::&lt;User&gt;().response_body::&lt;User&gt;(),\n        |ctx: RequestContext| async move {\n            let user: User = ctx.json()?;\n            Ok(Json(user).into())\n        },\n    )?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/quickstart/#run-it","title":"Run it","text":"<ul> <li>Python: <code>python app.py</code></li> <li>TypeScript: <code>pnpm ts-node app.ts</code> (or your runtime of choice), then hit <code>http://localhost:8000/users/1</code></li> <li>Ruby: <code>ruby app.rb</code></li> <li>Rust: <code>cargo run</code> inside your crate/binary</li> </ul>"},{"location":"getting-started/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Add middleware (logging, auth, tracing) with the same signature in every binding.</li> <li>Wire JSON Schema validation so request/response contracts stay enforced.</li> <li>Deploy using the Rust binary, the CLI, or container images (see Deployment).</li> </ul>"},{"location":"guides/configuration/","title":"Configuration","text":"<p>Spikard favors code-based configuration with environment overrides. The same knobs exist regardless of binding.</p>"},{"location":"guides/configuration/#server-settings","title":"Server Settings","text":"<ul> <li><code>host</code> / <code>port</code> \u2013 network binding for the HTTP server</li> <li><code>workers</code> \u2013 concurrency; defaults to the Tokio runtime defaults</li> <li><code>keep_alive</code> / <code>request_timeout</code> \u2013 tune to match upstream load balancers</li> </ul>"},{"location":"guides/configuration/#middleware-defaults","title":"Middleware Defaults","text":"<ul> <li>Logging/tracing enabled by default with request IDs</li> <li>CORS/compression configurable per app or per route</li> <li>Add custom middleware to inject tenant data, auth, or feature flags</li> </ul>"},{"location":"guides/configuration/#validation-controls","title":"Validation Controls","text":"<ul> <li>Enable/disable request and response validation globally or per route</li> <li>Provide JSON Schemas or rely on derived DTOs</li> <li>Customize error formatting for clients</li> </ul>"},{"location":"guides/configuration/#environment-overrides","title":"Environment Overrides","text":"<ul> <li>Prefer env vars for deploy-time changes (e.g., <code>SPIKARD_PORT=8080</code>)</li> <li>Keep secrets (API keys, DSNs) in env or secret managers; middleware can pull them into context</li> </ul> <p>A detailed option matrix will live in Reference: Configuration. Use the Taskfile (<code>task docs:serve</code>) to iterate on examples locally.</p>"},{"location":"guides/dependency-injection/","title":"Dependency Injection","text":"<p>Register shared services once and inject them into handlers by name. Value dependencies are singletons; factory dependencies can be request-scoped (cacheable) or singletons.</p>"},{"location":"guides/dependency-injection/#register-dependencies","title":"Register dependencies","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard\nfrom spikard.di import Provide\n\napp = Spikard()\n\n# Value dependency (singleton)\napp.provide(\"config\", {\"db_url\": \"postgresql://localhost/app\"})\n\n# Factory dependency (depends on config, cached globally)\nasync def make_pool(config: dict[str, str]):\n    return {\"url\": config[\"db_url\"], \"client\": \"pool\"}\n\napp.provide(\"db_pool\", Provide(make_pool, depends_on=[\"config\"], singleton=True))\n\n@app.get(\"/stats\")\nasync def stats(config: dict[str, str], db_pool):\n    return {\"db\": db_pool[\"url\"], \"env\": config[\"db_url\"]}\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\n\nconst app = new Spikard();\n\n// Value dependency (singleton)\napp.provide(\"config\", { dbUrl: \"postgresql://localhost/app\" });\n\n// Factory dependency (depends on config, singleton)\napp.provide(\n  \"dbPool\",\n  async ({ config }) =&gt; {\n    // connect using config.dbUrl\n    return { url: config.dbUrl, driver: \"pool\" };\n  },\n  { dependsOn: [\"config\"], singleton: true },\n);\n\napp.addRoute(\n  { method: \"GET\", path: \"/stats\", handler_name: \"stats\", is_async: true },\n  async (req: Request) =&gt; {\n    const deps = req.dependencies ?? {};\n    return { db: deps.dbPool?.url, env: deps.config?.dbUrl };\n  },\n);\n</code></pre> <pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\n# Value dependency (singleton)\napp.provide(\"config\", { \"db_url\" =&gt; \"postgresql://localhost/app\" })\n\n# Factory dependency (depends on config, singleton)\napp.provide(\"db_pool\", depends_on: [\"config\"], singleton: true) do |config:|\n  { url: config[\"db_url\"], client: \"pool\" }\nend\n\napp.get(\"/stats\") do |_params, _query, _body, config:, db_pool:|\n  { db: db_pool[:url], env: config[\"db_url\"] }\nend\n</code></pre> <pre><code>use axum::response::Json;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::{get, App, RequestContext};\nuse spikard_http::ServerConfig;\nuse std::sync::Arc;\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct Health {\n    db: String,\n    env: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Register dependencies on the server config\n    let config = ServerConfig::builder()\n        .provide_value(\"config\", \"postgresql://localhost/app\".to_string())\n        .provide_factory(\"db_pool\", |resolved| async move {\n            let url: Arc&lt;String&gt; = resolved.get(\"config\").ok_or(\"missing config\")?;\n            Ok(format!(\"pool({})\", url))\n        })\n        .build();\n\n    let mut app = App::new().config(config);\n\n    app.route(get(\"/stats\"), |ctx: RequestContext| async move {\n        let deps = ctx.dependencies();\n        let db = deps.and_then(|d| d.get::&lt;String&gt;(\"db_pool\")).cloned().unwrap_or_default();\n        let env = deps\n            .and_then(|d| d.get::&lt;String&gt;(\"config\"))\n            .cloned()\n            .unwrap_or_else(|| \"unknown\".to_string());\n        Ok(Json(Health { db, env }).into())\n    })?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"guides/dependency-injection/#notes","title":"Notes","text":"<ul> <li>Value dependencies are cached globally. Use factories for per-request values and set <code>cacheable</code>/<code>use_cache</code> when you need a fresh value each time.</li> <li>Factories can depend on other dependencies; unresolved or circular graphs fail fast with clear errors.</li> <li>Cleanup generators (Python) and singleton toggles (TypeScript/Ruby) mirror the core DI engine semantics.</li> </ul>"},{"location":"guides/deployment/","title":"Deployment","text":"<p>Spikard can run as a compiled Rust binary, via the CLI, or packaged into containers. Pick the surface that matches your stack; the runtime behavior stays the same.</p>"},{"location":"guides/deployment/#local-run-options","title":"Local run options","text":"CLIRust binaryTypeScriptPython <p>Runtime serving via CLI is planned. Start your binding directly, e.g. <code>python app.py</code>.</p> <pre><code>cargo run --bin spikard-http -- --port 8000\n</code></pre> <pre><code>pnpm ts-node app.ts\n</code></pre> <pre><code>python app.py\n</code></pre>"},{"location":"guides/deployment/#production-tips","title":"Production tips","text":"<ul> <li>Set explicit <code>host</code>/<code>port</code> and timeouts; avoid relying on defaults in container platforms.</li> <li>Enable structured logging + tracing (OTel recommended) and forward request IDs.</li> <li>Run health checks against a lightweight endpoint with minimal middleware.</li> <li>Use the Taskfile to build bindings before containerizing (<code>task build</code> or targeted language tasks).</li> </ul>"},{"location":"guides/deployment/#versioned-docs-config","title":"Versioned docs &amp; config","text":"<ul> <li>Publish docs with <code>task docs:publish</code> after syncing schemas/code.</li> <li>Keep configuration declarative and environment-driven (see Configuration).</li> </ul>"},{"location":"guides/deployment/#example-dockerfile-sketch","title":"Example Dockerfile sketch","text":"<pre><code>FROM rust:1.79-slim AS build\nWORKDIR /app\nCOPY . .\nRUN cargo build --release -p spikard-http\n\nFROM debian:bookworm-slim\nWORKDIR /app\nCOPY --from=build /app/target/release/spikard-http /usr/local/bin/spikard\nENV SPIKARD_PORT=8080\nCMD [\"spikard\", \"--port\", \"8080\"]\n</code></pre> <p>Adjust packages/runtime depending on whether you run the CLI or embed routes in Rust.</p>"},{"location":"guides/middleware/","title":"Middleware","text":"<p>Middleware is the right place for cross-cutting behavior like logging, auth, or request shaping. The API mirrors per-language conventions but calls into the same Rust pipeline.</p>"},{"location":"guides/middleware/#add-middleware","title":"Add middleware","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard\n\napp = Spikard()\n\n@app.on_request\nasync def logging_hook(request):\n    print(f\"{request['method']} {request['path']}\")\n    return request\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\n\nconst app = new Spikard();\n\napp.onRequest(async (request: Request): Promise&lt;Request&gt; =&gt; {\n  console.log(`${request.method} ${request.path}`);\n  return request;\n});\n</code></pre> <pre><code>app = Spikard::App.new\n\napp.on_request do |request|\n  puts \"#{request[:method]} #{request[:path]}\"\n  request\nend\n</code></pre> <pre><code>use tower_http::trace::TraceLayer;\n\nlet mut app = App::new();\napp.layer(TraceLayer::new_for_http());\n</code></pre>"},{"location":"guides/middleware/#patterns","title":"Patterns","text":"<ul> <li>Auth guards: check headers/cookies, enrich context with the authenticated principal, and short-circuit on failures.</li> <li>Observability: emit structured logs and traces; forward request IDs/correlation IDs.</li> <li>Request shaping: normalize headers, coerce params, or inject tenant/feature flags.</li> </ul>"},{"location":"guides/middleware/#tips","title":"Tips","text":"<ul> <li>Keep middleware pure and side-effect free when possible; expensive IO should be async.</li> <li>Prefer per-route middleware for sensitive endpoints.</li> <li>Use shared context keys to pass data to handlers; keep namespaced to avoid collisions.</li> </ul>"},{"location":"guides/requests/","title":"Requests &amp; Responses","text":"<p>Handlers receive a context object tailored to each binding but backed by the same Rust data model.</p>"},{"location":"guides/requests/#read-request-data","title":"Read request data","text":"PythonTypeScriptRubyRust <pre><code>from typing import Optional\nfrom spikard import Spikard\nfrom msgspec import Struct\n\napp = Spikard()\n\n\nclass Order(Struct):\n    id: int\n    item: str\n    quantity: int\n    verbose: bool | None = None\n\n\n@app.post(\"/orders/{order_id:int}\")\nasync def update_order(order_id: int, order: Order, verbose: Optional[bool] = False) -&gt; Order:\n    return Order(id=order_id, item=order.item, quantity=order.quantity, verbose=verbose or False)\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst OrderSchema = z.object({\n  id: z.number(),\n  item: z.string(),\n  quantity: z.number().int().positive(),\n  verbose: z.boolean().optional(),\n});\ntype Order = z.infer&lt;typeof OrderSchema&gt;;\n\nconst app = new Spikard();\n\nconst updateOrder = async (req: Request): Promise&lt;Order&gt; =&gt; {\n  const order = OrderSchema.parse(req.json());\n  return { ...order, id: Number(req.params[\"order_id\"] ?? order.id) };\n};\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/orders/:order_id\",\n    handler_name: \"updateOrder\",\n    request_schema: OrderSchema,\n    response_schema: OrderSchema,\n    is_async: true,\n  },\n  updateOrder,\n);\n</code></pre> <pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.post(\"/orders/:order_id\") do |params, query, body|\n  {\n    **body,\n    id: params[:order_id].to_i,\n    verbose: query[\"verbose\"] == \"true\",\n  }\nend\n</code></pre> <pre><code>app.route(post(\"/orders/:order_id\"), |ctx: Context| async move {\n    let mut order: serde_json::Value = ctx.json()?;\n    let id = ctx.path_param(\"order_id\").unwrap_or(\"0\");\n    let verbose: serde_json::Value = ctx.query().unwrap_or_default();\n    if let Some(map) = order.as_object_mut() {\n        map.insert(\"id\".into(), serde_json::json!(id.parse::&lt;i64&gt;().unwrap_or_default()));\n        map.insert(\"verbose\".into(), verbose.get(\"verbose\").cloned().unwrap_or(serde_json::json!(false)));\n    }\n    Ok(Json(order))\n})?;\n</code></pre>"},{"location":"guides/requests/#return-responses","title":"Return responses","text":"PythonTypeScriptRubyRust <pre><code>@app.get(\"/health\")\nasync def health() -&gt; dict:\n    return {\"status\": \"ok\"}\n</code></pre> <pre><code>import { Spikard } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/health\", handler_name: \"health\", is_async: true },\n  async () =&gt; ({ status: \"ok\" }),\n);\n</code></pre> <pre><code>app = Spikard::App.new\n\napp.get(\"/health\") { |_params, _query, _body| { status: \"ok\" } }\n</code></pre> <pre><code>app.route(get(\"/health\"), |_ctx: Context| async {\n    Ok(Json(serde_json::json!({\"status\": \"ok\"})))\n})?;\n</code></pre>"},{"location":"guides/requests/#tips","title":"Tips","text":"<ul> <li>Use DTOs/schemas so validation runs before your handler executes.</li> <li>Prefer returning plain values/structs; the runtime will serialize and set content types.</li> <li>For streaming/WebSocket/SSE, see the streaming section in the concepts docs.</li> </ul>"},{"location":"guides/routing/","title":"Routing Basics","text":"<p>Routing is uniform across bindings: create an app, register routes with typed parameters, and return typed responses.</p>"},{"location":"guides/routing/#declare-routes","title":"Declare routes","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\n\nclass User(Struct):\n    id: int\n    name: str\n\napp = Spikard()\n\n@app.get(\"/health\")\nasync def health() -&gt; dict:\n    return {\"status\": \"ok\"}\n\n@app.post(\"/users\")\nasync def create_user(user: User) -&gt; User:\n    return user\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nconst app = new Spikard();\n\nconst health = async (): Promise&lt;{ status: string }&gt; =&gt; ({ status: \"ok\" });\n\nconst createUser = async (req: Request): Promise&lt;User&gt; =&gt; {\n  return UserSchema.parse(req.json());\n};\n\napp.addRoute(\n  { method: \"GET\", path: \"/health\", handler_name: \"health\", is_async: true },\n  health,\n);\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/users\",\n    handler_name: \"createUser\",\n    request_schema: UserSchema,\n    response_schema: UserSchema,\n    is_async: true,\n  },\n  createUser,\n);\n</code></pre> <pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get(\"/health\") { |_params, _query, _body| { status: \"ok\" } }\napp.post(\"/users\") { |_params, _query, body| body }\n</code></pre> <pre><code>use spikard::prelude::*;\n\nlet mut app = App::new();\n\napp.route(get(\"/health\"), |_ctx: Context| async { Ok(Json(json!({\"status\": \"ok\"}))) })?;\napp.route(post(\"/users\"), |ctx: Context| async move {\n    let user: serde_json::Value = ctx.json()?;\n    Ok(Json(user))\n})?;\n</code></pre>"},{"location":"guides/routing/#path-and-query-params","title":"Path and query params","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\napp = Spikard()\n\n\nclass OrderResponse(Struct):\n    id: int\n    details: bool\n\n\n@app.get(\"/orders/{order_id:int}\")\nasync def get_order(order_id: int, include_details: bool = False) -&gt; OrderResponse:\n    return OrderResponse(id=order_id, details=include_details)\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\n\ninterface OrderResponse {\n  id: number;\n  details: boolean;\n}\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/orders/:order_id\", handler_name: \"getOrder\", is_async: true },\n  async (req: Request): Promise&lt;OrderResponse&gt; =&gt; {\n    const id = Number(req.params[\"order_id\"] ?? 0);\n    const details = req.query[\"details\"] === \"true\";\n    return { id, details };\n  },\n);\n</code></pre> <pre><code>app = Spikard::App.new\n\napp.get(\"/orders/:order_id\") do |params, query, _body|\n  {\n    id: params[:order_id].to_i,\n    details: query[\"details\"] == \"true\",\n  }\nend\n</code></pre> <pre><code>app.route(get(\"/orders/:order_id\"), |ctx: Context| async move {\n    let id = ctx.path_param(\"order_id\").unwrap_or(\"0\");\n    let details: serde_json::Value = ctx.query().unwrap_or_default();\n    Ok(Json(json!({\n        \"id\": id.parse::&lt;i64&gt;().unwrap_or_default(),\n        \"details\": details.get(\"details\").and_then(|d| d.as_bool()).unwrap_or(false)\n    })))\n})?;\n</code></pre>"},{"location":"guides/routing/#best-practices","title":"Best practices","text":"<ul> <li>Keep handlers small and pure; push IO into services.</li> <li>Prefer DTOs for shared schemas so codegen can derive OpenAPI/AsyncAPI.</li> <li>Use per-route middleware when sensitive endpoints need extra auth/logging.</li> </ul>"},{"location":"guides/validation/","title":"Validation Flows","text":"<p>Validation keeps handlers simple by enforcing contracts at the edge.</p>"},{"location":"guides/validation/#validate-requests","title":"Validate requests","text":"PythonTypeScriptRubyRust <pre><code>from msgspec import Struct\n\nclass Payment(Struct):\n    id: str\n    amount: float\n\n@app.post(\"/payments\")\nasync def create_payment(payment: Payment) -&gt; Payment:\n    return payment\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst PaymentSchema = z.object({\n  id: z.string().uuid(),\n  amount: z.number().positive(),\n});\ntype Payment = z.infer&lt;typeof PaymentSchema&gt;;\n\nconst app = new Spikard();\n\nconst createPayment = async (req: Request): Promise&lt;Payment&gt; =&gt; {\n  return PaymentSchema.parse(req.json());\n};\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/payments\",\n    handler_name: \"createPayment\",\n    request_schema: PaymentSchema,\n    response_schema: PaymentSchema,\n    is_async: true,\n  },\n  createPayment,\n);\n</code></pre> <pre><code>PaymentSchema = Dry::Schema.Params do\n  required(:id).filled(:string)\n  required(:amount).filled(:float)\nend\n\napp = Spikard::App.new\n\napp.post(\"/payments\") do |_params, _query, body|\n  PaymentSchema.call(body)\nend\n</code></pre> <pre><code>use schemars::JsonSchema;\nuse serde::Deserialize;\n\n#[derive(Deserialize, JsonSchema)]\nstruct Payment {\n    id: String,\n    amount: f64,\n}\n\napp.route(\n    post(\"/payments\").request_body::&lt;Payment&gt;().response_body::&lt;Payment&gt;(),\n    |ctx: Context| async move {\n        let payment: Payment = ctx.json()?;\n        Ok(Json(payment))\n    },\n)?;\n</code></pre>"},{"location":"guides/validation/#validate-responses","title":"Validate responses","text":"<p>Enable response validation on routes that require strict contracts by registering response DTOs/schemas, as in the Rust example above. Keep schemas in version control so generated clients and fixtures stay aligned.</p>"},{"location":"guides/validation/#testing-contracts","title":"Testing contracts","text":"<ul> <li>Use the CLI generators to create fixtures/tests from OpenAPI/AsyncAPI.</li> <li>Keep schemas in version control; run <code>task test</code> to ensure parity across bindings.</li> <li>Add ADR updates when changing validation behavior.</li> </ul>"},{"location":"playbooks/auth/","title":"Auth &amp; Guards","text":"<p>Add lightweight auth/guard logic across bindings. Prefer middleware/hooks for cross-cutting checks.</p>"},{"location":"playbooks/auth/#token-check-middleware","title":"Token check middleware","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard\n\napp = Spikard()\n\n@app.pre_handler\nasync def auth_hook(request: dict[str, object]):\n    headers = request.get(\"headers\", {}) if isinstance(request, dict) else {}\n    token = headers.get(\"authorization\") if isinstance(headers, dict) else None\n    if token != \"Bearer dev-token\":\n        return {\"error\": \"unauthorized\"}, 401\n    return request\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\n\nconst app = new Spikard();\n\napp.onRequest(async (request: Request): Promise&lt;Request | { statusCode: number; body: unknown }&gt; =&gt; {\n  const token = request.headers[\"authorization\"];\n  if (token !== \"Bearer dev-token\") {\n    return { statusCode: 401, body: { error: \"unauthorized\" } };\n  }\n  return request;\n});\n</code></pre> <pre><code>app = Spikard::App.new\n\napp.pre_handler do |request|\n  headers = request[:headers] || {}\n  if headers[\"authorization\"] != \"Bearer dev-token\"\n    { error: \"unauthorized\" }\n  else\n    request\n  end\nend\n</code></pre> <pre><code>use spikard::prelude::*;\nuse tower_http::auth::RequireAuthorizationLayer;\n\nlet mut app = App::new();\n\napp.layer(RequireAuthorizationLayer::bearer(\"dev-token\"));\n</code></pre>"},{"location":"playbooks/auth/#tips","title":"Tips","text":"<ul> <li>Normalize header casing before checks (bindings expose lowercased headers).</li> <li>Short-circuit unauthorized requests with a structured body.</li> <li>Add per-route middleware for sensitive endpoints (admin, payments).</li> </ul>"},{"location":"playbooks/background/","title":"Background Tasks","text":"<p>Offload non-critical work from request handlers.</p>"},{"location":"playbooks/background/#enqueue-work","title":"Enqueue work","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard, background\nfrom msgspec import Struct\n\napp = Spikard()\n\nclass User(Struct):\n    id: int\n    email: str\n\nasync def send_email(user_id: int) -&gt; None:\n    # enqueue real email send\n    print(f\"send email to {user_id}\")\n\n@app.post(\"/signup\")\nasync def signup(user: User) -&gt; User:\n    background.run(send_email(user.id))\n    return user\n</code></pre> <pre><code>import { Spikard, background } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"POST\", path: \"/signup\", handler_name: \"signup\", is_async: true },\n  async (req) =&gt; {\n    const user = req.json&lt;{ id: number; email: string }&gt;();\n    background.run(async () =&gt; {\n      console.log(`send email to ${user.id}`);\n    });\n    return user;\n  },\n);\n</code></pre> <pre><code># Use external job runners (Sidekiq/Resque) or queues for durability; avoid heavy work inside request handlers.\n</code></pre> <pre><code>use spikard::prelude::*;\nuse tokio::task;\n\napp.route(post(\"/signup\"), |ctx: Context| async move {\n    let user: serde_json::Value = ctx.json()?;\n    task::spawn(async move {\n        // send email or enqueue to external system\n    });\n    Ok(Json(user))\n})?;\n</code></pre>"},{"location":"playbooks/background/#tips","title":"Tips","text":"<ul> <li>Keep request handlers fast; enqueue email/notifications/ETL jobs instead of blocking responses.</li> <li>Prefer durable queues (Redis/SQS) over in-process threads for production workloads; the built-in helpers are best-effort and in-process.</li> <li>Ensure idempotency when retrying background tasks.</li> </ul>"},{"location":"playbooks/errors/","title":"Error Handling","text":"<p>Standardize errors so clients can rely on status codes and payload shape.</p>"},{"location":"playbooks/errors/#basic-patterns","title":"Basic patterns","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Response\n\n@app.get(\"/fail\")\nasync def fail() -&gt; Response:\n    return Response({\"error\": \"bad\"}, status=400)\n</code></pre> <pre><code>import { Spikard } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/fail\", handler_name: \"fail\", is_async: true },\n  async () =&gt; ({ statusCode: 400, body: { error: \"bad\" } }),\n);\n</code></pre> <pre><code>app.get \"/fail\" do |_request|\n  [{ error: \"bad\" }, 400]\nend\n</code></pre> <pre><code>use spikard::prelude::*;\n\napp.route(get(\"/fail\"), |_ctx: Context| async {\n    Ok(Json(json!({\"error\": \"bad\"})).with_status(StatusCode::BAD_REQUEST))\n})?;\n</code></pre>"},{"location":"playbooks/errors/#tips","title":"Tips","text":"<ul> <li>Prefer structured bodies (RFC 9457 style) with <code>type</code>, <code>title</code>, <code>detail</code>, <code>status</code> fields.</li> <li>Propagate request IDs in errors for tracing.</li> <li>Short-circuit auth/validation failures in middleware when possible.</li> </ul>"},{"location":"playbooks/logging/","title":"Logging &amp; Tracing","text":"<p>Standardize request IDs, structured logs, and tracing across bindings.</p>"},{"location":"playbooks/logging/#inject-request-ids","title":"Inject request IDs","text":"PythonTypeScriptRubyRust <pre><code>@app.on_request\nasync def request_id(request: dict[str, object]):\n    headers = request.get(\"headers\", {}) if isinstance(request, dict) else {}\n    request_id = headers.get(\"x-request-id\") or request.get(\"request_id\")\n    if isinstance(headers, dict):\n        headers = {**headers, \"x-request-id\": request_id}\n    return {**request, \"headers\": headers, \"request_id\": request_id}\n</code></pre> <pre><code>import { Spikard, type Request } from \"spikard\";\n\nconst app = new Spikard();\n\napp.onRequest(async (request: Request) =&gt; {\n  const requestId = request.headers[\"x-request-id\"] ?? crypto.randomUUID();\n  return { ...request, headers: { ...request.headers, \"x-request-id\": requestId } };\n});\n</code></pre> <pre><code>require \"securerandom\"\n\napp.on_request do |request|\n  headers = request[:headers] || {}\n  headers[\"x-request-id\"] ||= SecureRandom.uuid\n  request.merge(headers: headers)\nend\n</code></pre> <pre><code>use axum::response::Json;\nuse spikard::{get, App, RequestContext};\n\nlet mut app = App::new();\napp.route(get(\"/health\"), |_ctx: RequestContext| async move {\n    let body = serde_json::json!({ \"status\": \"ok\" });\n    Ok(Json(body).into())\n})?;\n</code></pre>"},{"location":"playbooks/logging/#tips","title":"Tips","text":"<ul> <li>Forward <code>x-request-id</code> from clients or generate one; include it in logs and errors.</li> <li>Prefer structured logs (JSON) and tracing exporters (OTel) where available.</li> <li>Keep log volume low in hot paths; push verbose data to debug-only logs.</li> </ul>"},{"location":"playbooks/streaming/","title":"Streaming &amp; Real-Time","text":"<p>Serve streaming responses (chunked, NDJSON), SSE, or WebSockets.</p>"},{"location":"playbooks/streaming/#streaming-response","title":"Streaming response","text":"PythonTypeScriptRubyRust <pre><code>from spikard import SseEvent, sse\n\n@sse(\"/events\")\nasync def events():\n    for i in range(3):\n        yield SseEvent(data={\"tick\": i})\n</code></pre> <pre><code>import { Spikard, StreamingResponse } from \"spikard\";\n\nconst app = new Spikard();\n\nasync function* makeStream() {\n  for (let i = 0; i &lt; 3; i++) {\n    yield JSON.stringify({ tick: i }) + \"\\n\";\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  }\n}\n\napp.addRoute(\n  { method: \"GET\", path: \"/stream\", handler_name: \"stream\", is_async: true },\n  async () =&gt;\n    new StreamingResponse(makeStream(), {\n      statusCode: 200,\n      headers: { \"Content-Type\": \"application/x-ndjson\" },\n    }),\n);\n</code></pre> <pre><code>require \"spikard\"\nrequire \"json\"\n\napp = Spikard::App.new\n\napp.get \"/stream\" do |_params, _query, _body|\n  Enumerator.new do |y|\n    3.times do |i|\n      y &lt;&lt; JSON.dump({ tick: i }) + \"\\n\"\n      sleep 0.1\n    end\n  end\nend\n</code></pre> <pre><code>use spikard::prelude::*;\nuse tokio_stream::StreamExt;\n\napp.route(get(\"/stream\"), |_ctx: Context| async move {\n    let stream = tokio_stream::iter(0..3).map(|i| {\n        serde_json::to_vec(&amp;serde_json::json!({ \"tick\": i })).unwrap()\n    });\n    Ok(StreamingBody::new(stream))\n})?;\n</code></pre>"},{"location":"playbooks/streaming/#tips","title":"Tips","text":"<ul> <li>Set appropriate content types (<code>application/x-ndjson</code>, <code>text/event-stream</code>).</li> <li>Handle client disconnects gracefully; stop producing when the connection closes.</li> <li>For WebSockets/SSE, add auth middleware before handler execution.</li> </ul>"},{"location":"playbooks/streaming/#websockets","title":"WebSockets","text":"PythonRust <pre><code>from spikard import Spikard, websocket\n\napp = Spikard()\n\n@websocket(\"/ws\")\nasync def echo(socket):\n    async for message in socket:\n        await socket.send_json({\"echo\": message})\n</code></pre> <pre><code>use spikard::prelude::*;\nuse futures::StreamExt;\n\napp.websocket(\"/ws\", |mut socket| async move {\n    while let Some(msg) = socket.next().await {\n        let text = msg.unwrap_or_default();\n        socket.send(text).await.ok();\n    }\n});\n</code></pre> TypeScript <p>WebSocket support is available via <code>method: \"WS\"</code> handlers and the test client <code>websocketConnect</code>.</p> Ruby <pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\nclass ChatHandler &lt; Spikard::WebSocketHandler\n  def handle_message(message)\n    # Echo JSON message back\n    message\n  end\nend\n\napp.websocket(\"/chat\") { ChatHandler.new }\n</code></pre>"},{"location":"playbooks/streaming/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard, SseEvent, sse\n\napp = Spikard()\n\n@sse(\"/events\")\nasync def events():\n    for i in range(3):\n        yield SseEvent(data={\"tick\": i})\n</code></pre> <pre><code>import { Spikard, StreamingResponse } from \"spikard\";\n\nconst app = new Spikard();\n\nasync function* sseStream() {\n  for (let i = 0; i &lt; 3; i++) {\n    yield `data: ${JSON.stringify({ tick: i })}\\n\\n`;\n  }\n}\n\napp.addRoute(\n  { method: \"GET\", path: \"/events\", handler_name: \"events\", is_async: true },\n  async () =&gt;\n    new StreamingResponse(sseStream(), {\n      statusCode: 200,\n      headers: { \"Content-Type\": \"text/event-stream\" },\n    }),\n);\n</code></pre> <pre><code>require \"spikard\"\nrequire \"json\"\n\napp = Spikard::App.new\n\napp.get \"/events\" do |_params, _query, _body|\n  Enumerator.new do |y|\n    3.times do |i|\n      y &lt;&lt; \"data: #{JSON.dump({ tick: i })}\\n\\n\"\n      sleep 0.1\n    end\n  end\nend\n</code></pre> <pre><code>use spikard::prelude::*;\nuse tokio_stream::StreamExt;\n\napp.route(get(\"/events\"), |_ctx: Context| async move {\n    let stream = tokio_stream::iter(0..3).map(|i| {\n        format!(\"data: {}\\n\\n\", serde_json::json!({\"tick\": i}))\n    });\n    Ok(StreamingBody::new(stream).with_header(\"content-type\", \"text/event-stream\"))\n})?;\n</code></pre>"},{"location":"playbooks/uploads/","title":"File Uploads","text":"<p>Handle multipart uploads with consistent patterns per binding.</p>"},{"location":"playbooks/uploads/#upload-handler","title":"Upload handler","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Spikard, UploadFile\n\napp = Spikard()\n\n@app.post(\"/upload\")\nasync def upload(file: UploadFile) -&gt; dict:\n    content = file.read()\n    return {\"filename\": file.filename, \"size\": len(content)}\n</code></pre> <pre><code>import { Spikard } from \"spikard\";\nimport { UploadFile } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"POST\", path: \"/upload\", handler_name: \"upload\", is_async: true },\n  async (req) =&gt; {\n    const body = req.json&lt;{ file: UploadFile; description?: string }&gt;();\n    const size = body.file.size;\n    return { filename: body.file.filename, size };\n  },\n);\n</code></pre> <pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.post \"/upload\" do |_params, _query, body|\n  file = body[\"file\"]\n  { filename: file[:filename], size: file[:tempfile].size }\nend\n</code></pre> <pre><code>use spikard::prelude::*;\nuse spikard::UploadFile;\n\napp.route(post(\"/upload\"), |ctx: Context| async move {\n    let upload: UploadFile = ctx.json()?;\n    Ok(Json(json!({ \"filename\": upload.filename, \"size\": upload.size })))\n})?;\n</code></pre>"},{"location":"playbooks/uploads/#tips","title":"Tips","text":"<ul> <li>Enforce size/type limits via middleware or schema where supported.</li> <li>For large uploads, stream chunks instead of reading all bytes into memory.</li> <li>Return metadata (filename, size, type) and store bytes in durable storage.</li> </ul>"},{"location":"python/architecture/","title":"Python Binding Architecture","text":"<p>This document describes the architecture of Spikard's Python bindings, focusing on how Python handlers integrate with the Rust-powered HTTP server.</p>"},{"location":"python/architecture/#overview","title":"Overview","text":"<p>Spikard's Python bindings use PyO3 to provide a Pythonic API for building web services while leveraging Rust's performance for HTTP handling. The core design principle is Rust drives, Python handles: the Rust layer manages the HTTP server, routing, and middleware, while Python code implements business logic.</p>"},{"location":"python/architecture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Spikard Application                       \u2502\n\u2502                  (packages/python/spikard/)                  \u2502\n\u2502                                                               \u2502\n\u2502  @app.get(\"/users\")                                          \u2502\n\u2502  async def get_users() -&gt; list[User]:                        \u2502\n\u2502      return await db.fetch_all_users()                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u2502 PyO3 FFI Boundary\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Rust HTTP Server Layer                     \u2502\n\u2502                  (crates/spikard-py/src/)                    \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Axum Server (Main Thread - Tokio Runtime)            \u2502  \u2502\n\u2502  \u2502  \u2022 HTTP request parsing                                \u2502  \u2502\n\u2502  \u2502  \u2022 Routing &amp; middleware                                \u2502  \u2502\n\u2502  \u2502  \u2022 Connection management                               \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                \u2502                          \u2502                   \u2502\n\u2502                \u25bc                          \u25bc                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Blocking Thread Pool \u2502  \u2502 Python Event Loop Thread     \u2502 \u2502\n\u2502  \u2502 (tokio::spawn_       \u2502  \u2502 (Dedicated Daemon)           \u2502 \u2502\n\u2502  \u2502  blocking)           \u2502  \u2502                              \u2502 \u2502\n\u2502  \u2502                      \u2502  \u2502 \u2022 asyncio.run_forever()      \u2502 \u2502\n\u2502  \u2502 \u2022 Acquire GIL        \u2502  \u2502 \u2022 uvloop integration         \u2502 \u2502\n\u2502  \u2502 \u2022 Call Python        \u2502  \u2502 \u2022 Executes async handlers    \u2502 \u2502\n\u2502  \u2502 \u2022 Submit coroutines  \u2502  \u2502                              \u2502 \u2502\n\u2502  \u2502 \u2022 Wait for results   \u2502  \u2502                              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"python/architecture/#threading-model","title":"Threading Model","text":"<p>Spikard uses a multi-threaded architecture with specialized thread types:</p>"},{"location":"python/architecture/#1-main-thread-tokio-runtime","title":"1. Main Thread (Tokio Runtime)","text":"<ul> <li>Runs the Axum HTTP server</li> <li>Handles incoming connections and HTTP parsing</li> <li>Manages request routing and middleware execution</li> <li>Delegates to blocking threads for Python handler invocation</li> </ul>"},{"location":"python/architecture/#2-blocking-thread-pool","title":"2. Blocking Thread Pool","text":"<ul> <li>Tokio's <code>spawn_blocking</code> thread pool</li> <li>Used for all Python handler invocations (sync and async)</li> <li>Acquires the GIL to call Python code</li> <li>For async handlers: submits coroutines to the event loop thread</li> </ul>"},{"location":"python/architecture/#3-python-event-loop-thread-dedicated-daemon","title":"3. Python Event Loop Thread (Dedicated Daemon)","text":"<ul> <li>Created at server startup in <code>init_python_event_loop()</code> (handler.rs:34-73)</li> <li>Runs <code>asyncio.run_forever()</code> in an infinite loop</li> <li>Uses uvloop if available for enhanced performance</li> <li>Executes all async Python handler coroutines</li> <li>Thread-safe via <code>asyncio.run_coroutine_threadsafe()</code></li> </ul>"},{"location":"python/architecture/#request-flow","title":"Request Flow","text":""},{"location":"python/architecture/#synchronous-handler-flow","title":"Synchronous Handler Flow","text":"<pre><code>HTTP Request\n    \u2193\nAxum Router (Tokio)\n    \u2193\ntokio::spawn_blocking()\n    \u2193\nAcquire GIL\n    \u2193\nCall Python Handler \u2192 handler(**kwargs)\n    \u2193\nReturn Value\n    \u2193\nConvert to Rust ResponseResult\n    \u2193\nRelease GIL\n    \u2193\nHTTP Response\n</code></pre> <p>Implementation: <code>handler.rs:242-272</code></p>"},{"location":"python/architecture/#asynchronous-handler-flow","title":"Asynchronous Handler Flow","text":"<pre><code>HTTP Request\n    \u2193\nAxum Router (Tokio)\n    \u2193\ntokio::spawn_blocking()\n    \u2193\nAcquire GIL\n    \u2193\nCall Python Handler \u2192 Returns Coroutine\n    \u2193\nasyncio.run_coroutine_threadsafe(coro, loop)\n    \u2193                              \u2502\n    \u2502                              \u25bc\n    \u2502                    Python Event Loop Thread\n    \u2502                    Executes Coroutine\n    \u2502                              \u2502\n    \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502      concurrent.futures.Future\n    \u2193\nfuture.result() (blocks, GIL released)\n    \u2193\nConvert to Rust ResponseResult\n    \u2193\nRelease GIL\n    \u2193\nHTTP Response\n</code></pre> <p>Implementation: <code>handler.rs:177-241</code></p> <p>Key Code Locations: - Event loop initialization: <code>handler.rs:34-73</code> - Async handler execution: <code>handler.rs:177-241</code> - Coroutine submission: <code>handler.rs:212-213</code> - Result blocking: <code>handler.rs:216</code></p>"},{"location":"python/architecture/#key-components","title":"Key Components","text":""},{"location":"python/architecture/#1-event-loop-management","title":"1. Event Loop Management","text":"<p>The Python event loop is created once at server startup and runs continuously in a daemon thread:</p> <pre><code>// crates/spikard-py/src/handler.rs:34-73\npub fn init_python_event_loop() -&gt; PyResult&lt;()&gt; {\n    Python::attach(|py| {\n        // Install uvloop if available\n        if let Ok(uvloop) = py.import(\"uvloop\") {\n            uvloop.call_method0(\"install\")?;\n        }\n\n        // Create event loop\n        let asyncio = py.import(\"asyncio\")?;\n        let event_loop = asyncio.call_method0(\"new_event_loop\")?;\n\n        // Store globally\n        PYTHON_EVENT_LOOP.set(event_loop.into())?;\n\n        // Start daemon thread running loop.run_forever()\n        let threading = py.import(\"threading\")?;\n        // ... thread creation code ...\n    })\n}\n</code></pre>"},{"location":"python/architecture/#2-coroutine-submission","title":"2. Coroutine Submission","text":"<p>Async handlers submit coroutines to the event loop thread using Python's thread-safe API:</p> <pre><code>// crates/spikard-py/src/handler.rs:212-216\nlet future = asyncio.call_method1(\n    \"run_coroutine_threadsafe\",\n    (coroutine, loop_obj)\n)?;\n\n// Blocks until coroutine completes, GIL is released during wait\nlet result = future.call_method0(\"result\")?;\n</code></pre> <p>This uses Python's <code>asyncio.run_coroutine_threadsafe()</code> which returns a <code>concurrent.futures.Future</code>. The calling thread blocks on <code>future.result()</code>, releasing the GIL while waiting.</p>"},{"location":"python/architecture/#3-zero-copy-json-conversion","title":"3. Zero-Copy JSON Conversion","text":"<p>For performance, JSON values are converted directly from <code>serde_json::Value</code> to Python objects without intermediate string serialization:</p> <pre><code>// crates/spikard-py/src/handler.rs:json_to_python()\nmatch value {\n    Value::Object(map) =&gt; {\n        let dict = PyDict::new(py);\n        for (k, v) in map {\n            dict.set_item(k, json_to_python(py, v)?)?;\n        }\n        Ok(dict.into())\n    }\n    // ... other types ...\n}\n</code></pre> <p>Reference: See <code>docs/design/msgspec-type-conversion.md</code> for detailed type mappings.</p>"},{"location":"python/architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"python/architecture/#advantages","title":"Advantages","text":"<p>\u2705 Single Persistent Event Loop: Created once at startup, eliminating per-request event loop creation overhead (30-40% improvement over previous <code>asyncio.run()</code> approach)</p> <p>\u2705 uvloop Integration: Automatically uses uvloop when available for high-performance async I/O operations</p> <p>\u2705 Zero-Copy JSON: Direct Python object construction from <code>serde_json::Value</code> without JSON string round-trips</p> <p>\u2705 Rust HTTP Layer: All HTTP parsing, routing, and middleware handled by high-performance Rust code</p> <p>\u2705 Proper GIL Management: GIL is released during async coroutine execution and I/O waits</p>"},{"location":"python/architecture/#trade-offs","title":"Trade-offs","text":"<p>\u26a0\ufe0f Thread Pool Overhead: Each request uses <code>spawn_blocking</code>, incurring thread scheduling overhead</p> <p>\u26a0\ufe0f GIL Contention: Multiple blocking threads compete for GIL when calling Python code</p> <p>\u26a0\ufe0f Cross-Thread Communication: <code>run_coroutine_threadsafe()</code> involves queue operations and thread synchronization</p> <p>\u26a0\ufe0f Blocking Wait: Calling thread blocks on <code>future.result()</code> even though async work happens elsewhere</p>"},{"location":"python/architecture/#comparison-to-alternatives","title":"Comparison to Alternatives","text":""},{"location":"python/architecture/#current-architecture-rust-driven-with-event-loop-thread","title":"Current Architecture: Rust-Driven with Event Loop Thread","text":"<pre><code>Pros:\n\u2022 Rust handles HTTP efficiently\n\u2022 Single persistent event loop\n\u2022 Works with existing Python async code\n\u2022 uvloop integration\n\nCons:\n\u2022 Thread pool overhead per request\n\u2022 GIL contention\n\u2022 Cross-thread communication cost\n</code></pre>"},{"location":"python/architecture/#alternative-1-asgi-python-driven","title":"Alternative 1: ASGI (Python-Driven)","text":"<pre><code>Pros:\n\u2022 Python manages its own event loop naturally\n\u2022 No cross-thread communication\n\u2022 Direct async integration\n\u2022 Ecosystem compatibility (ASGI middleware)\n\nCons:\n\u2022 Python drives HTTP (slower parsing/routing)\n\u2022 Loses Rust's HTTP performance benefits\n\u2022 More complex integration with Rust middleware\n</code></pre>"},{"location":"python/architecture/#alternative-2-rsgi-hybrid","title":"Alternative 2: RSGI (Hybrid)","text":"<pre><code>Pros:\n\u2022 Rust HTTP layer with Python event loop integration\n\u2022 Balance of performance and Python async support\n\u2022 Could match ASGI interface\n\nCons:\n\u2022 Requires significant architectural changes\n\u2022 New standard to define and maintain\n</code></pre>"},{"location":"python/architecture/#future-directions","title":"Future Directions","text":"<p>The current architecture is stable and functional. Potential future improvements:</p> <ol> <li>ASGI/RSGI Support: Add deployment modes where Python manages the event loop for async-heavy workloads</li> <li>Status: Documented as future option in README</li> <li> <p>Use case: Applications with heavy async I/O (database queries, external APIs)</p> </li> <li> <p>GIL-Free Python: When PEP 703 (free-threaded Python) becomes stable, eliminate GIL contention entirely</p> </li> <li>Status: Experimental in Python 3.13+</li> <li> <p>Impact: Would remove one of the main performance bottlenecks</p> </li> <li> <p>Async Runtime Bridge: Use <code>pyo3_async_runtimes</code> to directly convert Python coroutines to Tokio futures</p> </li> <li>Status: Attempted but requires Python-driven event loop</li> <li>Blocked by: Current Rust-driven architecture</li> </ol>"},{"location":"python/architecture/#code-references","title":"Code References","text":""},{"location":"python/architecture/#rust-implementation","title":"Rust Implementation","text":"<ul> <li>Event loop initialization: <code>crates/spikard-py/src/handler.rs:34-73</code></li> <li>Async handler execution: <code>crates/spikard-py/src/handler.rs:177-241</code></li> <li>Sync handler execution: <code>crates/spikard-py/src/handler.rs:242-272</code></li> <li>JSON conversion: <code>crates/spikard-py/src/handler.rs:json_to_python()</code></li> <li>Python handler trait: <code>crates/spikard-py/src/handler.rs:PythonHandler</code></li> <li>Server entry point: <code>crates/spikard-py/src/lib.rs:run_server()</code></li> </ul>"},{"location":"python/architecture/#python-api","title":"Python API","text":"<ul> <li>Application class: <code>packages/python/spikard/app.py:Spikard</code></li> <li>Route decorators: <code>packages/python/spikard/decorators.py</code></li> <li>Type system: <code>packages/python/spikard/types.py</code></li> <li>Configuration: <code>packages/python/spikard/config.py:ServerConfig</code></li> </ul>"},{"location":"python/architecture/#related-documentation","title":"Related Documentation","text":"<ul> <li>Overall Architecture: <code>docs/design/architecture.md</code></li> <li>Type Conversion: <code>docs/design/msgspec-type-conversion.md</code></li> <li>Middleware &amp; Lifecycle: <code>docs/design/middleware-lifecycle-optimization.md</code></li> <li>Validation Strategy: <code>docs/design/validation-strategy.md</code></li> </ul>"},{"location":"reference/api-python/","title":"Python API Reference","text":"<p>The Python binding exposes the Rust runtime through a thin, Pythonic surface.</p>"},{"location":"reference/api-python/#package","title":"Package","text":"<ul> <li>Install: <code>pip install spikard</code></li> <li>Entry module: <code>spikard</code></li> </ul>"},{"location":"reference/api-python/#core-types","title":"Core Types","text":"<ul> <li><code>Spikard</code> \u2013 register routes and run the server</li> <li>Route decorators (<code>@app.get</code>, <code>@app.post</code>, \u2026) \u2013 built on msgspec type hints</li> <li>Lifecycle hooks (<code>on_request</code>, <code>pre_validation</code>, <code>pre_handler</code>, <code>on_response</code>, <code>on_error</code>)</li> <li>Validation powered by msgspec (with optional Pydantic/attrs/dataclass detection)</li> <li>Dependency injection via <code>app.provide</code> and <code>spikard.di.Provide</code></li> </ul>"},{"location":"reference/api-python/#routing","title":"Routing","text":"<pre><code>from spikard import Spikard\n\napp = Spikard()\n\n@app.get(\"/health\")\nasync def health() -&gt; dict:\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"reference/api-python/#dependency-injection","title":"Dependency Injection","text":"<pre><code>from spikard.di import Provide\n\napp.provide(\"config\", {\"db_url\": \"postgresql://localhost/app\"})\napp.provide(\"db_pool\", Provide(lambda config: f\"pool({config['db_url']})\", depends_on=[\"config\"], singleton=True))\n</code></pre>"},{"location":"reference/api-python/#middleware","title":"Middleware","text":"<p>Use lifecycle hooks for cross-cutting behavior: <pre><code>from spikard import Spikard\n\napp = Spikard()\n\n@app.on_request\nasync def log_request(request):\n    print(f\"{request['method']} {request['path']}\")\n    return request\n</code></pre></p>"},{"location":"reference/api-python/#validation","title":"Validation","text":"<p>Use msgspec <code>Struct</code> types for automatic request/response validation. Pydantic/dataclasses can be detected when enabled.</p>"},{"location":"reference/api-python/#event-loop","title":"Event Loop","text":"<p>The binding runs handlers on a dedicated Python event loop thread while the Rust runtime stays async (see Python architecture).</p> <p>More detailed, generated docs can be added with <code>mkdocstrings</code> once docstrings are in place.</p>"},{"location":"reference/api-ruby/","title":"Ruby API Reference","text":"<p>The Ruby binding uses magnus to expose the Rust runtime with a Ruby-friendly DSL.</p>"},{"location":"reference/api-ruby/#gem","title":"Gem","text":"<ul> <li>Install: <code>gem install spikard</code></li> <li>Require: <code>require \"spikard\"</code></li> </ul>"},{"location":"reference/api-ruby/#core-types","title":"Core Types","text":"<ul> <li><code>Spikard::App</code> \u2013 register routes and start the server</li> <li>Handler args \u2013 receive path params, query params, and body (or use handler wrappers)</li> <li>Lifecycle hooks (<code>on_request</code>, <code>pre_validation</code>, <code>pre_handler</code>, <code>on_response</code>, <code>on_error</code>)</li> <li>Dependency injection via <code>app.provide</code> and keyword parameters</li> </ul>"},{"location":"reference/api-ruby/#routing","title":"Routing","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get(\"/health\") do |_params, _query, _body|\n  { status: \"ok\" }\nend\n\napp.run(port: 8000)\n</code></pre>"},{"location":"reference/api-ruby/#middleware","title":"Middleware","text":"<pre><code>app = Spikard::App.new\n\napp.on_request do |request|\n  puts \"#{request[:method]} #{request[:path]}\"\n  request\nend\n</code></pre>"},{"location":"reference/api-ruby/#dependency-injection","title":"Dependency Injection","text":"<pre><code>app.provide(\"config\", { \"db_url\" =&gt; \"postgresql://localhost/app\" })\napp.provide(\"db_pool\", depends_on: [\"config\"], singleton: true) { |config:| config[\"db_url\"] }\n</code></pre>"},{"location":"reference/api-ruby/#validation","title":"Validation","text":"<p>Ruby handlers can rely on RBS signatures and runtime validation hooks. DTO generation from OpenAPI/AsyncAPI keeps Ruby types in sync with other bindings.</p>"},{"location":"reference/api-rust/","title":"Rust API Reference","text":"<p>Use the Rust API when you want zero-overhead access to the runtime without crossing an FFI boundary.</p>"},{"location":"reference/api-rust/#crate","title":"Crate","text":"<ul> <li>Add: <code>cargo add spikard</code></li> <li>Import route builders and types directly from <code>spikard</code></li> </ul>"},{"location":"reference/api-rust/#core-types","title":"Core Types","text":"<ul> <li><code>App</code> \u2013 build your router and middleware stack</li> <li><code>RequestContext</code> \u2013 access path/query/header/cookie/body data</li> <li>Response helpers such as <code>HandlerResponse::stream</code>, plus <code>axum</code> response types for JSON/streaming in your handlers</li> <li>Dependency injection via <code>ServerConfig::provide_value</code> / <code>provide_factory</code> and <code>RequestContext::dependencies</code></li> </ul>"},{"location":"reference/api-rust/#routing","title":"Routing","text":"<pre><code>use axum::response::Json;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::{get, post, App, RequestContext};\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct User {\n    id: i32,\n    name: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut app = App::new();\n\n    app.route(get(\"/health\"), |_ctx: RequestContext| async move {\n        let body = serde_json::json!({\"status\": \"ok\"});\n        Ok(Json(body).into())\n    })?;\n\n    app.route(\n        post(\"/users\").request_body::&lt;User&gt;().response_body::&lt;User&gt;(),\n        |ctx: RequestContext| async move {\n            let user: User = ctx.json()?;\n            Ok(Json(user).into())\n        },\n    )?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"reference/api-rust/#middleware","title":"Middleware","text":"<p>Attach middleware via <code>ServerConfig</code> or by adding layers to the Axum router produced by <code>App::into_router</code>.</p>"},{"location":"reference/api-rust/#validation","title":"Validation","text":"<p>Integrate serde-based DTOs with JSON Schema derivation to keep contracts aligned with other bindings and code generators.</p>"},{"location":"reference/api-typescript/","title":"TypeScript API Reference","text":"<p>The TypeScript binding uses NAPI-RS for Node/Bun and can also target WASM for Deno/Edge-style runtimes.</p>"},{"location":"reference/api-typescript/#package","title":"Package","text":"<ul> <li>Install: <code>npm install spikard</code> or <code>pnpm add spikard</code></li> <li>Entry module: <code>spikard</code></li> </ul>"},{"location":"reference/api-typescript/#core-types","title":"Core Types","text":"<ul> <li><code>Spikard</code> \u2013 register routes and start the HTTP server</li> <li><code>Request</code> \u2013 access <code>params</code>, <code>query</code>, <code>headers</code>, <code>cookies</code>, and parsed <code>body</code></li> <li>Lifecycle hooks (<code>onRequest</code>, <code>preValidation</code>, <code>preHandler</code>, <code>onResponse</code>, <code>onError</code>)</li> <li>Helper wrappers for streaming and background tasks</li> <li>Dependency injection via <code>app.provide</code> and <code>request.dependencies</code></li> </ul>"},{"location":"reference/api-typescript/#routing","title":"Routing","text":"<pre><code>import { Spikard } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/health\", handler_name: \"health\", is_async: true },\n  async () =&gt; ({ status: \"ok\" }),\n);\napp.run({ port: 8000 });\n</code></pre>"},{"location":"reference/api-typescript/#dependency-injection","title":"Dependency Injection","text":"<pre><code>app.provide(\"config\", { dbUrl: \"postgresql://localhost/app\" });\napp.provide(\"dbPool\", async ({ config }) =&gt; ({ url: config.dbUrl }), { dependsOn: [\"config\"], singleton: true });\n</code></pre>"},{"location":"reference/api-typescript/#validation","title":"Validation","text":"<p>Use Zod (recommended) to validate requests/responses: <pre><code>import { z } from \"zod\";\nconst User = z.object({ id: z.number(), name: z.string() });\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/users\",\n    handler_name: \"createUser\",\n    request_schema: User,\n    response_schema: User,\n    is_async: true,\n  },\n  (req) =&gt; User.parse(req.json()),\n);\n</code></pre></p>"},{"location":"reference/api-typescript/#middleware","title":"Middleware","text":"<pre><code>app.onRequest(async (request) =&gt; {\n  console.log(`${request.method} ${request.path}`);\n  return request;\n});\n</code></pre>"},{"location":"reference/api-typescript/#wasm","title":"WASM","text":"<p>Bindings are compatible with WASM targets for environments without Node APIs. Use the WASM package when running on Deno/Edge.</p>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>Configuration is code-first with environment overrides. Use these settings consistently across bindings and the CLI.</p>"},{"location":"reference/configuration/#server-rust-core-cli","title":"Server (Rust core / CLI)","text":"<ul> <li><code>host</code> (default <code>0.0.0.0</code>)</li> <li><code>port</code> (default <code>8000</code>)</li> <li><code>workers</code> / runtime threads</li> <li><code>graceful_shutdown_timeout</code> (seconds)</li> <li><code>request_timeout</code> (seconds)</li> <li><code>max_body_size</code> (bytes)</li> <li><code>enable_request_id</code> (bool)</li> <li><code>compression</code> (gzip/brotli, quality, min_size)</li> <li><code>rate_limit</code> (per_second, burst, ip_based)</li> <li><code>static_files</code> (directory, route_prefix, index_file, cache_control)</li> <li><code>openapi</code> (enabled, title, version, swagger_ui_path, redoc_path)</li> <li><code>jwt_auth</code> (secret, algorithm, audience, issuer, leeway)</li> </ul>"},{"location":"reference/configuration/#validation","title":"Validation","text":"<ul> <li>Enable request/response validation globally or per route (bindings surface this via schemas/DTOs).</li> <li>Schema sources: derived (<code>JsonSchema</code>, msgspec/Typed schemas, Zod) or explicit JSON Schema objects.</li> </ul>"},{"location":"reference/configuration/#cli-flags-codegenvalidation","title":"CLI Flags (codegen/validation)","text":"<ul> <li><code>spikard generate</code> and <code>spikard validate-asyncapi</code> use standard file/path flags</li> <li>Runtime serving via the CLI is planned; use binding-specific <code>run</code> methods today</li> </ul>"},{"location":"reference/configuration/#environment-variables-convention","title":"Environment Variables (convention)","text":"<ul> <li><code>SPIKARD_HOST</code>, <code>SPIKARD_PORT</code></li> <li><code>SPIKARD_LOG</code> / <code>RUST_LOG</code> for log levels</li> <li><code>SPIKARD_OTEL_EXPORTER</code> for tracing destinations</li> </ul> <p>See Configuration guide for usage patterns; binding-specific pages cover how these surface in each runtime.</p>"},{"location":"reference/errors/","title":"Errors","text":"<p>Spikard returns structured error responses that align with RFC 9457 so clients can reliably parse failures.</p>"},{"location":"reference/errors/#format","title":"Format","text":"<pre><code>{\n  \"type\": \"https://spikard.dev/errors/validation\",\n  \"title\": \"Validation failed\",\n  \"status\": 422,\n  \"detail\": \"Field 'email' is not a valid address\",\n  \"instance\": \"/users\",\n  \"errors\": [\n    { \"path\": \"/email\", \"message\": \"must be an email\" }\n  ],\n  \"request_id\": \"c90d52c2-4c34-4b42-b028-a5a48e57b1f7\"\n}\n</code></pre>"},{"location":"reference/errors/#categories","title":"Categories","text":"<ul> <li>Validation \u2013 400/422 with field-level errors</li> <li>Auth \u2013 401/403 with reason codes</li> <li>Not Found \u2013 404 with path metadata</li> <li>Server \u2013 500 with opaque message; detailed traces stay in logs unless explicitly exposed</li> </ul>"},{"location":"reference/errors/#best-practices","title":"Best Practices","text":"<ul> <li>Keep error types stable; clients should depend on <code>type</code> and <code>status</code> rather than raw messages.</li> <li>Add correlation/request IDs via middleware and return them in error payloads for debugging.</li> <li>Use domain-specific <code>type</code> URLs when exposing business errors.</li> </ul>"},{"location":"reference/errors/#binding-notes","title":"Binding notes","text":"<ul> <li>Python/TypeScript/Ruby: return structured objects/hashes; include <code>status</code>/<code>statusCode</code> and a predictable body shape.</li> <li>Rust: use <code>Json(..).with_status(StatusCode::...)</code> or return typed error responses from handlers/middleware.</li> </ul>"},{"location":"reference/errors/#examples-per-binding","title":"Examples per binding","text":"PythonTypeScriptRubyRust <pre><code>from spikard import Response\n\n@app.get(\"/fail\")\nasync def fail() -&gt; Response:\n    return Response(\n        {\n            \"type\": \"https://spikard.dev/errors/validation\",\n            \"title\": \"Validation failed\",\n            \"detail\": \"email is invalid\",\n            \"status\": 422,\n        },\n        status=422,\n    )\n</code></pre> <pre><code>const app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/fail\", handler_name: \"fail\", is_async: true },\n  async () =&gt; ({\n    statusCode: 422,\n    body: {\n      type: \"https://spikard.dev/errors/validation\",\n      title: \"Validation failed\",\n      detail: \"email is invalid\",\n      status: 422,\n    },\n  }),\n);\n</code></pre> <pre><code>app.get \"/fail\" do |_request|\n  [{ type: \"https://spikard.dev/errors/validation\", title: \"Validation failed\", status: 422 }, 422]\nend\n</code></pre> <pre><code>use spikard::prelude::*;\n\napp.route(get(\"/fail\"), |_ctx: Context| async move {\n    Ok(Json(json!({\n        \"type\": \"https://spikard.dev/errors/validation\",\n        \"title\": \"Validation failed\",\n        \"status\": 422\n    })).with_status(StatusCode::UNPROCESSABLE_ENTITY))\n})?;\n</code></pre>"},{"location":"reference/errors/#status-code-map-binding-expectations","title":"Status code map (binding expectations)","text":"Binding Validation Auth Not Found Server Python 422 with RFC9457 body 401/403 (structured) 404 with path info 500 with generic message TypeScript 422 with RFC9457 body 401/403 (structured) 404 with path info 500 with generic message Ruby 422 with RFC9457 body 401/403 (structured) 404 with path info 500 with generic message Rust 422 with RFC9457 body 401/403 (structured) 404 with path info 500 with generic message"},{"location":"reference/types/","title":"Types Reference","text":"<p>The runtime normalizes request/response types so bindings can stay in sync. Use these shapes to model DTOs and to align generated code.</p>"},{"location":"reference/types/#request-context","title":"Request Context","text":"<ul> <li>Method/Path: HTTP verb and path template</li> <li>Params: path params with optional converters (int, uuid, etc.)</li> <li>Query: map/object of query params</li> <li>Headers/Cookies: case-insensitive accessors</li> <li>Body: JSON by default; form/multipart helpers per binding</li> </ul>"},{"location":"reference/types/#responses","title":"Responses","text":"<ul> <li>JSON: <code>Json&lt;T&gt;</code> in Rust, plain objects/structs in other bindings</li> <li>Streams: async iterators/generators for chunked responses</li> <li>Errors: typed error envelopes with status codes</li> </ul>"},{"location":"reference/types/#dtos","title":"DTOs","text":"<ul> <li>Python: msgspec <code>Struct</code>, optional Pydantic/dataclasses</li> <li>TypeScript: Zod schemas with inferred types</li> <li>Ruby: RBS/dry-schema</li> <li>Rust: serde structs + JSON Schema derivation</li> </ul>"},{"location":"reference/types/#errors-shape","title":"Errors Shape","text":"<p>See Errors for the canonical response body and RFC 9457 mapping.</p>"},{"location":"reference/types/#matrix-bindings","title":"Matrix (bindings)","text":"Surface Requests Validation Responses Streaming Python <code>ctx</code> with params/query/headers/body, msgspec structs msgspec (default), Pydantic/dataclasses return objects/Structs SSE/WebSockets via bridge TypeScript <code>Request</code> with <code>path</code>, <code>params</code>, <code>query</code>, <code>headers</code>, <code>cookies</code>, <code>json()</code> Zod (<code>bodySchema</code>/<code>responseSchema</code>), JSON Schema object or <code>{ statusCode, body }</code> <code>StreamingResponse</code>, WS route Ruby request hash (<code>:path_params</code>, <code>:query</code>, <code>:headers</code>, <code>:body</code>) dry-schema/JSON Schema hashes/arrays SSE via bridge; WS planned Rust <code>Context</code> with getters (<code>path_param</code>, <code>query</code>, <code>json</code>) <code>JsonSchema</code> derive, raw schema <code>Json&lt;T&gt;</code>, <code>Response</code> builders <code>StreamingBody</code>, SSE, WS"},{"location":"snippets/cli/run_app/","title":"Run app","text":"<p>Runtime serving via CLI is planned. Start your binding directly, e.g. <code>python app.py</code>.</p>"},{"location":"snippets/php/auth_middleware/","title":"Auth middleware","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Config\\LifecycleHooks;\nuse Spikard\\Config\\HookResult;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$hooks = new LifecycleHooks(\n    preHandler: function (Request $request): HookResult {\n        $token = $request-&gt;headers['authorization'] ?? null;\n        if ($token !== 'Bearer dev-token') {\n            return HookResult::ShortCircuit(\n                Response::json(['error' =&gt; 'unauthorized'], 401)\n            );\n        }\n        return HookResult::Continue($request);\n    }\n);\n\n$app = (new App(new ServerConfig(port: 8000)))\n    -&gt;withLifecycleHooks($hooks);\n</code></pre>"},{"location":"snippets/php/background_task/","title":"Background task","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Background\\BackgroundTask;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\nfunction sendEmail(int $userId): void {\n    error_log(\"send email to {$userId}\");\n}\n\n$app = $app-&gt;addRoute('POST', '/signup', function (Request $request) {\n    $user = $request-&gt;body;\n\n    BackgroundTask::run(function () use ($user) {\n        sendEmail($user['id']);\n    });\n\n    return Response::json($user);\n});\n</code></pre>"},{"location":"snippets/php/dependency_injection/","title":"Dependency injection","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\DI\\DependencyContainer;\nuse Spikard\\DI\\Provide;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n// Value dependency (singleton)\n$container = new DependencyContainer(\n    values: ['config' =&gt; ['db_url' =&gt; 'postgresql://localhost/app']],\n    factories: [\n        'db_pool' =&gt; new Provide(\n            factory: fn (array $config) =&gt; ['url' =&gt; $config['db_url'], 'client' =&gt; 'pool'],\n            dependsOn: ['config'],\n            singleton: true\n        ),\n    ]\n);\n\n$app = $app-&gt;withDependencies($container);\n\n$app = $app-&gt;addRoute('GET', '/stats', function () {\n    // Note: Full auto-injection pending P1.4\n    return Response::json(['status' =&gt; 'ok']);\n});\n</code></pre>"},{"location":"snippets/php/hello_route/","title":"Hello route","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('GET', '/users/{id}', function (Request $request) {\n    $userId = (int) $request-&gt;pathParams['id'];\n    return Response::json(['id' =&gt; $userId, 'name' =&gt; 'Alice']);\n});\n\n$app-&gt;run();\n</code></pre>"},{"location":"snippets/php/middleware_basic/","title":"Middleware basic","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Config\\LifecycleHooks;\nuse Spikard\\Config\\HookResult;\nuse Spikard\\Http\\Request;\n\n$hooks = new LifecycleHooks(\n    onRequest: function (Request $request): HookResult {\n        error_log(\"{$request-&gt;method} {$request-&gt;path}\");\n        return HookResult::Continue($request);\n    }\n);\n\n$app = (new App(new ServerConfig(port: 8000)))\n    -&gt;withLifecycleHooks($hooks);\n</code></pre>"},{"location":"snippets/php/path_params/","title":"Path params","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('GET', '/orders/{order_id}', function (Request $request) {\n    $orderId = (int) $request-&gt;pathParams['order_id'];\n    $includeDetails = $request-&gt;queryParams['include_details'][0] ?? 'false';\n\n    return Response::json([\n        'id' =&gt; $orderId,\n        'details' =&gt; $includeDetails === 'true'\n    ]);\n});\n</code></pre>"},{"location":"snippets/php/quickstart_routes/","title":"Quickstart routes","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('GET', '/users/{id}', function (Request $request) {\n    $userId = (int) $request-&gt;pathParams['id'];\n    return Response::json(['id' =&gt; $userId, 'name' =&gt; 'Alice']);\n});\n\n$app = $app-&gt;addRoute('POST', '/users', function (Request $request) {\n    $user = $request-&gt;body;\n    return Response::json($user);\n});\n\n$app-&gt;run();\n</code></pre>"},{"location":"snippets/php/request_data/","title":"Request data","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('POST', '/orders/{order_id}', function (Request $request) {\n    $orderId = (int) $request-&gt;pathParams['order_id'];\n    $order = $request-&gt;body;\n    $verbose = $request-&gt;queryParams['verbose'][0] ?? 'false';\n\n    return Response::json([\n        'id' =&gt; $orderId,\n        'item' =&gt; $order['item'] ?? '',\n        'quantity' =&gt; $order['quantity'] ?? 0,\n        'verbose' =&gt; $verbose\n    ]);\n});\n</code></pre>"},{"location":"snippets/php/response_basic/","title":"Response basic","text":"<pre><code>&lt;?php\n\nuse Spikard\\Http\\Response;\n\nreturn Response::json(['status' =&gt; 'ok']);\n</code></pre>"},{"location":"snippets/php/routing_basic/","title":"Routing basic","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('GET', '/health', function () {\n    return Response::json(['status' =&gt; 'ok']);\n});\n\n$app = $app-&gt;addRoute('POST', '/users', function (Request $request) {\n    $user = $request-&gt;jsonBody();\n    return Response::json($user);\n});\n</code></pre>"},{"location":"snippets/php/run_app/","title":"Run app","text":"<pre><code>php app.php\n</code></pre>"},{"location":"snippets/php/sse/","title":"Sse","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\StreamingResponse;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('GET', '/events', function () {\n    $generator = function (): Generator {\n        for ($i = 0; $i &lt; 3; $i++) {\n            yield \"data: \" . json_encode(['tick' =&gt; $i]) . \"\\n\\n\";\n        }\n    };\n\n    return StreamingResponse::sse($generator());\n});\n</code></pre>"},{"location":"snippets/php/streaming/","title":"Streaming","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\StreamingResponse;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('GET', '/stream', function () {\n    $generator = function (): Generator {\n        for ($i = 0; $i &lt; 3; $i++) {\n            yield \"data: \" . json_encode(['tick' =&gt; $i]) . \"\\n\\n\";\n            sleep(1);\n        }\n    };\n\n    return StreamingResponse::sse($generator());\n});\n</code></pre>"},{"location":"snippets/php/upload/","title":"Upload","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n// Note: UploadFile support is in development (P1.5)\n$app = $app-&gt;addRoute('POST', '/upload', function (Request $request) {\n    $file = $request-&gt;files['file'] ?? null;\n\n    if (!$file) {\n        return Response::json(['error' =&gt; 'No file uploaded'], 400);\n    }\n\n    return Response::json([\n        'filename' =&gt; $file['filename'] ?? 'unknown',\n        'received' =&gt; true\n    ]);\n});\n</code></pre>"},{"location":"snippets/php/validation_basic/","title":"Validation basic","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Http\\Request;\nuse Spikard\\Http\\Response;\n\n$app = new App(new ServerConfig(port: 8000));\n\n$app = $app-&gt;addRoute('POST', '/payments', function (Request $request) {\n    $payment = $request-&gt;body;\n\n    // Validation\n    if (!isset($payment['id'], $payment['amount'])) {\n        return Response::json(['error' =&gt; 'Invalid payment data'], 400);\n    }\n\n    return Response::json($payment);\n});\n</code></pre>"},{"location":"snippets/php/websocket/","title":"Websocket","text":"<pre><code>&lt;?php\n\nuse Spikard\\App;\nuse Spikard\\Config\\ServerConfig;\nuse Spikard\\Handlers\\WebSocketHandlerInterface;\n\nclass ChatHandler implements WebSocketHandlerInterface\n{\n    public function onConnect(): void\n    {\n        error_log('Client connected');\n    }\n\n    public function onMessage(string $message): void\n    {\n        // Handle incoming message\n        $data = json_decode($message, true);\n        error_log(\"Received: \" . json_encode($data));\n    }\n\n    public function onClose(int $code, ?string $reason = null): void\n    {\n        error_log(\"Client disconnected: {$code}\");\n    }\n}\n\n$app = new App(new ServerConfig(port: 8000));\n$app = $app-&gt;addWebSocket('/ws', new ChatHandler());\n</code></pre>"},{"location":"snippets/python/auth_middleware/","title":"Auth middleware","text":"<pre><code>from spikard import Spikard\n\napp = Spikard()\n\n@app.pre_handler\nasync def auth_hook(request: dict[str, object]):\n    headers = request.get(\"headers\", {}) if isinstance(request, dict) else {}\n    token = headers.get(\"authorization\") if isinstance(headers, dict) else None\n    if token != \"Bearer dev-token\":\n        return {\"error\": \"unauthorized\"}, 401\n    return request\n</code></pre>"},{"location":"snippets/python/background_task/","title":"Background task","text":"<pre><code>from spikard import Spikard, background\nfrom msgspec import Struct\n\napp = Spikard()\n\nclass User(Struct):\n    id: int\n    email: str\n\nasync def send_email(user_id: int) -&gt; None:\n    # enqueue real email send\n    print(f\"send email to {user_id}\")\n\n@app.post(\"/signup\")\nasync def signup(user: User) -&gt; User:\n    background.run(send_email(user.id))\n    return user\n</code></pre>"},{"location":"snippets/python/dependency_injection/","title":"Dependency injection","text":"<pre><code>from spikard import Spikard\nfrom spikard.di import Provide\n\napp = Spikard()\n\n# Value dependency (singleton)\napp.provide(\"config\", {\"db_url\": \"postgresql://localhost/app\"})\n\n# Factory dependency (depends on config, cached globally)\nasync def make_pool(config: dict[str, str]):\n    return {\"url\": config[\"db_url\"], \"client\": \"pool\"}\n\napp.provide(\"db_pool\", Provide(make_pool, depends_on=[\"config\"], singleton=True))\n\n@app.get(\"/stats\")\nasync def stats(config: dict[str, str], db_pool):\n    return {\"db\": db_pool[\"url\"], \"env\": config[\"db_url\"]}\n</code></pre>"},{"location":"snippets/python/hello_route/","title":"Hello route","text":"<pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\nclass User(Struct):\n    id: int\n    name: str\n\napp = Spikard()\n\n@app.get(\"/users/{id:int}\")\nasync def get_user(id: int) -&gt; User:\n    return User(id=id, name=\"Alice\")\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre>"},{"location":"snippets/python/middleware_basic/","title":"Middleware basic","text":"<pre><code>from spikard import Spikard\n\napp = Spikard()\n\n@app.on_request\nasync def logging_hook(request):\n    print(f\"{request['method']} {request['path']}\")\n    return request\n</code></pre>"},{"location":"snippets/python/path_params/","title":"Path params","text":"<pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\napp = Spikard()\n\n\nclass OrderResponse(Struct):\n    id: int\n    details: bool\n\n\n@app.get(\"/orders/{order_id:int}\")\nasync def get_order(order_id: int, include_details: bool = False) -&gt; OrderResponse:\n    return OrderResponse(id=order_id, details=include_details)\n</code></pre>"},{"location":"snippets/python/quickstart_routes/","title":"Quickstart routes","text":"<pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\nclass User(Struct):\n    id: int\n    name: str\n\napp = Spikard()\n\n@app.get(\"/users/{id:int}\")\nasync def get_user(id: int) -&gt; User:\n    return User(id=id, name=\"Alice\")\n\n@app.post(\"/users\")\nasync def create_user(user: User) -&gt; User:\n    return user\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre>"},{"location":"snippets/python/request_data/","title":"Request data","text":"<pre><code>from typing import Optional\nfrom spikard import Spikard\nfrom msgspec import Struct\n\napp = Spikard()\n\n\nclass Order(Struct):\n    id: int\n    item: str\n    quantity: int\n    verbose: bool | None = None\n\n\n@app.post(\"/orders/{order_id:int}\")\nasync def update_order(order_id: int, order: Order, verbose: Optional[bool] = False) -&gt; Order:\n    return Order(id=order_id, item=order.item, quantity=order.quantity, verbose=verbose or False)\n</code></pre>"},{"location":"snippets/python/response_basic/","title":"Response basic","text":"<pre><code>@app.get(\"/health\")\nasync def health() -&gt; dict:\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"snippets/python/routing_basic/","title":"Routing basic","text":"<pre><code>from spikard import Spikard\nfrom msgspec import Struct\n\n\nclass User(Struct):\n    id: int\n    name: str\n\napp = Spikard()\n\n@app.get(\"/health\")\nasync def health() -&gt; dict:\n    return {\"status\": \"ok\"}\n\n@app.post(\"/users\")\nasync def create_user(user: User) -&gt; User:\n    return user\n</code></pre>"},{"location":"snippets/python/run_app/","title":"Run app","text":"<pre><code>python app.py\n</code></pre>"},{"location":"snippets/python/sse/","title":"Sse","text":"<pre><code>from spikard import Spikard, SseEvent, sse\n\napp = Spikard()\n\n@sse(\"/events\")\nasync def events():\n    for i in range(3):\n        yield SseEvent(data={\"tick\": i})\n</code></pre>"},{"location":"snippets/python/streaming/","title":"Streaming","text":"<pre><code>from spikard import SseEvent, sse\n\n@sse(\"/events\")\nasync def events():\n    for i in range(3):\n        yield SseEvent(data={\"tick\": i})\n</code></pre>"},{"location":"snippets/python/upload/","title":"Upload","text":"<pre><code>from spikard import Spikard, UploadFile\n\napp = Spikard()\n\n@app.post(\"/upload\")\nasync def upload(file: UploadFile) -&gt; dict:\n    content = file.read()\n    return {\"filename\": file.filename, \"size\": len(content)}\n</code></pre>"},{"location":"snippets/python/validation_basic/","title":"Validation basic","text":"<pre><code>from msgspec import Struct\n\nclass Payment(Struct):\n    id: str\n    amount: float\n\n@app.post(\"/payments\")\nasync def create_payment(payment: Payment) -&gt; Payment:\n    return payment\n</code></pre>"},{"location":"snippets/python/websocket/","title":"Websocket","text":"<pre><code>from spikard import Spikard, websocket\n\napp = Spikard()\n\n@websocket(\"/ws\")\nasync def echo(socket):\n    async for message in socket:\n        await socket.send_json({\"echo\": message})\n</code></pre>"},{"location":"snippets/ruby/auth_middleware/","title":"Auth middleware","text":"<pre><code>app = Spikard::App.new\n\napp.pre_handler do |request|\n  headers = request[:headers] || {}\n  if headers[\"authorization\"] != \"Bearer dev-token\"\n    { error: \"unauthorized\" }\n  else\n    request\n  end\nend\n</code></pre>"},{"location":"snippets/ruby/background_task/","title":"Background task","text":"<pre><code># Placeholder: Ruby binding background jobs TBD\n</code></pre>"},{"location":"snippets/ruby/dependency_injection/","title":"Dependency injection","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\n# Value dependency (singleton)\napp.provide(\"config\", { \"db_url\" =&gt; \"postgresql://localhost/app\" })\n\n# Factory dependency (depends on config, singleton)\napp.provide(\"db_pool\", depends_on: [\"config\"], singleton: true) do |config:|\n  { url: config[\"db_url\"], client: \"pool\" }\nend\n\napp.get(\"/stats\") do |_params, _query, _body, config:, db_pool:|\n  { db: db_pool[:url], env: config[\"db_url\"] }\nend\n</code></pre>"},{"location":"snippets/ruby/hello_route/","title":"Hello route","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get(\"/users/:id\") do |params, _query, _body|\n  { id: params[:id].to_i, name: \"Alice\" }\nend\n\napp.run(port: 8000)\n</code></pre>"},{"location":"snippets/ruby/middleware_basic/","title":"Middleware basic","text":"<pre><code>app = Spikard::App.new\n\napp.on_request do |request|\n  puts \"#{request[:method]} #{request[:path]}\"\n  request\nend\n</code></pre>"},{"location":"snippets/ruby/path_params/","title":"Path params","text":"<pre><code>app = Spikard::App.new\n\napp.get(\"/orders/:order_id\") do |params, query, _body|\n  {\n    id: params[:order_id].to_i,\n    details: query[\"details\"] == \"true\",\n  }\nend\n</code></pre>"},{"location":"snippets/ruby/quickstart_routes/","title":"Quickstart routes","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get(\"/users/:id\") do |params, _query, _body|\n  { id: params[:id].to_i, name: \"Alice\" }\nend\n\napp.post(\"/users\") do |_params, _query, body|\n  user = body\n  { id: user[\"id\"], name: user[\"name\"] }\nend\n\napp.run(port: 8000)\n</code></pre>"},{"location":"snippets/ruby/request_data/","title":"Request data","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.post(\"/orders/:order_id\") do |params, query, body|\n  {\n    **body,\n    id: params[:order_id].to_i,\n    verbose: query[\"verbose\"] == \"true\",\n  }\nend\n</code></pre>"},{"location":"snippets/ruby/response_basic/","title":"Response basic","text":"<pre><code>app = Spikard::App.new\n\napp.get(\"/health\") { |_params, _query, _body| { status: \"ok\" } }\n</code></pre>"},{"location":"snippets/ruby/routing_basic/","title":"Routing basic","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.get(\"/health\") { |_params, _query, _body| { status: \"ok\" } }\napp.post(\"/users\") { |_params, _query, body| body }\n</code></pre>"},{"location":"snippets/ruby/sse/","title":"Sse","text":"<pre><code>require \"spikard\"\nrequire \"json\"\n\napp = Spikard::App.new\n\napp.get \"/events\" do |_params, _query, _body|\n  Enumerator.new do |y|\n    3.times do |i|\n      y &lt;&lt; \"data: #{JSON.dump({ tick: i })}\\n\\n\"\n      sleep 0.1\n    end\n  end\nend\n</code></pre>"},{"location":"snippets/ruby/streaming/","title":"Streaming","text":"<pre><code>require \"spikard\"\nrequire \"json\"\n\napp = Spikard::App.new\n\napp.get \"/stream\" do |_params, _query, _body|\n  Enumerator.new do |y|\n    3.times do |i|\n      y &lt;&lt; JSON.dump({ tick: i }) + \"\\n\"\n      sleep 0.1\n    end\n  end\nend\n</code></pre>"},{"location":"snippets/ruby/upload/","title":"Upload","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\napp.post \"/upload\" do |_params, _query, body|\n  file = body[\"file\"]\n  { filename: file[:filename], size: file[:tempfile].size }\nend\n</code></pre>"},{"location":"snippets/ruby/validation_basic/","title":"Validation basic","text":"<pre><code>PaymentSchema = Dry::Schema.Params do\n  required(:id).filled(:string)\n  required(:amount).filled(:float)\nend\n\napp = Spikard::App.new\n\napp.post(\"/payments\") do |_params, _query, body|\n  PaymentSchema.call(body)\nend\n</code></pre>"},{"location":"snippets/ruby/websocket/","title":"Websocket","text":"<pre><code>require \"spikard\"\n\napp = Spikard::App.new\n\nclass ChatHandler &lt; Spikard::WebSocketHandler\n  def handle_message(message)\n    # Echo JSON message back\n    message\n  end\nend\n\napp.websocket(\"/chat\") { ChatHandler.new }\n</code></pre>"},{"location":"snippets/rust/auth_layer/","title":"Auth layer","text":"<pre><code>use spikard::prelude::*;\nuse tower_http::auth::RequireAuthorizationLayer;\n\nlet mut app = App::new();\n\napp.layer(RequireAuthorizationLayer::bearer(\"dev-token\"));\n</code></pre>"},{"location":"snippets/rust/background_task/","title":"Background task","text":"<pre><code>// Placeholder: background tasks via Tokio spawn or external queue\n</code></pre>"},{"location":"snippets/rust/dependency_injection/","title":"Dependency injection","text":"<pre><code>use axum::response::Json;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::{get, App, RequestContext};\nuse spikard_http::ServerConfig;\nuse std::sync::Arc;\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct Health {\n    db: String,\n    env: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Register dependencies on the server config\n    let config = ServerConfig::builder()\n        .provide_value(\"config\", \"postgresql://localhost/app\".to_string())\n        .provide_factory(\"db_pool\", |resolved| async move {\n            let url: Arc&lt;String&gt; = resolved.get(\"config\").ok_or(\"missing config\")?;\n            Ok(format!(\"pool({})\", url))\n        })\n        .build();\n\n    let mut app = App::new().config(config);\n\n    app.route(get(\"/stats\"), |ctx: RequestContext| async move {\n        let deps = ctx.dependencies();\n        let db = deps.and_then(|d| d.get::&lt;String&gt;(\"db_pool\")).cloned().unwrap_or_default();\n        let env = deps\n            .and_then(|d| d.get::&lt;String&gt;(\"config\"))\n            .cloned()\n            .unwrap_or_else(|| \"unknown\".to_string());\n        Ok(Json(Health { db, env }).into())\n    })?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"snippets/rust/hello_route/","title":"Hello route","text":"<pre><code>use axum::response::Json;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::{get, App, RequestContext};\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct User {\n    id: i64,\n    name: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut app = App::new();\n\n    app.route(get(\"/users/:id\"), |ctx: RequestContext| async move {\n        let id = ctx.path_param(\"id\").unwrap_or(\"0\").parse::&lt;i64&gt;().unwrap_or_default();\n        Ok(Json(User { id, name: \"Alice\".into() }).into())\n    })?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"snippets/rust/middleware_basic/","title":"Middleware basic","text":"<pre><code>use tower_http::trace::TraceLayer;\n\nlet mut app = App::new();\napp.layer(TraceLayer::new_for_http());\n</code></pre>"},{"location":"snippets/rust/path_params/","title":"Path params","text":"<pre><code>app.route(get(\"/orders/:order_id\"), |ctx: Context| async move {\n    let id = ctx.path_param(\"order_id\").unwrap_or(\"0\");\n    let details: serde_json::Value = ctx.query().unwrap_or_default();\n    Ok(Json(json!({\n        \"id\": id.parse::&lt;i64&gt;().unwrap_or_default(),\n        \"details\": details.get(\"details\").and_then(|d| d.as_bool()).unwrap_or(false)\n    })))\n})?;\n</code></pre>"},{"location":"snippets/rust/quickstart_routes/","title":"Quickstart routes","text":"<pre><code>use axum::response::Json;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse spikard::{get, post, App, RequestContext};\n\n#[derive(Serialize, Deserialize, JsonSchema)]\nstruct User {\n    id: i64,\n    name: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut app = App::new();\n\n    app.route(get(\"/users/:id\"), |ctx: RequestContext| async move {\n        let id = ctx.path_param(\"id\").unwrap_or(\"0\").parse::&lt;i64&gt;().unwrap_or_default();\n        Ok(Json(User { id, name: \"Alice\".into() }).into())\n    })?;\n\n    app.route(\n        post(\"/users\").request_body::&lt;User&gt;().response_body::&lt;User&gt;(),\n        |ctx: RequestContext| async move {\n            let user: User = ctx.json()?;\n            Ok(Json(user).into())\n        },\n    )?;\n\n    app.run().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"snippets/rust/request_data/","title":"Request data","text":"<pre><code>app.route(post(\"/orders/:order_id\"), |ctx: Context| async move {\n    let mut order: serde_json::Value = ctx.json()?;\n    let id = ctx.path_param(\"order_id\").unwrap_or(\"0\");\n    let verbose: serde_json::Value = ctx.query().unwrap_or_default();\n    if let Some(map) = order.as_object_mut() {\n        map.insert(\"id\".into(), serde_json::json!(id.parse::&lt;i64&gt;().unwrap_or_default()));\n        map.insert(\"verbose\".into(), verbose.get(\"verbose\").cloned().unwrap_or(serde_json::json!(false)));\n    }\n    Ok(Json(order))\n})?;\n</code></pre>"},{"location":"snippets/rust/response_basic/","title":"Response basic","text":"<pre><code>app.route(get(\"/health\"), |_ctx: Context| async {\n    Ok(Json(serde_json::json!({\"status\": \"ok\"})))\n})?;\n</code></pre>"},{"location":"snippets/rust/routing_basic/","title":"Routing basic","text":"<pre><code>use spikard::prelude::*;\n\nlet mut app = App::new();\n\napp.route(get(\"/health\"), |_ctx: Context| async { Ok(Json(json!({\"status\": \"ok\"}))) })?;\napp.route(post(\"/users\"), |ctx: Context| async move {\n    let user: serde_json::Value = ctx.json()?;\n    Ok(Json(user))\n})?;\n</code></pre>"},{"location":"snippets/rust/run_binary/","title":"Run binary","text":"<pre><code>cargo run --bin spikard-http -- --port 8000\n</code></pre>"},{"location":"snippets/rust/sse/","title":"Sse","text":"<pre><code>use spikard::prelude::*;\nuse tokio_stream::StreamExt;\n\napp.route(get(\"/events\"), |_ctx: Context| async move {\n    let stream = tokio_stream::iter(0..3).map(|i| {\n        format!(\"data: {}\\n\\n\", serde_json::json!({\"tick\": i}))\n    });\n    Ok(StreamingBody::new(stream).with_header(\"content-type\", \"text/event-stream\"))\n})?;\n</code></pre>"},{"location":"snippets/rust/streaming/","title":"Streaming","text":"<pre><code>use spikard::prelude::*;\nuse tokio_stream::StreamExt;\n\napp.route(get(\"/stream\"), |_ctx: Context| async move {\n    let stream = tokio_stream::iter(0..3).map(|i| {\n        serde_json::to_vec(&amp;serde_json::json!({ \"tick\": i })).unwrap()\n    });\n    Ok(StreamingBody::new(stream))\n})?;\n</code></pre>"},{"location":"snippets/rust/upload/","title":"Upload","text":"<pre><code>use spikard::prelude::*;\nuse spikard::UploadFile;\n\napp.route(post(\"/upload\"), |ctx: Context| async move {\n    let upload: UploadFile = ctx.json()?;\n    Ok(Json(json!({ \"filename\": upload.filename, \"size\": upload.size })))\n})?;\n</code></pre>"},{"location":"snippets/rust/validation_basic/","title":"Validation basic","text":"<pre><code>use schemars::JsonSchema;\nuse serde::Deserialize;\n\n#[derive(Deserialize, JsonSchema)]\nstruct Payment {\n    id: String,\n    amount: f64,\n}\n\napp.route(\n    post(\"/payments\").request_body::&lt;Payment&gt;().response_body::&lt;Payment&gt;(),\n    |ctx: Context| async move {\n        let payment: Payment = ctx.json()?;\n        Ok(Json(payment))\n    },\n)?;\n</code></pre>"},{"location":"snippets/rust/websocket/","title":"Websocket","text":"<pre><code>use spikard::prelude::*;\nuse futures::StreamExt;\n\napp.websocket(\"/ws\", |mut socket| async move {\n    while let Some(msg) = socket.next().await {\n        let text = msg.unwrap_or_default();\n        socket.send(text).await.ok();\n    }\n});\n</code></pre>"},{"location":"snippets/typescript/auth_middleware/","title":"Auth middleware","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\n\nconst app = new Spikard();\n\napp.onRequest(async (request: Request): Promise&lt;Request | { statusCode: number; body: unknown }&gt; =&gt; {\n  const token = request.headers[\"authorization\"];\n  if (token !== \"Bearer dev-token\") {\n    return { statusCode: 401, body: { error: \"unauthorized\" } };\n  }\n  return request;\n});\n</code></pre>"},{"location":"snippets/typescript/background_task/","title":"Background task","text":"<pre><code>import { Spikard, background } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"POST\", path: \"/signup\", handler_name: \"signup\", is_async: true },\n  async (req) =&gt; {\n    const user = req.json&lt;{ id: number; email: string }&gt;();\n    background.run(async () =&gt; {\n      console.log(`send email to ${user.id}`);\n    });\n    return user;\n  },\n);\n</code></pre>"},{"location":"snippets/typescript/deno_fetch/","title":"Deno fetch","text":"<pre><code>import { Spikard, get } from \"npm:spikard-wasm\";\n\nconst app = new Spikard();\n\nget(\"/hello\")(async () =&gt; ({ message: \"Hello from Deno\" }));\n\nDeno.serve({ port: 8000 }, (request) =&gt; app.handleRequest(request));\n</code></pre>"},{"location":"snippets/typescript/dependency_injection/","title":"Dependency injection","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\n\nconst app = new Spikard();\n\n// Value dependency (singleton)\napp.provide(\"config\", { dbUrl: \"postgresql://localhost/app\" });\n\n// Factory dependency (depends on config, singleton)\napp.provide(\n  \"dbPool\",\n  async ({ config }) =&gt; {\n    // connect using config.dbUrl\n    return { url: config.dbUrl, driver: \"pool\" };\n  },\n  { dependsOn: [\"config\"], singleton: true },\n);\n\napp.addRoute(\n  { method: \"GET\", path: \"/stats\", handler_name: \"stats\", is_async: true },\n  async (req: Request) =&gt; {\n    const deps = req.dependencies ?? {};\n    return { db: deps.dbPool?.url, env: deps.config?.dbUrl };\n  },\n);\n</code></pre>"},{"location":"snippets/typescript/fetch_handler/","title":"Fetch handler","text":"<pre><code>import { Spikard, get, createFetchHandler } from \"spikard-wasm\";\nimport { z } from \"zod\";\n\nconst app = new Spikard();\n\nget(\"/hello\")(async () =&gt; ({ message: \"Hello from the edge!\" }));\n\nconst UserSchema = z.object({ name: z.string(), email: z.string().email() });\n\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\npost(\"/users\", { bodySchema: UserSchema })(async (req) =&gt; {\n  const user = req.json&lt;User&gt;();\n  return { id: 1, ...user };\n});\n\nexport default {\n  fetch: createFetchHandler(app),\n};\n</code></pre>"},{"location":"snippets/typescript/hello_route/","title":"Hello route","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/users/:id\", handler_name: \"getUser\", is_async: true },\n  async (req: Request): Promise&lt;User&gt; =&gt; {\n    const id = Number(req.params[\"id\"] ?? 0);\n    return { id, name: \"Alice\" };\n  },\n);\n\nif (require.main === module) {\n  app.run({ port: 8000 });\n}\n</code></pre>"},{"location":"snippets/typescript/middleware_basic/","title":"Middleware basic","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\n\nconst app = new Spikard();\n\napp.onRequest(async (request: Request): Promise&lt;Request&gt; =&gt; {\n  console.log(`${request.method} ${request.path}`);\n  return request;\n});\n</code></pre>"},{"location":"snippets/typescript/path_params/","title":"Path params","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\n\ninterface OrderResponse {\n  id: number;\n  details: boolean;\n}\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/orders/:order_id\", handler_name: \"getOrder\", is_async: true },\n  async (req: Request): Promise&lt;OrderResponse&gt; =&gt; {\n    const id = Number(req.params[\"order_id\"] ?? 0);\n    const details = req.query[\"details\"] === \"true\";\n    return { id, details };\n  },\n);\n</code></pre>"},{"location":"snippets/typescript/quickstart_routes/","title":"Quickstart routes","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/users/:id\", handler_name: \"getUser\", is_async: true },\n  async (req: Request): Promise&lt;User&gt; =&gt; {\n    const id = Number(req.params[\"id\"] ?? 0);\n    return { id, name: \"Alice\" };\n  },\n);\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/users\",\n    handler_name: \"createUser\",\n    request_schema: UserSchema,\n    response_schema: UserSchema,\n    is_async: true,\n  },\n  async (req: Request): Promise&lt;User&gt; =&gt; UserSchema.parse(req.json()),\n);\n\nif (require.main === module) {\n  app.run({ port: 8000 });\n}\n</code></pre>"},{"location":"snippets/typescript/request_data/","title":"Request data","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst OrderSchema = z.object({\n  id: z.number(),\n  item: z.string(),\n  quantity: z.number().int().positive(),\n  verbose: z.boolean().optional(),\n});\ntype Order = z.infer&lt;typeof OrderSchema&gt;;\n\nconst app = new Spikard();\n\nconst updateOrder = async (req: Request): Promise&lt;Order&gt; =&gt; {\n  const order = OrderSchema.parse(req.json());\n  return { ...order, id: Number(req.params[\"order_id\"] ?? order.id) };\n};\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/orders/:order_id\",\n    handler_name: \"updateOrder\",\n    request_schema: OrderSchema,\n    response_schema: OrderSchema,\n    is_async: true,\n  },\n  updateOrder,\n);\n</code></pre>"},{"location":"snippets/typescript/response_basic/","title":"Response basic","text":"<pre><code>import { Spikard } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"GET\", path: \"/health\", handler_name: \"health\", is_async: true },\n  async () =&gt; ({ status: \"ok\" }),\n);\n</code></pre>"},{"location":"snippets/typescript/routing_basic/","title":"Routing basic","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nconst app = new Spikard();\n\nconst health = async (): Promise&lt;{ status: string }&gt; =&gt; ({ status: \"ok\" });\n\nconst createUser = async (req: Request): Promise&lt;User&gt; =&gt; {\n  return UserSchema.parse(req.json());\n};\n\napp.addRoute(\n  { method: \"GET\", path: \"/health\", handler_name: \"health\", is_async: true },\n  health,\n);\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/users\",\n    handler_name: \"createUser\",\n    request_schema: UserSchema,\n    response_schema: UserSchema,\n    is_async: true,\n  },\n  createUser,\n);\n</code></pre>"},{"location":"snippets/typescript/run_app/","title":"Run app","text":"<pre><code>pnpm ts-node app.ts\n</code></pre>"},{"location":"snippets/typescript/sse/","title":"Sse","text":"<pre><code>import { Spikard, StreamingResponse } from \"spikard\";\n\nconst app = new Spikard();\n\nasync function* sseStream() {\n  for (let i = 0; i &lt; 3; i++) {\n    yield `data: ${JSON.stringify({ tick: i })}\\n\\n`;\n  }\n}\n\napp.addRoute(\n  { method: \"GET\", path: \"/events\", handler_name: \"events\", is_async: true },\n  async () =&gt;\n    new StreamingResponse(sseStream(), {\n      statusCode: 200,\n      headers: { \"Content-Type\": \"text/event-stream\" },\n    }),\n);\n</code></pre>"},{"location":"snippets/typescript/streaming/","title":"Streaming","text":"<pre><code>import { Spikard, StreamingResponse } from \"spikard\";\n\nconst app = new Spikard();\n\nasync function* makeStream() {\n  for (let i = 0; i &lt; 3; i++) {\n    yield JSON.stringify({ tick: i }) + \"\\n\";\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  }\n}\n\napp.addRoute(\n  { method: \"GET\", path: \"/stream\", handler_name: \"stream\", is_async: true },\n  async () =&gt;\n    new StreamingResponse(makeStream(), {\n      statusCode: 200,\n      headers: { \"Content-Type\": \"application/x-ndjson\" },\n    }),\n);\n</code></pre>"},{"location":"snippets/typescript/upload/","title":"Upload","text":"<pre><code>import { Spikard } from \"spikard\";\nimport { UploadFile } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"POST\", path: \"/upload\", handler_name: \"upload\", is_async: true },\n  async (req) =&gt; {\n    const body = req.json&lt;{ file: UploadFile; description?: string }&gt;();\n    const size = body.file.size;\n    return { filename: body.file.filename, size };\n  },\n);\n</code></pre>"},{"location":"snippets/typescript/validation_basic/","title":"Validation basic","text":"<pre><code>import { Spikard, type Request } from \"spikard\";\nimport { z } from \"zod\";\n\nconst PaymentSchema = z.object({\n  id: z.string().uuid(),\n  amount: z.number().positive(),\n});\ntype Payment = z.infer&lt;typeof PaymentSchema&gt;;\n\nconst app = new Spikard();\n\nconst createPayment = async (req: Request): Promise&lt;Payment&gt; =&gt; {\n  return PaymentSchema.parse(req.json());\n};\n\napp.addRoute(\n  {\n    method: \"POST\",\n    path: \"/payments\",\n    handler_name: \"createPayment\",\n    request_schema: PaymentSchema,\n    response_schema: PaymentSchema,\n    is_async: true,\n  },\n  createPayment,\n);\n</code></pre>"},{"location":"snippets/typescript/websocket/","title":"Websocket","text":"<pre><code>import { Spikard } from \"spikard\";\n\nconst app = new Spikard();\n\napp.addRoute(\n  { method: \"WS\", path: \"/ws\", handler_name: \"ws\", is_async: true },\n  async (socket) =&gt; {\n    for await (const message of socket) {\n      await socket.send({ echo: message });\n    }\n  },\n);\n</code></pre>"}]}