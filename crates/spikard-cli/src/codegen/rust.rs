//! Rust code generation from OpenAPI schemas

use super::RustDtoStyle;
use anyhow::Result;
use heck::{ToPascalCase, ToSnakeCase};
use openapiv3::{IntegerFormat, OpenAPI, Operation, ReferenceOr, Schema, SchemaKind, Type, VariantOrUnknownOrEmpty};

pub struct RustGenerator {
    spec: OpenAPI,
    style: RustDtoStyle,
}

impl RustGenerator {
    pub fn new(spec: OpenAPI, style: RustDtoStyle) -> Self {
        Self { spec, style }
    }

    pub fn generate(&self) -> Result<String> {
        let mut output = String::new();
        match self.style {
            RustDtoStyle::SerdeStruct => {}
        }

        output.push_str(&self.generate_header());

        output.push_str(&self.generate_models()?);

        let (handlers, registrations) = self.generate_handlers()?;
        output.push_str(&handlers);
        output.push_str(&self.generate_builder(&registrations));

        output.push_str(&self.generate_main());

        Ok(output)
    }

    fn generate_header(&self) -> String {
        format!(
            r#"// Generated by Spikard OpenAPI code generator
// OpenAPI Version: {}
// Title: {}
// DO NOT EDIT - regenerate from OpenAPI schema

use axum::body::Body;
use axum::http::StatusCode;
use axum::http::Response as HttpResponse;
use schemars::JsonSchema;
use serde::{{Deserialize, Serialize}};
use spikard::{{App, AppError, RequestContext, delete, get, patch, post, put}};

"#,
            self.spec.openapi, self.spec.info.title
        )
    }

    fn generate_models(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Schema Models\n\n");

        if let Some(components) = &self.spec.components {
            for (name, schema_ref) in &components.schemas {
                match schema_ref {
                    ReferenceOr::Item(schema) => {
                        output.push_str(&self.generate_model_struct(name, schema)?);
                        output.push('\n');
                    }
                    ReferenceOr::Reference { .. } => {
                        continue;
                    }
                }
            }
        }

        Ok(output)
    }

    fn generate_model_struct(&self, name: &str, schema: &Schema) -> Result<String> {
        let struct_name = name.to_pascal_case();
        let mut output = String::new();

        if let Some(description) = &schema.schema_data.description {
            output.push_str(&format!("/// {}\n", description));
        }

        output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        output.push_str(&format!("pub struct {} {{\n", struct_name));

        match &schema.schema_kind {
            SchemaKind::Type(Type::Object(obj)) => {
                if obj.properties.is_empty() {
                    output.push_str("    // Empty struct\n");
                } else {
                    for (prop_name, prop_schema_ref) in &obj.properties {
                        let is_required = obj.required.contains(prop_name);
                        let field_name = prop_name.to_snake_case();

                        if !is_required {
                            output.push_str("    #[serde(skip_serializing_if = \"Option::is_none\")]\n");
                        }

                        let type_hint = match prop_schema_ref {
                            ReferenceOr::Item(prop_schema) => Self::schema_to_rust_type(prop_schema, !is_required),
                            ReferenceOr::Reference { reference } => {
                                let ref_name = reference.split('/').next_back().unwrap();
                                let base_type = ref_name.to_pascal_case();
                                if is_required {
                                    base_type
                                } else {
                                    format!("Option<{}>", base_type)
                                }
                            }
                        };

                        output.push_str(&format!("    pub {}: {},\n", field_name, type_hint));
                    }
                }
            }
            _ => {
                output.push_str("    // Unsupported schema type\n");
            }
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Extract type name from a schema reference or inline schema
    fn extract_type_from_schema_ref(&self, schema_ref: &ReferenceOr<Schema>) -> String {
        match schema_ref {
            ReferenceOr::Reference { reference } => {
                let ref_name = reference.split('/').next_back().unwrap();
                ref_name.to_pascal_case()
            }
            ReferenceOr::Item(schema) => Self::schema_to_rust_type(schema, false),
        }
    }

    /// Extract request body type from operation
    fn extract_request_body_type(&self, operation: &Operation) -> Option<String> {
        operation.request_body.as_ref().and_then(|body_ref| match body_ref {
            ReferenceOr::Item(request_body) => request_body.content.get("application/json").and_then(|media_type| {
                media_type
                    .schema
                    .as_ref()
                    .map(|schema_ref| self.extract_type_from_schema_ref(schema_ref))
            }),
            ReferenceOr::Reference { reference } => {
                let ref_name = reference.split('/').next_back().unwrap();
                Some(ref_name.to_pascal_case())
            }
        })
    }

    /// Extract response type from operation (looks for 200/201 responses)
    fn extract_response_type(&self, operation: &Operation) -> Option<String> {
        use openapiv3::StatusCode;

        let response = operation
            .responses
            .responses
            .get(&StatusCode::Code(200))
            .or_else(|| operation.responses.responses.get(&StatusCode::Code(201)))
            .or_else(|| operation.responses.responses.get(&StatusCode::Range(2)));

        if let Some(response_ref) = response {
            match response_ref {
                ReferenceOr::Item(response) => {
                    if let Some(content) = response.content.get("application/json")
                        && let Some(schema_ref) = &content.schema
                    {
                        return Some(self.extract_type_from_schema_ref(schema_ref));
                    }
                }
                ReferenceOr::Reference { reference } => {
                    let ref_name = reference.split('/').next_back().unwrap();
                    return Some(ref_name.to_pascal_case());
                }
            }
        }

        None
    }

    fn schema_to_rust_type(schema: &Schema, optional: bool) -> String {
        let base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "String".to_string(),
            SchemaKind::Type(Type::Number(_)) => "f64".to_string(),
            SchemaKind::Type(Type::Integer(int_type)) => match &int_type.format {
                VariantOrUnknownOrEmpty::Item(IntegerFormat::Int32) => "i32".to_string(),
                VariantOrUnknownOrEmpty::Item(IntegerFormat::Int64) => "i64".to_string(),
                _ => "i64".to_string(),
            },
            SchemaKind::Type(Type::Boolean(_)) => "bool".to_string(),
            SchemaKind::Type(Type::Array(arr)) => {
                let item_type = match &arr.items {
                    Some(ReferenceOr::Item(item_schema)) => Self::schema_to_rust_type(item_schema, false),
                    Some(ReferenceOr::Reference { reference }) => {
                        let ref_name = reference.split('/').next_back().unwrap();
                        ref_name.to_pascal_case()
                    }
                    None => "serde_json::Value".to_string(),
                };
                format!("Vec<{}>", item_type)
            }
            SchemaKind::Type(Type::Object(_)) => "serde_json::Value".to_string(),
            _ => "serde_json::Value".to_string(),
        };

        if optional {
            format!("Option<{}>", base_type)
        } else {
            base_type
        }
    }

    fn generate_handlers(&self) -> Result<(String, String)> {
        let mut handlers = String::from(
            "
// Route Handlers

",
        );
        let mut registrations = String::new();

        for (path, path_item_ref) in &self.spec.paths.paths {
            let path_item = match path_item_ref {
                ReferenceOr::Item(item) => item,
                ReferenceOr::Reference { .. } => continue,
            };

            if let Some(op) = &path_item.get {
                self.append_handler(path, "GET", op, &mut handlers, &mut registrations)?;
            }
            if let Some(op) = &path_item.post {
                self.append_handler(path, "POST", op, &mut handlers, &mut registrations)?;
            }
            if let Some(op) = &path_item.put {
                self.append_handler(path, "PUT", op, &mut handlers, &mut registrations)?;
            }
            if let Some(op) = &path_item.delete {
                self.append_handler(path, "DELETE", op, &mut handlers, &mut registrations)?;
            }
            if let Some(op) = &path_item.patch {
                self.append_handler(path, "PATCH", op, &mut handlers, &mut registrations)?;
            }
        }

        Ok((handlers, registrations))
    }

    fn append_handler(
        &self,
        path: &str,
        method: &str,
        operation: &Operation,
        handlers: &mut String,
        registrations: &mut String,
    ) -> Result<()> {
        let builder_fn = match method {
            "GET" => "get",
            "POST" => "post",
            "PUT" => "put",
            "PATCH" => "patch",
            "DELETE" => "delete",
            _ => return Ok(()),
        };

        let handler_name = operation
            .operation_id
            .as_ref()
            .map(|id| id.to_snake_case())
            .unwrap_or_else(|| format!("{}_{}", method.to_lowercase(), sanitize_identifier(path)));

        let request_type = self.extract_request_body_type(operation);
        let response_type = self.extract_response_type(operation);
        let escaped_path = path.replace('"', "\\\"");

        let mut builder = format!("{}(\"{}\")", builder_fn, escaped_path);
        builder.push_str(&format!(".handler_name(\"{}\")", handler_name));
        if let Some(ref req_ty) = request_type {
            builder.push_str(&format!(".request_body::<{}>()", req_ty));
        }
        if let Some(ref resp_ty) = response_type {
            builder.push_str(&format!(".response_body::<{}>()", resp_ty));
        }
        registrations.push_str(&format!("    app.route({builder}, {handler_name})?;\n"));

        handlers.push_str(&format!(
            "async fn {handler_name}(ctx: RequestContext) -> Result<HttpResponse<Body>, (StatusCode, String)> {{\n"
        ));
        if let Some(req_ty) = request_type {
            handlers.push_str(&format!("    // let body: {ty} = ctx.json()?;\n", ty = req_ty));
        }
        handlers.push_str(&format!("    println!(\"TODO: Implement {method} {path}\");\n"));
        handlers.push_str("    let _ = ctx;\n");
        handlers.push_str("    Err((StatusCode::NOT_IMPLEMENTED, \"Not implemented\".to_string()))\n");
        handlers.push_str("}\n\n");

        Ok(())
    }

    fn generate_builder(&self, registrations: &str) -> String {
        format!(
            "fn build_app() -> Result<App, AppError> {{
    let mut app = App::new();
{regs}    Ok(app)
}}

",
            regs = registrations
        )
    }

    fn generate_main(&self) -> String {
        r"#[tokio::main]
async fn main() -> Result<(), AppError> {
    let app = build_app()?;
    app.run().await
}
"
        .to_string()
    }
}

fn sanitize_identifier(path: &str) -> String {
    path.chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect::<String>()
        .trim_matches('_')
        .to_string()
}
