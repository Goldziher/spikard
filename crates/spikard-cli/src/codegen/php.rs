//! PHP code generation from OpenAPI schemas

use super::PhpDtoStyle;
use anyhow::Result;
use heck::{ToPascalCase, ToSnakeCase};
use openapiv3::{OpenAPI, Operation, Parameter, ReferenceOr, Schema, SchemaKind, Type};

pub struct PhpGenerator {
    spec: OpenAPI,
    style: PhpDtoStyle,
}

impl PhpGenerator {
    pub fn new(spec: OpenAPI, style: PhpDtoStyle) -> Self {
        Self { spec, style }
    }

    /// Generate complete PHP code from OpenAPI spec
    /// Returns the complete PHP file as a string
    pub fn generate(&self) -> Result<String> {
        let mut output = String::new();
        match self.style {
            PhpDtoStyle::ReadonlyClass => {}
        }

        output.push_str(&self.generate_header());
        output.push_str(&self.generate_models()?);
        output.push_str(&self.generate_controllers()?);
        output.push_str(&self.generate_main());

        Ok(output)
    }

    /// Generate PHP file header with strict types and namespace declaration
    fn generate_header(&self) -> String {
        let title = Self::escape_php_string(&self.spec.info.title);
        let openapi = Self::escape_php_string(&self.spec.openapi);

        format!(
            "<?php\n/**\n * Generated by Spikard OpenAPI code generator\n * OpenAPI Version: {}\n * Title: {}\n * DO NOT EDIT - regenerate from OpenAPI schema\n */\n\ndeclare(strict_types=1);\n\nnamespace SpikardGenerated;\n\n",
            openapi, title
        )
    }

    fn generate_models(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Schema Models\n\n");

        if let Some(components) = &self.spec.components {
            for (name, schema_ref) in &components.schemas {
                match schema_ref {
                    ReferenceOr::Item(schema) => {
                        output.push_str(&self.generate_model_class(name, schema)?);
                        output.push('\n');
                    }
                    ReferenceOr::Reference { .. } => {
                        continue;
                    }
                }
            }
        }

        Ok(output)
    }

    /// Generate a PHP model class for an OpenAPI schema
    fn generate_model_class(&self, name: &str, schema: &Schema) -> Result<String> {
        let class_name = name.to_pascal_case();
        let mut output = String::new();

        self.append_php_doc(&mut output, &schema.schema_data.description, &class_name);

        output.push_str(&format!("readonly class {}\n{{\n", class_name));

        match &schema.schema_kind {
            SchemaKind::Type(Type::Object(obj)) => {
                if obj.properties.is_empty() {
                    output.push_str("    // Empty schema\n");
                } else {
                    self.append_constructor(&mut output, obj)?;
                }
            }
            _ => {
                output.push_str("    // Unsupported schema type\n");
            }
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Append PHPDoc comment block to output
    fn append_php_doc(&self, output: &mut String, description: &Option<String>, class_name: &str) {
        output.push_str("/**\n");
        if let Some(desc) = description {
            let escaped = Self::escape_php_string(desc);
            output.push_str(&format!(" * {}\n", escaped));
        } else {
            output.push_str(&format!(" * {} model\n", class_name));
        }
        output.push_str(" */\n");
    }

    /// Append constructor method with typed properties
    fn append_constructor(&self, output: &mut String, obj: &openapiv3::ObjectType) -> Result<()> {
        output.push_str("    public function __construct(\n");

        let property_lines = self.build_constructor_params(obj)?;
        let props_str = property_lines.join("");
        let props_str = props_str.trim_end_matches(",\n").to_string() + "\n";
        output.push_str(&props_str);

        output.push_str("    ) {}\n");
        Ok(())
    }

    /// Build constructor parameter declarations for object properties
    /// Partitions properties so required parameters come first (PHP 8.1+ requirement)
    fn build_constructor_params(&self, obj: &openapiv3::ObjectType) -> Result<Vec<String>> {
        let mut required_props = Vec::new();
        let mut optional_props = Vec::new();

        // First pass: partition properties into required and optional
        for (prop_name, prop_schema_ref) in &obj.properties {
            let is_required = obj.required.contains(prop_name);
            let field_name = Self::to_camel_case(prop_name);

            let (type_hint, nullable) = match prop_schema_ref {
                ReferenceOr::Item(prop_schema) => Self::schema_to_php_type(prop_schema, !is_required),
                ReferenceOr::Reference { reference } => {
                    let ref_name = self.extract_ref_name(reference);
                    let ref_type = ref_name.to_pascal_case();
                    if is_required {
                        (ref_type, false)
                    } else {
                        (format!("?{}", ref_type), true)
                    }
                }
            };

            let prop_line = self.build_property_line(&type_hint, &field_name, is_required, nullable);

            if is_required {
                required_props.push(prop_line);
            } else {
                optional_props.push(prop_line);
            }
        }

        // Combine: required first, then optional
        let mut property_lines = required_props;
        property_lines.extend(optional_props);

        Ok(property_lines)
    }

    /// Build a single property parameter line for constructor
    fn build_property_line(&self, type_hint: &str, field_name: &str, is_required: bool, nullable: bool) -> String {
        if is_required {
            format!("        public {} ${},\n", type_hint, field_name)
        } else if nullable {
            format!("        public {} ${} = null,\n", type_hint, field_name)
        } else {
            format!("        public ?{} ${} = null,\n", type_hint, field_name)
        }
    }

    /// Escape PHP string content for safe output
    /// Handles special characters in PHP string context
    fn escape_php_string(s: &str) -> String {
        s.chars()
            .flat_map(|c| match c {
                '\\' => vec!['\\', '\\'],
                '\'' => vec!['\\', '\''],
                '\n' => vec!['\\', 'n'],
                '\r' => vec!['\\', 'r'],
                '\t' => vec!['\\', 't'],
                _ => vec![c],
            })
            .collect()
    }

    /// Extract the last component of a JSON reference path
    fn extract_ref_name(&self, reference: &str) -> String {
        reference.split('/').next_back().unwrap_or("UnknownType").to_string()
    }

    /// Convert snake_case or kebab-case to camelCase
    fn to_camel_case(s: &str) -> String {
        let snake = s.to_snake_case();
        let mut chars = snake.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => {
                let mut result = first.to_lowercase().collect::<String>();
                let mut capitalize_next = false;
                for c in chars {
                    if c == '_' {
                        capitalize_next = true;
                    } else if capitalize_next {
                        result.push_str(&c.to_uppercase().to_string());
                        capitalize_next = false;
                    } else {
                        result.push(c);
                    }
                }
                result
            }
        }
    }

    /// Extract type name from a schema reference or inline schema
    fn extract_type_from_schema_ref(&self, schema_ref: &ReferenceOr<Schema>) -> String {
        match schema_ref {
            ReferenceOr::Reference { reference } => {
                let ref_name = self.extract_ref_name(reference);
                ref_name.to_pascal_case()
            }
            ReferenceOr::Item(schema) => {
                let (php_type, _) = Self::schema_to_php_type(schema, false);
                php_type
            }
        }
    }

    /// Extract request body type from operation if present
    fn extract_request_body_type(&self, operation: &Operation) -> Option<String> {
        operation.request_body.as_ref().and_then(|body_ref| match body_ref {
            ReferenceOr::Item(request_body) => {
                self.extract_json_schema_type(request_body.content.get("application/json"))
            }
            ReferenceOr::Reference { reference } => {
                let ref_name = self.extract_ref_name(reference);
                Some(ref_name.to_pascal_case())
            }
        })
    }

    /// Extract JSON schema type from media type content
    fn extract_json_schema_type(&self, media_type: Option<&openapiv3::MediaType>) -> Option<String> {
        media_type.and_then(|mt| {
            mt.schema
                .as_ref()
                .map(|schema_ref| self.extract_type_from_schema_ref(schema_ref))
        })
    }

    /// Extract response type from operation (looks for 200/201 responses)
    fn extract_response_type(&self, operation: &Operation) -> String {
        use openapiv3::StatusCode;

        let response = operation
            .responses
            .responses
            .get(&StatusCode::Code(200))
            .or_else(|| operation.responses.responses.get(&StatusCode::Code(201)))
            .or_else(|| operation.responses.responses.get(&StatusCode::Range(2)));

        response
            .and_then(|response_ref| self.extract_response_type_from_ref(response_ref))
            .unwrap_or_else(|| "array".to_string())
    }

    /// Extract response type from a single response reference
    fn extract_response_type_from_ref(&self, response_ref: &ReferenceOr<openapiv3::Response>) -> Option<String> {
        match response_ref {
            ReferenceOr::Item(response) => {
                let media_type = response.content.get("application/json")?;
                let schema_ref = media_type.schema.as_ref()?;
                Some(self.extract_type_from_schema_ref(schema_ref))
            }
            ReferenceOr::Reference { reference } => {
                let ref_name = self.extract_ref_name(reference);
                Some(ref_name.to_pascal_case())
            }
        }
    }

    /// Convert OpenAPI schema to PHP type hint
    /// Returns (type_hint, is_already_nullable)
    /// Uses native PHP type syntax for type hints (valid in PHP 7.4+)
    fn schema_to_php_type(schema: &Schema, optional: bool) -> (String, bool) {
        let base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "string".to_string(),
            SchemaKind::Type(Type::Number(_)) => "float".to_string(),
            SchemaKind::Type(Type::Integer(_)) => "int".to_string(),
            SchemaKind::Type(Type::Boolean(_)) => "bool".to_string(),
            SchemaKind::Type(Type::Array(_)) => {
                // Use plain 'array' for native type hints; generic syntax is only for PHPDoc
                "array".to_string()
            }
            SchemaKind::Type(Type::Object(_)) => "array".to_string(),
            _ => "mixed".to_string(),
        };

        if optional {
            (format!("?{}", base_type), true)
        } else {
            (base_type, false)
        }
    }

    /// Generate PHPDoc type annotation for arrays
    #[allow(dead_code)]
    fn schema_to_phpdoc_type(schema: &Schema, optional: bool) -> String {
        let base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "string".to_string(),
            SchemaKind::Type(Type::Number(_)) => "float".to_string(),
            SchemaKind::Type(Type::Integer(_)) => "int".to_string(),
            SchemaKind::Type(Type::Boolean(_)) => "bool".to_string(),
            SchemaKind::Type(Type::Array(arr)) => {
                let item_type = match &arr.items {
                    Some(ReferenceOr::Item(item_schema)) => Self::schema_to_phpdoc_type(item_schema, false),
                    Some(ReferenceOr::Reference { reference }) => {
                        let ref_name = reference.split('/').next_back().unwrap();
                        ref_name.to_pascal_case()
                    }
                    None => "mixed".to_string(),
                };
                format!("{}[]", item_type)
            }
            SchemaKind::Type(Type::Object(_)) => "array<string, mixed>".to_string(),
            _ => "mixed".to_string(),
        };

        if optional {
            format!("{}|null", base_type)
        } else {
            base_type
        }
    }

    /// Generate all controller classes from API paths
    fn generate_controllers(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("\n// Controller Classes\n\n");

        let controllers = self.group_operations_by_controller();

        for (controller_name, routes) in controllers {
            output.push_str(&self.generate_controller_class(&controller_name, &routes)?);
            output.push('\n');
        }

        Ok(output)
    }

    /// Group operations by controller name based on API path
    fn group_operations_by_controller(&self) -> std::collections::HashMap<String, Vec<(String, String, Operation)>> {
        let mut controllers: std::collections::HashMap<String, Vec<(String, String, Operation)>> =
            std::collections::HashMap::new();

        for (path, path_item_ref) in &self.spec.paths.paths {
            let path_item = match path_item_ref {
                ReferenceOr::Item(item) => item,
                ReferenceOr::Reference { .. } => continue,
            };

            let controller_name = self.extract_controller_name(path);
            self.add_path_operations(&mut controllers, path, &controller_name, path_item);
        }

        controllers
    }

    /// Add all HTTP method operations from a path item to controllers map
    fn add_path_operations(
        &self,
        controllers: &mut std::collections::HashMap<String, Vec<(String, String, Operation)>>,
        path: &str,
        controller_name: &str,
        path_item: &openapiv3::PathItem,
    ) {
        let methods = [
            ("GET", &path_item.get),
            ("POST", &path_item.post),
            ("PUT", &path_item.put),
            ("DELETE", &path_item.delete),
            ("PATCH", &path_item.patch),
        ];

        for (method, op_opt) in methods {
            if let Some(op) = op_opt {
                controllers.entry(controller_name.to_string()).or_default().push((
                    path.to_string(),
                    method.to_string(),
                    op.clone(),
                ));
            }
        }
    }

    fn extract_controller_name(&self, path: &str) -> String {
        let segments: Vec<&str> = path
            .split('/')
            .filter(|s| !s.is_empty() && !s.starts_with('{'))
            .collect();

        if let Some(first_segment) = segments.first() {
            format!("{}Controller", first_segment.to_pascal_case())
        } else {
            "DefaultController".to_string()
        }
    }

    fn generate_controller_class(
        &self,
        controller_name: &str,
        routes: &[(String, String, Operation)],
    ) -> Result<String> {
        let mut output = String::new();

        output.push_str("/**\n");
        output.push_str(&format!(
            " * {} - Generated controller for API routes\n",
            controller_name
        ));
        output.push_str(" */\n");

        output.push_str(&format!("class {}\n{{\n", controller_name));

        for (path, method, operation) in routes {
            output.push_str(&self.generate_route_handler(path, method, operation)?);
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Generate a single route handler method
    fn generate_route_handler(&self, path: &str, method: &str, operation: &Operation) -> Result<String> {
        let mut output = String::new();
        let method_name = self.extract_handler_method_name(operation, method, path);
        let (path_params, query_params, body_type, return_type) =
            self.extract_handler_parameters(operation, &mut output)?;

        output.push_str(&format!(
            "    #[Route('{}', methods: ['{}'])]\n",
            path,
            method.to_uppercase()
        ));

        self.append_function_signature(
            &mut output,
            &method_name,
            &path_params,
            &query_params,
            &body_type,
            &return_type,
        );
        self.append_function_body(&mut output);

        Ok(output)
    }

    /// Extract handler method name from operation ID or generate from path/method
    fn extract_handler_method_name(&self, operation: &Operation, method: &str, path: &str) -> String {
        operation
            .operation_id
            .as_ref()
            .map(|id| Self::to_camel_case(id))
            .unwrap_or_else(|| {
                Self::to_camel_case(&format!(
                    "{}_{}",
                    method.to_lowercase(),
                    path.replace('/', "_").replace(['{', '}'], "").trim_matches('_')
                ))
            })
    }

    /// Extract and document handler parameters from operation
    #[allow(clippy::type_complexity)]
    fn extract_handler_parameters(
        &self,
        operation: &Operation,
        output: &mut String,
    ) -> Result<(
        Vec<(String, String)>,
        Vec<(String, String, bool)>,
        Option<String>,
        String,
    )> {
        output.push_str("    /**\n");
        self.append_operation_description(output, operation);

        let (path_params, query_params) = self.extract_path_and_query_params(operation, output);
        let body_type = self.extract_request_body_type(operation);
        let return_type = self.extract_response_type(operation);

        self.append_parameter_docs(output, &body_type, &return_type);

        Ok((path_params, query_params, body_type, return_type))
    }

    /// Append operation summary and description to PHPDoc
    fn append_operation_description(&self, output: &mut String, operation: &Operation) {
        if let Some(summary) = &operation.summary {
            output.push_str(&format!("     * {}\n", summary));
        }
        if let Some(description) = &operation.description {
            output.push_str(&format!("     * \n     * {}\n", description));
        }
        output.push_str("     * \n");
    }

    /// Extract path and query parameters from operation
    #[allow(clippy::type_complexity)]
    fn extract_path_and_query_params(
        &self,
        operation: &Operation,
        output: &mut String,
    ) -> (Vec<(String, String)>, Vec<(String, String, bool)>) {
        let mut path_params = Vec::new();
        let mut query_params = Vec::new();

        for param_ref in &operation.parameters {
            if let ReferenceOr::Item(param) = param_ref {
                self.process_parameter(param, &mut path_params, &mut query_params, output);
            }
        }

        (path_params, query_params)
    }

    /// Process a single parameter and add to path or query params
    fn process_parameter(
        &self,
        param: &Parameter,
        path_params: &mut Vec<(String, String)>,
        query_params: &mut Vec<(String, String, bool)>,
        output: &mut String,
    ) {
        match param {
            Parameter::Path { parameter_data, .. } => {
                let param_name = Self::to_camel_case(&parameter_data.name);
                path_params.push((param_name.clone(), "string".to_string()));
                output.push_str(&format!("     * @param string ${}\n", param_name));
            }
            Parameter::Query { parameter_data, .. } => {
                let param_name = Self::to_camel_case(&parameter_data.name);
                let required = parameter_data.required;
                query_params.push((param_name.clone(), "string".to_string(), required));
                let type_hint = if required { "string" } else { "string|null" };
                output.push_str(&format!("     * @param {} ${}\n", type_hint, param_name));
            }
            _ => {}
        }
    }

    /// Append parameter documentation to PHPDoc
    fn append_parameter_docs(&self, output: &mut String, body_type: &Option<String>, return_type: &str) {
        if let Some(body_type_name) = body_type {
            output.push_str(&format!("     * @param {} $body\n", body_type_name));
        }
        output.push_str(&format!("     * @return {}\n", return_type));
        output.push_str("     */\n");
    }

    /// Append function signature to output
    fn append_function_signature(
        &self,
        output: &mut String,
        method_name: &str,
        path_params: &[(String, String)],
        query_params: &[(String, String, bool)],
        body_type: &Option<String>,
        return_type: &str,
    ) {
        output.push_str(&format!("    public function {}(", method_name));

        let mut params = Vec::new();

        for (param_name, param_type) in path_params {
            params.push(format!("{} ${}", param_type, param_name));
        }

        for (param_name, param_type, required) in query_params {
            if *required {
                params.push(format!("{} ${}", param_type, param_name));
            } else {
                params.push(format!("?{} ${} = null", param_type, param_name));
            }
        }

        if let Some(body_type_name) = body_type {
            params.push(format!("{} $body", body_type_name));
        }

        output.push_str(&params.join(", "));
        output.push_str(&format!("): {}\n    {{\n", return_type));
    }

    /// Append function body (TODO stub)
    fn append_function_body(&self, output: &mut String) {
        output.push_str("        // TODO: Implement this endpoint\n");
        output.push_str("        throw new \\RuntimeException('Not implemented');\n");
        output.push_str("    }\n\n");
    }

    fn generate_main(&self) -> String {
        format!(
            r#"
// Bootstrap Application
// This section shows how to initialize and run the application

/**
 * Example using Slim Framework 4:
 *
 * require __DIR__ . '/vendor/autoload.php';
 *
 * use Slim\Factory\AppFactory;
 *
 * $app = AppFactory::create();
 *
 * // Register routes
 * // Note: You'll need to manually extract route attributes and register them
 * // or use a library that supports PHP 8 attributes
 *
 * $app->run();
 */

/**
 * Example using Symfony:
 *
 * The #[Route] attributes are compatible with Symfony's routing.
 * Simply ensure the controllers are registered as services and
 * Symfony will automatically discover the routes.
 */

/**
 * Application Information:
 * Title: {}
 * Version: {}
 * OpenAPI: {}
 */
"#,
            self.spec.info.title, self.spec.info.version, self.spec.openapi
        )
    }
}
