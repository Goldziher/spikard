//! PHP code generation from OpenAPI schemas

use super::PhpDtoStyle;
use anyhow::Result;
use heck::{ToPascalCase, ToSnakeCase};
use openapiv3::{OpenAPI, Operation, Parameter, ReferenceOr, Schema, SchemaKind, Type};

pub struct PhpGenerator {
    spec: OpenAPI,
    style: PhpDtoStyle,
}

impl PhpGenerator {
    pub fn new(spec: OpenAPI, style: PhpDtoStyle) -> Self {
        Self { spec, style }
    }

    pub fn generate(&self) -> Result<String> {
        let mut output = String::new();
        match self.style {
            PhpDtoStyle::ReadonlyClass => {}
        }

        // Generate file header
        output.push_str(&self.generate_header());

        // Generate schema models
        output.push_str(&self.generate_models()?);

        // Generate controller classes with routes
        output.push_str(&self.generate_controllers()?);

        // Generate bootstrap code
        output.push_str(&self.generate_main());

        Ok(output)
    }

    fn generate_header(&self) -> String {
        format!(
            r#"<?php
/**
 * Generated by Spikard OpenAPI code generator
 * OpenAPI Version: {}
 * Title: {}
 * DO NOT EDIT - regenerate from OpenAPI schema
 */

declare(strict_types=1);

namespace SpikardGenerated;

"#,
            self.spec.openapi, self.spec.info.title
        )
    }

    fn generate_models(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Schema Models\n\n");

        if let Some(components) = &self.spec.components {
            for (name, schema_ref) in &components.schemas {
                match schema_ref {
                    ReferenceOr::Item(schema) => {
                        output.push_str(&self.generate_model_class(name, schema)?);
                        output.push('\n');
                    }
                    ReferenceOr::Reference { .. } => {
                        // Skip references - they'll be resolved when used
                        continue;
                    }
                }
            }
        }

        Ok(output)
    }

    fn generate_model_class(&self, name: &str, schema: &Schema) -> Result<String> {
        let class_name = name.to_pascal_case();
        let mut output = String::new();

        // Generate PHPDoc comment
        output.push_str("/**\n");
        if let Some(description) = &schema.schema_data.description {
            output.push_str(&format!(" * {}\n", description));
        } else {
            output.push_str(&format!(" * {} model\n", class_name));
        }
        output.push_str(" */\n");

        // Start class definition with readonly keyword for immutability
        output.push_str(&format!("readonly class {}\n{{\n", class_name));

        match &schema.schema_kind {
            SchemaKind::Type(Type::Object(obj)) => {
                if obj.properties.is_empty() {
                    // Empty class - just add a comment
                    output.push_str("    // Empty schema\n");
                } else {
                    // Generate constructor with promoted properties (PHP 8.0+ feature)
                    output.push_str("    public function __construct(\n");

                    let mut property_lines = Vec::new();

                    for (prop_name, prop_schema_ref) in &obj.properties {
                        let is_required = obj.required.contains(prop_name);
                        let field_name = Self::to_camel_case(prop_name);

                        let (type_hint, nullable) = match prop_schema_ref {
                            ReferenceOr::Item(prop_schema) => Self::schema_to_php_type(prop_schema, !is_required),
                            ReferenceOr::Reference { reference } => {
                                let ref_name = reference.split('/').next_back().unwrap();
                                let ref_type = ref_name.to_pascal_case();
                                if is_required {
                                    (ref_type, false)
                                } else {
                                    (format!("?{}", ref_type), true)
                                }
                            }
                        };

                        // Generate PHPDoc for property
                        let mut prop_line = String::new();

                        // Build property declaration
                        if is_required {
                            prop_line.push_str(&format!("        public {} ${},\n", type_hint, field_name));
                        } else if nullable {
                            prop_line.push_str(&format!("        public {} ${} = null,\n", type_hint, field_name));
                        } else {
                            prop_line.push_str(&format!("        public ?{} ${} = null,\n", type_hint, field_name));
                        }

                        property_lines.push(prop_line);
                    }

                    // Join all properties, removing trailing comma from last one
                    let props_str = property_lines.join("");
                    let props_str = props_str.trim_end_matches(",\n").to_string() + "\n";
                    output.push_str(&props_str);

                    output.push_str("    ) {}\n");
                }
            }
            _ => {
                output.push_str("    // Unsupported schema type\n");
            }
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Convert snake_case or kebab-case to camelCase
    fn to_camel_case(s: &str) -> String {
        let snake = s.to_snake_case();
        let mut chars = snake.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => {
                let mut result = first.to_lowercase().collect::<String>();
                let mut capitalize_next = false;
                for c in chars {
                    if c == '_' {
                        capitalize_next = true;
                    } else if capitalize_next {
                        result.push_str(&c.to_uppercase().to_string());
                        capitalize_next = false;
                    } else {
                        result.push(c);
                    }
                }
                result
            }
        }
    }

    /// Extract type name from a schema reference or inline schema
    fn extract_type_from_schema_ref(&self, schema_ref: &ReferenceOr<Schema>) -> String {
        match schema_ref {
            ReferenceOr::Reference { reference } => {
                // Extract name from #/components/schemas/Pet -> Pet
                let ref_name = reference.split('/').next_back().unwrap();
                ref_name.to_pascal_case()
            }
            ReferenceOr::Item(schema) => {
                let (php_type, _) = Self::schema_to_php_type(schema, false);
                php_type
            }
        }
    }

    /// Extract request body type from operation
    fn extract_request_body_type(&self, operation: &Operation) -> Option<String> {
        operation.request_body.as_ref().and_then(|body_ref| match body_ref {
            ReferenceOr::Item(request_body) => request_body.content.get("application/json").and_then(|media_type| {
                media_type
                    .schema
                    .as_ref()
                    .map(|schema_ref| self.extract_type_from_schema_ref(schema_ref))
            }),
            ReferenceOr::Reference { reference } => {
                let ref_name = reference.split('/').next_back().unwrap();
                Some(ref_name.to_pascal_case())
            }
        })
    }

    /// Extract response type from operation (looks for 200/201 responses)
    fn extract_response_type(&self, operation: &Operation) -> String {
        use openapiv3::StatusCode;

        // Try to find a successful response (200, 201, 2XX)
        let response = operation
            .responses
            .responses
            .get(&StatusCode::Code(200))
            .or_else(|| operation.responses.responses.get(&StatusCode::Code(201)))
            .or_else(|| operation.responses.responses.get(&StatusCode::Range(2)));

        if let Some(response_ref) = response {
            match response_ref {
                ReferenceOr::Item(response) => {
                    if let Some(content) = response.content.get("application/json")
                        && let Some(schema_ref) = &content.schema
                    {
                        return self.extract_type_from_schema_ref(schema_ref);
                    }
                }
                ReferenceOr::Reference { reference } => {
                    let ref_name = reference.split('/').next_back().unwrap();
                    return ref_name.to_pascal_case();
                }
            }
        }

        // Default to array if no schema found
        "array".to_string()
    }

    /// Convert OpenAPI schema to PHP type hint
    /// Returns (type_hint, is_already_nullable)
    fn schema_to_php_type(schema: &Schema, optional: bool) -> (String, bool) {
        let base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "string",
            SchemaKind::Type(Type::Number(_)) => "float",
            SchemaKind::Type(Type::Integer(_)) => "int",
            SchemaKind::Type(Type::Boolean(_)) => "bool",
            SchemaKind::Type(Type::Array(arr)) => {
                let _item_type = match &arr.items {
                    Some(ReferenceOr::Item(item_schema)) => {
                        let (item_type, _) = Self::schema_to_php_type(item_schema, false);
                        item_type
                    }
                    Some(ReferenceOr::Reference { reference }) => {
                        let ref_name = reference.split('/').next_back().unwrap();
                        ref_name.to_pascal_case()
                    }
                    None => "mixed".to_string(),
                };
                // PHP uses array for all arrays, type information is in PHPDoc
                "array"
            }
            SchemaKind::Type(Type::Object(_)) => "array",
            _ => "mixed",
        };

        if optional {
            (format!("?{}", base_type), true)
        } else {
            (base_type.to_string(), false)
        }
    }

    /// Generate PHPDoc type annotation for arrays
    #[allow(dead_code)]
    fn schema_to_phpdoc_type(schema: &Schema, optional: bool) -> String {
        let base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "string".to_string(),
            SchemaKind::Type(Type::Number(_)) => "float".to_string(),
            SchemaKind::Type(Type::Integer(_)) => "int".to_string(),
            SchemaKind::Type(Type::Boolean(_)) => "bool".to_string(),
            SchemaKind::Type(Type::Array(arr)) => {
                let item_type = match &arr.items {
                    Some(ReferenceOr::Item(item_schema)) => Self::schema_to_phpdoc_type(item_schema, false),
                    Some(ReferenceOr::Reference { reference }) => {
                        let ref_name = reference.split('/').next_back().unwrap();
                        ref_name.to_pascal_case()
                    }
                    None => "mixed".to_string(),
                };
                format!("{}[]", item_type)
            }
            SchemaKind::Type(Type::Object(_)) => "array<string, mixed>".to_string(),
            _ => "mixed".to_string(),
        };

        if optional {
            format!("{}|null", base_type)
        } else {
            base_type
        }
    }

    fn generate_controllers(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("\n// Controller Classes\n\n");

        // Group routes by a common prefix or create a single controller
        // For simplicity, we'll create one controller per top-level resource
        let mut controllers: std::collections::HashMap<String, Vec<(String, String, Operation)>> =
            std::collections::HashMap::new();

        for (path, path_item_ref) in &self.spec.paths.paths {
            let path_item = match path_item_ref {
                ReferenceOr::Item(item) => item,
                ReferenceOr::Reference { .. } => continue,
            };

            // Extract controller name from path (e.g., /pets -> PetController)
            let controller_name = self.extract_controller_name(path);

            // Generate route for each HTTP method
            if let Some(op) = &path_item.get {
                controllers.entry(controller_name.clone()).or_default().push((
                    path.clone(),
                    "GET".to_string(),
                    op.clone(),
                ));
            }
            if let Some(op) = &path_item.post {
                controllers.entry(controller_name.clone()).or_default().push((
                    path.clone(),
                    "POST".to_string(),
                    op.clone(),
                ));
            }
            if let Some(op) = &path_item.put {
                controllers.entry(controller_name.clone()).or_default().push((
                    path.clone(),
                    "PUT".to_string(),
                    op.clone(),
                ));
            }
            if let Some(op) = &path_item.delete {
                controllers.entry(controller_name.clone()).or_default().push((
                    path.clone(),
                    "DELETE".to_string(),
                    op.clone(),
                ));
            }
            if let Some(op) = &path_item.patch {
                controllers.entry(controller_name.clone()).or_default().push((
                    path.clone(),
                    "PATCH".to_string(),
                    op.clone(),
                ));
            }
        }

        // Generate each controller class
        for (controller_name, routes) in controllers {
            output.push_str(&self.generate_controller_class(&controller_name, &routes)?);
            output.push('\n');
        }

        Ok(output)
    }

    fn extract_controller_name(&self, path: &str) -> String {
        // Extract first path segment as controller name
        // /pets -> PetController
        // /pets/{id} -> PetController
        // /api/v1/users -> UserController
        let segments: Vec<&str> = path
            .split('/')
            .filter(|s| !s.is_empty() && !s.starts_with('{'))
            .collect();

        if let Some(first_segment) = segments.first() {
            format!("{}Controller", first_segment.to_pascal_case())
        } else {
            "DefaultController".to_string()
        }
    }

    fn generate_controller_class(
        &self,
        controller_name: &str,
        routes: &[(String, String, Operation)],
    ) -> Result<String> {
        let mut output = String::new();

        // Generate class PHPDoc
        output.push_str("/**\n");
        output.push_str(&format!(
            " * {} - Generated controller for API routes\n",
            controller_name
        ));
        output.push_str(" */\n");

        output.push_str(&format!("class {}\n{{\n", controller_name));

        // Generate each route handler method
        for (path, method, operation) in routes {
            output.push_str(&self.generate_route_handler(path, method, operation)?);
        }

        output.push_str("}\n");

        Ok(output)
    }

    fn generate_route_handler(&self, path: &str, method: &str, operation: &Operation) -> Result<String> {
        let mut output = String::new();

        // Generate PHPDoc comment
        output.push_str("    /**\n");
        if let Some(summary) = &operation.summary {
            output.push_str(&format!("     * {}\n", summary));
        }
        if let Some(description) = &operation.description {
            output.push_str(&format!("     * \n     * {}\n", description));
        }
        output.push_str("     * \n");

        // Convert operation_id to method name, or generate one
        let method_name = operation
            .operation_id
            .as_ref()
            .map(|id| Self::to_camel_case(id))
            .unwrap_or_else(|| {
                Self::to_camel_case(&format!(
                    "{}_{}",
                    method.to_lowercase(),
                    path.replace('/', "_").replace(['{', '}'], "").trim_matches('_')
                ))
            });

        // Parse parameters
        let mut path_params = Vec::new();
        let mut query_params = Vec::new();

        for param_ref in &operation.parameters {
            if let ReferenceOr::Item(param) = param_ref {
                match param {
                    Parameter::Path { parameter_data, .. } => {
                        let param_name = Self::to_camel_case(&parameter_data.name);
                        let param_type = "string".to_string(); // Simplified
                        path_params.push((param_name, param_type));
                        output.push_str(&format!(
                            "     * @param string ${}\n",
                            Self::to_camel_case(&parameter_data.name)
                        ));
                    }
                    Parameter::Query { parameter_data, .. } => {
                        let param_name = Self::to_camel_case(&parameter_data.name);
                        let param_type = "string".to_string(); // Simplified
                        let required = parameter_data.required;
                        query_params.push((param_name.clone(), param_type, required));
                        if required {
                            output.push_str(&format!("     * @param string ${}\n", param_name));
                        } else {
                            output.push_str(&format!("     * @param string|null ${}\n", param_name));
                        }
                    }
                    _ => {}
                }
            }
        }

        // Extract request body type
        let body_type = self.extract_request_body_type(operation);
        if let Some(ref body_type_name) = body_type {
            output.push_str(&format!("     * @param {} $body\n", body_type_name));
        }

        // Extract response type
        let return_type = self.extract_response_type(operation);
        output.push_str(&format!("     * @return {}\n", return_type));
        output.push_str("     */\n");

        // Generate Route attribute
        output.push_str(&format!(
            "    #[Route('{}', methods: ['{}'])]\n",
            path,
            method.to_uppercase()
        ));

        // Generate method signature
        output.push_str(&format!("    public function {}(", method_name));

        let mut params = Vec::new();

        // Add path parameters
        for (param_name, param_type) in &path_params {
            params.push(format!("{} ${}", param_type, param_name));
        }

        // Add query parameters
        for (param_name, param_type, required) in &query_params {
            if *required {
                params.push(format!("{} ${}", param_type, param_name));
            } else {
                params.push(format!("?{} ${} = null", param_type, param_name));
            }
        }

        // Add body parameter
        if let Some(body_type_name) = &body_type {
            params.push(format!("{} $body", body_type_name));
        }

        output.push_str(&params.join(", "));
        output.push_str(&format!("): {}\n    {{\n", return_type));

        // Generate method body
        output.push_str("        // TODO: Implement this endpoint\n");
        output.push_str("        throw new \\RuntimeException('Not implemented');\n");
        output.push_str("    }\n\n");

        Ok(output)
    }

    fn generate_main(&self) -> String {
        format!(
            r#"
// Bootstrap Application
// This section shows how to initialize and run the application

/**
 * Example using Slim Framework 4:
 *
 * require __DIR__ . '/vendor/autoload.php';
 *
 * use Slim\Factory\AppFactory;
 *
 * $app = AppFactory::create();
 *
 * // Register routes
 * // Note: You'll need to manually extract route attributes and register them
 * // or use a library that supports PHP 8 attributes
 *
 * $app->run();
 */

/**
 * Example using Symfony:
 *
 * The #[Route] attributes are compatible with Symfony's routing.
 * Simply ensure the controllers are registered as services and
 * Symfony will automatically discover the routes.
 */

/**
 * Application Information:
 * Title: {}
 * Version: {}
 * OpenAPI: {}
 */
"#,
            self.spec.info.title, self.spec.info.version, self.spec.openapi
        )
    }
}
