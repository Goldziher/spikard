//! Python code generation from `OpenAPI` schemas

use super::{PythonDtoStyle, SchemaRegistry};
use anyhow::{Result, bail};
use heck::{ToPascalCase, ToSnakeCase};
use openapiv3::{OpenAPI, Operation, Parameter, ReferenceOr, Schema, SchemaKind, Type};

pub struct PythonGenerator {
    spec: OpenAPI,
    dto: PythonDtoStyle,
    registry: SchemaRegistry,
}

impl PythonGenerator {
    #[must_use]
    pub fn new(spec: OpenAPI, dto: PythonDtoStyle) -> Self {
        let registry = SchemaRegistry::from_spec(&spec);
        Self { spec, dto, registry }
    }

    pub fn generate(&self) -> Result<String> {
        let mut output = String::new();

        output.push_str(&self.generate_header());

        output.push_str(&self.generate_models()?);

        output.push_str(&self.generate_routes()?);

        output.push_str(&self.generate_main());

        Ok(output)
    }

    fn generate_header(&self) -> String {
        let mut header = String::new();
        header.push_str("from __future__ import annotations\n\n");

        match self.dto {
            PythonDtoStyle::Dataclass => {
                header.push_str(&format!(
                    r"# Generated by Spikard OpenAPI code generator
# OpenAPI Version: {}
# Title: {}
# DO NOT EDIT - regenerate from OpenAPI schema

from dataclasses import dataclass
from typing import Any
from spikard import Body, Path, Query, Request, Spikard, route

app = Spikard()

",
                    self.spec.openapi, self.spec.info.title,
                ));
            }
            PythonDtoStyle::Msgspec => {
                header.push_str(&format!(
                    r"# Generated by Spikard OpenAPI code generator
# OpenAPI Version: {}
# Title: {}
# DO NOT EDIT - regenerate from OpenAPI schema

import msgspec
from typing import Any

from spikard import Body, Path, Query, Request, Spikard, route

app = Spikard()

",
                    self.spec.openapi, self.spec.info.title,
                ));
            }
        }

        header
    }

    fn generate_models(&self) -> Result<String> {
        if self.dto == PythonDtoStyle::Msgspec {
            return self.generate_msgspec_models();
        }
        self.generate_dataclass_models()
    }

    fn generate_dataclass_models(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Schema Models\n\n");

        if let Some(components) = &self.spec.components {
            for (name, schema_ref) in &components.schemas {
                match schema_ref {
                    ReferenceOr::Item(schema) => {
                        output.push_str(&self.generate_dataclass(name, schema)?);
                        output.push('\n');
                    }
                    ReferenceOr::Reference { .. } => continue,
                }
            }
        }

        Ok(output)
    }

    fn generate_msgspec_models(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Schema Models\n\n");

        if let Some(components) = &self.spec.components {
            for (name, schema_ref) in &components.schemas {
                match schema_ref {
                    ReferenceOr::Item(schema) => {
                        output.push_str(&self.generate_msgspec_struct(name, schema)?);
                        output.push('\n');
                    }
                    ReferenceOr::Reference { .. } => continue,
                }
            }
        }

        Ok(output)
    }

    fn generate_dataclass(&self, name: &str, schema: &Schema) -> Result<String> {
        if self.dto != PythonDtoStyle::Dataclass {
            bail!("dataclass generation called for non-dataclass style");
        }

        let mut output = String::new();
        let class_name = name.to_pascal_case();

        if let Some(description) = &schema.schema_data.description {
            output.push_str(&format!("\"\"\" {description} \"\"\"\n"));
        }

        output.push_str("@dataclass(slots=True, kw_only=True)\n");
        output.push_str(&format!("class {class_name}:\n"));

        match &schema.schema_kind {
            SchemaKind::Type(Type::Object(obj)) => {
                if obj.properties.is_empty() {
                    output.push_str("    pass\n");
                } else {
                    for (prop_name, prop_schema_ref) in &obj.properties {
                        let is_required = obj.required.contains(prop_name);
                        let field_name = prop_name.to_snake_case();
                        let type_hint = self.python_type_from_boxed_schema_ref(prop_schema_ref, !is_required);

                        if is_required {
                            output.push_str(&format!("    {field_name}: {type_hint}\n"));
                        } else {
                            output.push_str(&format!("    {field_name}: {type_hint} = None\n"));
                        }
                    }
                }
            }
            _ => output.push_str("    pass  # Unsupported schema type\n"),
        }

        Ok(output)
    }

    fn generate_msgspec_struct(&self, name: &str, schema: &Schema) -> Result<String> {
        let class_name = name.to_pascal_case();
        let mut output = String::new();

        if let Some(description) = &schema.schema_data.description {
            output.push_str(&format!("\"\"\" {description} \"\"\"\n"));
        }

        output.push_str(&format!("class {class_name}(msgspec.Struct):\n"));

        match &schema.schema_kind {
            SchemaKind::Type(Type::Object(obj)) => {
                if obj.properties.is_empty() {
                    output.push_str("    pass\n");
                } else {
                    for (prop_name, prop_schema_ref) in &obj.properties {
                        let is_required = obj.required.contains(prop_name);
                        let field_name = prop_name.to_snake_case();

                        let type_hint = self.python_type_from_boxed_schema_ref(prop_schema_ref, !is_required);

                        if is_required {
                            output.push_str(&format!("    {field_name}: {type_hint}\n"));
                        } else {
                            output.push_str(&format!("    {field_name}: {type_hint} = None\n"));
                        }
                    }
                }
            }
            _ => {
                output.push_str("    pass  # Unsupported schema type\n");
            }
        }

        Ok(output)
    }

    /// Extract type name from a schema reference or inline schema
    fn extract_type_from_schema_ref(&self, schema_ref: &ReferenceOr<Schema>) -> String {
        self.python_type_from_schema_ref(schema_ref, false)
    }

    /// Extract request body type from operation
    fn extract_request_body_type(&self, operation: &Operation) -> Option<String> {
        operation.request_body.as_ref().and_then(|body_ref| match body_ref {
            ReferenceOr::Item(request_body) => request_body.content.get("application/json").and_then(|media_type| {
                media_type
                    .schema
                    .as_ref()
                    .map(|schema_ref| self.extract_type_from_schema_ref(schema_ref))
            }),
            ReferenceOr::Reference { reference } => {
                let ref_name = reference.split('/').next_back().unwrap();
                Some(ref_name.to_pascal_case())
            }
        })
    }

    /// Extract response type from operation (looks for 200/201 responses)
    fn extract_response_type(&self, operation: &Operation) -> String {
        use openapiv3::StatusCode;

        let response = operation
            .responses
            .responses
            .get(&StatusCode::Code(200))
            .or_else(|| operation.responses.responses.get(&StatusCode::Code(201)))
            .or_else(|| operation.responses.responses.get(&StatusCode::Range(2)));

        if let Some(response_ref) = response {
            match response_ref {
                ReferenceOr::Item(response) => {
                    if let Some(content) = response.content.get("application/json")
                        && let Some(schema_ref) = &content.schema
                    {
                        return self.extract_type_from_schema_ref(schema_ref);
                    }
                }
                ReferenceOr::Reference { reference } => {
                    let ref_name = reference.split('/').next_back().unwrap();
                    return ref_name.to_pascal_case();
                }
            }
        }

        "dict[str, Any]".to_string()
    }

    fn python_type_from_schema_ref(&self, schema_ref: &ReferenceOr<Schema>, optional: bool) -> String {
        match schema_ref {
            ReferenceOr::Item(schema) => self.schema_to_python_type(schema, optional),
            ReferenceOr::Reference { reference } => self.python_type_from_reference(reference, optional),
        }
    }

    fn python_type_from_boxed_schema_ref(&self, schema_ref: &ReferenceOr<Box<Schema>>, optional: bool) -> String {
        match schema_ref {
            ReferenceOr::Item(schema) => self.schema_to_python_type(schema, optional),
            ReferenceOr::Reference { reference } => self.python_type_from_reference(reference, optional),
        }
    }

    fn python_type_from_reference(&self, reference: &str, optional: bool) -> String {
        let mut base = reference.split('/').next_back().unwrap().to_pascal_case();
        if let Some(schema) = self.registry.resolve_reference(reference)
            && schema.schema_data.nullable
        {
            base = self.append_optional(base, true);
        }
        self.append_optional(base, optional)
    }

    #[allow(clippy::only_used_in_recursion)]
    fn schema_to_python_type(&self, schema: &Schema, optional: bool) -> String {
        let mut base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "str".to_string(),
            SchemaKind::Type(Type::Number(_)) => "float".to_string(),
            SchemaKind::Type(Type::Integer(_)) => "int".to_string(),
            SchemaKind::Type(Type::Boolean(_)) => "bool".to_string(),
            SchemaKind::Type(Type::Array(arr)) => {
                let item_type = match &arr.items {
                    Some(item_schema) => self.python_type_from_boxed_schema_ref(item_schema, false),
                    None => "dict[str, Any]".to_string(),
                };
                format!("list[{item_type}]")
            }
            SchemaKind::Type(Type::Object(_)) => "dict[str, Any]".to_string(),
            _ => "dict[str, Any]".to_string(),
        };

        if schema.schema_data.nullable {
            base_type = self.append_optional(base_type, true);
        }

        self.append_optional(base_type, optional)
    }

    fn append_optional(&self, base: String, optional: bool) -> String {
        if optional && !base.trim().ends_with("| None") {
            format!("{base} | None")
        } else {
            base
        }
    }

    fn generate_routes(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("\n# Route Handlers\n\n");

        for (path, path_item_ref) in &self.spec.paths.paths {
            let path_item = match path_item_ref {
                ReferenceOr::Item(item) => item,
                ReferenceOr::Reference { .. } => continue,
            };

            if let Some(op) = &path_item.get {
                output.push_str(&self.generate_route_handler(path, "get", op)?);
            }
            if let Some(op) = &path_item.post {
                output.push_str(&self.generate_route_handler(path, "post", op)?);
            }
            if let Some(op) = &path_item.put {
                output.push_str(&self.generate_route_handler(path, "put", op)?);
            }
            if let Some(op) = &path_item.delete {
                output.push_str(&self.generate_route_handler(path, "delete", op)?);
            }
            if let Some(op) = &path_item.patch {
                output.push_str(&self.generate_route_handler(path, "patch", op)?);
            }
        }

        Ok(output)
    }

    fn generate_route_handler(&self, path: &str, method: &str, operation: &Operation) -> Result<String> {
        let mut output = String::new();

        if let Some(summary) = &operation.summary {
            output.push_str(&format!("\"\"\" {summary} \"\"\"\n"));
        }

        let func_name = operation
            .operation_id
            .as_ref()
            .map(|id| id.to_snake_case())
            .unwrap_or_else(|| {
                format!(
                    "{}_{}",
                    method,
                    path.replace('/', "_").replace(['{', '}'], "").trim_matches('_')
                )
            });

        let mut path_params = Vec::new();
        let mut query_params = Vec::new();

        for param_ref in &operation.parameters {
            if let ReferenceOr::Item(param) = param_ref {
                match param {
                    Parameter::Path { parameter_data, .. } => {
                        path_params.push((parameter_data.name.clone(), "str".to_string()));
                    }
                    Parameter::Query { parameter_data, .. } => {
                        let type_hint = "str".to_string();
                        query_params.push((parameter_data.name.clone(), type_hint, parameter_data.required));
                    }
                    _ => {}
                }
            }
        }

        let body_type = self.extract_request_body_type(operation);

        let return_type = self.extract_response_type(operation);

        output.push_str(&format!(
            "@route(\"{}\", methods=[\"{}\"])\n",
            path,
            method.to_uppercase()
        ));

        output.push_str(&format!("def {func_name}(request: Request"));

        for (param_name, param_type) in &path_params {
            output.push_str(&format!(", {}: Path[{}]", param_name.to_snake_case(), param_type));
        }

        for (param_name, param_type, required) in &query_params {
            if *required {
                output.push_str(&format!(", {}: Query[{}]", param_name.to_snake_case(), param_type));
            } else {
                output.push_str(&format!(
                    ", {}: Query[{} | None] = Query(default=None)",
                    param_name.to_snake_case(),
                    param_type
                ));
            }
        }

        if let Some(body_type_name) = &body_type {
            output.push_str(&format!(", body: Body[{body_type_name}]"));
        }

        output.push_str(&format!(") -> {return_type}:\n"));

        if let Some(desc) = &operation.description {
            output.push_str(&format!("    \"\"\"\n    {desc}\n    \"\"\"\n"));
        }

        output.push_str("    raise NotImplementedError(\"TODO: Implement this endpoint\")\n\n");

        Ok(output)
    }

    fn generate_main(&self) -> String {
        r#"
# Run the application
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
"#
        .to_string()
    }
}
