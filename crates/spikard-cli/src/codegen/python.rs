//! Python code generation from OpenAPI schemas

use anyhow::Result;
use heck::{ToSnakeCase, ToPascalCase};
use openapiv3::{OpenAPI, ReferenceOr, Schema, SchemaKind, Type, Operation, Parameter};

pub struct PythonGenerator {
    spec: OpenAPI,
}

impl PythonGenerator {
    pub fn new(spec: OpenAPI) -> Self {
        Self { spec }
    }
    
    pub fn generate(&self) -> Result<String> {
        let mut output = String::new();
        
        // Generate file header
        output.push_str(&self.generate_header());
        
        // Generate schema models
        output.push_str(&self.generate_models()?);
        
        // Generate routes
        output.push_str(&self.generate_routes()?);
        
        // Generate main block
        output.push_str(&self.generate_main());
        
        Ok(output)
    }
    
    fn generate_header(&self) -> String {
        format!(
            r#"# Generated by Spikard OpenAPI code generator
# OpenAPI Version: {}
# Title: {}
# DO NOT EDIT - regenerate from OpenAPI schema

from dataclasses import dataclass
from typing import Optional, List, Dict, Any
from spikard import Spikard, Request, route, Query, Path, Body, Header

app = Spikard()

"#,
            self.spec.openapi,
            self.spec.info.title
        )
    }
    
    fn generate_models(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Schema Models\n\n");
        
        if let Some(components) = &self.spec.components {
            for (name, schema_ref) in &components.schemas {
                match schema_ref {
                    ReferenceOr::Item(schema) => {
                        output.push_str(&self.generate_model_class(name, schema)?);
                        output.push('\n');
                    }
                    ReferenceOr::Reference { .. } => {
                        // Skip references - they'll be resolved when used
                        continue;
                    }
                }
            }
        }
        
        Ok(output)
    }
    
    fn generate_model_class(&self, name: &str, schema: &Schema) -> Result<String> {
        let class_name = name.to_pascal_case();
        let mut output = String::new();
        
        if let Some(description) = &schema.schema_data.description {
            output.push_str(&format!("\"\"\" {} \"\"\"\n", description));
        }
        
        output.push_str("@dataclass\n");
        output.push_str(&format!("class {}:\n", class_name));
        
        match &schema.schema_kind {
            SchemaKind::Type(Type::Object(obj)) => {
                if obj.properties.is_empty() {
                    output.push_str("    pass\n");
                } else {
                    for (prop_name, prop_schema_ref) in &obj.properties {
                        let is_required = obj.required.contains(prop_name);
                        let field_name = prop_name.to_snake_case();
                        
                        let type_hint = match prop_schema_ref {
                            ReferenceOr::Item(prop_schema) => {
                                self.schema_to_python_type(prop_schema, !is_required)
                            }
                            ReferenceOr::Reference { reference } => {
                                let ref_name = reference.split('/').last().unwrap();
                                if is_required {
                                    ref_name.to_pascal_case()
                                } else {
                                    format!("Optional[{}]", ref_name.to_pascal_case())
                                }
                            }
                        };
                        
                        if is_required {
                            output.push_str(&format!("    {}: {}\n", field_name, type_hint));
                        } else {
                            output.push_str(&format!("    {}: {} = None\n", field_name, type_hint));
                        }
                    }
                }
            }
            _ => {
                output.push_str("    pass  # Unsupported schema type\n");
            }
        }
        
        Ok(output)
    }
    
    fn schema_to_python_type(&self, schema: &Schema, optional: bool) -> String {
        let base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "str".to_string(),
            SchemaKind::Type(Type::Number(_)) => "float".to_string(),
            SchemaKind::Type(Type::Integer(_)) => "int".to_string(),
            SchemaKind::Type(Type::Boolean(_)) => "bool".to_string(),
            SchemaKind::Type(Type::Array(arr)) => {
                let item_type = match &arr.items {
                    Some(ReferenceOr::Item(item_schema)) => {
                        self.schema_to_python_type(item_schema, false)
                    }
                    Some(ReferenceOr::Reference { reference }) => {
                        let ref_name = reference.split('/').last().unwrap();
                        ref_name.to_pascal_case()
                    }
                    None => "Any".to_string(),
                };
                format!("List[{}]", item_type)
            }
            SchemaKind::Type(Type::Object(_)) => "Dict[str, Any]".to_string(),
            _ => "Any".to_string(),
        };
        
        if optional {
            format!("Optional[{}]", base_type)
        } else {
            base_type
        }
    }
    
    fn generate_routes(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("\n# Route Handlers\n\n");
        
        for (path, path_item_ref) in &self.spec.paths.paths {
            let path_item = match path_item_ref {
                ReferenceOr::Item(item) => item,
                ReferenceOr::Reference { .. } => continue,
            };
            
            // Generate route for each HTTP method
            if let Some(op) = &path_item.get {
                output.push_str(&self.generate_route_handler(path, "get", op)?);
            }
            if let Some(op) = &path_item.post {
                output.push_str(&self.generate_route_handler(path, "post", op)?);
            }
            if let Some(op) = &path_item.put {
                output.push_str(&self.generate_route_handler(path, "put", op)?);
            }
            if let Some(op) = &path_item.delete {
                output.push_str(&self.generate_route_handler(path, "delete", op)?);
            }
            if let Some(op) = &path_item.patch {
                output.push_str(&self.generate_route_handler(path, "patch", op)?);
            }
        }
        
        Ok(output)
    }
    
    fn generate_route_handler(&self, path: &str, method: &str, operation: &Operation) -> Result<String> {
        let mut output = String::new();
        
        // Generate docstring
        if let Some(summary) = &operation.summary {
            output.push_str(&format!("\"\"\" {} \"\"\"\n", summary));
        }
        
        // Convert operation_id to function name, or generate one
        let func_name = operation.operation_id.as_ref()
            .map(|id| id.to_snake_case())
            .unwrap_or_else(|| format!("{}_{}", method, path.replace('/', "_").replace('{', "").replace('}', "").trim_matches('_')));
        
        // Parse parameters
        let mut path_params = Vec::new();
        let mut query_params = Vec::new();
        let mut has_body = false;
        let mut body_type = "Any".to_string();
        
        for param_ref in &operation.parameters {
            match param_ref {
                ReferenceOr::Item(param) => {
                    match param {
                        Parameter::Path { parameter_data, .. } => {
                            path_params.push((parameter_data.name.clone(), "str".to_string()));
                        }
                        Parameter::Query { parameter_data, .. } => {
                            let type_hint = "str".to_string(); // Simplified
                            query_params.push((parameter_data.name.clone(), type_hint, parameter_data.required));
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        
        // Check for request body
        if let Some(request_body_ref) = &operation.request_body {
            match request_body_ref {
                ReferenceOr::Item(request_body) => {
                    has_body = true;
                    // Try to extract schema from JSON content
                    if request_body.content.get("application/json").is_some() {
                        body_type = "Dict[str, Any]".to_string(); // Simplified
                    }
                }
                _ => {}
            }
        }
        
        // Generate route decorator
        output.push_str(&format!("@route(\"{}\", methods=[\"{}\"])\n", path, method.to_uppercase()));
        
        // Generate function signature
        output.push_str(&format!("def {}(request: Request", func_name));
        
        // Add path parameters
        for (param_name, param_type) in &path_params {
            output.push_str(&format!(", {}: Path[{}]", param_name.to_snake_case(), param_type));
        }
        
        // Add query parameters
        for (param_name, param_type, required) in &query_params {
            if *required {
                output.push_str(&format!(", {}: Query[{}]", param_name.to_snake_case(), param_type));
            } else {
                output.push_str(&format!(", {}: Query[Optional[{}]] = None", param_name.to_snake_case(), param_type));
            }
        }
        
        // Add body parameter
        if has_body {
            output.push_str(&format!(", body: Body[{}]", body_type));
        }
        
        output.push_str(") -> dict:\n");
        
        // Generate function body
        if let Some(desc) = &operation.description {
            output.push_str(&format!("    \"\"\"\n    {}\n    \"\"\"\n", desc));
        }
        
        output.push_str("    # TODO: Implement handler logic\n");
        output.push_str("    return {\"message\": \"Not implemented\"}\n\n");
        
        Ok(output)
    }
    
    fn generate_main(&self) -> String {
        r#"
# Run the application
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
"#.to_string()
    }
}
