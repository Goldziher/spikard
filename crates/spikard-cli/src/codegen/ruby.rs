//! Ruby code generation from `OpenAPI` schemas

use super::RubyDtoStyle;
use anyhow::Result;
use heck::{ToPascalCase, ToSnakeCase};
use openapiv3::{OpenAPI, Operation, Parameter, ReferenceOr, Schema, SchemaKind, Type};

pub struct RubyGenerator {
    spec: OpenAPI,
    dto: RubyDtoStyle,
}

impl RubyGenerator {
    #[must_use]
    pub const fn new(spec: OpenAPI, dto: RubyDtoStyle) -> Self {
        Self { spec, dto }
    }

    pub fn generate(&self) -> Result<String> {
        let mut output = String::new();

        output.push_str(&self.generate_header());

        output.push_str(&self.generate_models()?);

        output.push_str(&self.generate_routes()?);

        output.push_str(&self.generate_main());

        Ok(output)
    }

    fn generate_header(&self) -> String {
        match self.dto {
            RubyDtoStyle::DrySchema => format!(
                r"# frozen_string_literal: true

# Generated by Spikard OpenAPI code generator
# OpenAPI Version: {}
# Title: {}
# DO NOT EDIT - regenerate from OpenAPI schema

require 'sinatra/base'
require 'json'

begin
  require 'dry-struct'
  require 'dry-types'
rescue LoadError
  puts 'Warning: dry-struct and dry-types not found. Install with: gem install dry-struct dry-types'
end

# Type definitions module
module Types
  include Dry.Types() if defined?(Dry)
end

",
                self.spec.openapi, self.spec.info.title
            ),
        }
    }

    fn generate_models(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Schema Models\n\n");

        if let Some(components) = &self.spec.components {
            for (name, schema_ref) in &components.schemas {
                match schema_ref {
                    ReferenceOr::Item(schema) => {
                        output.push_str(&self.generate_model_class(name, schema)?);
                        output.push('\n');
                    }
                    ReferenceOr::Reference { .. } => {
                        continue;
                    }
                }
            }
        }

        Ok(output)
    }

    fn generate_model_class(&self, name: &str, schema: &Schema) -> Result<String> {
        let class_name = name.to_pascal_case();
        let mut output = String::new();

        if let Some(description) = &schema.schema_data.description {
            for line in description.lines() {
                output.push_str(&format!("# {line}\n"));
            }
        } else {
            output.push_str(&format!("# {class_name} model\n"));
        }

        output.push_str(&format!("class {class_name} < Dry::Struct\n"));

        match &schema.schema_kind {
            SchemaKind::Type(Type::Object(obj)) => {
                if obj.properties.is_empty() {
                    output.push_str("  # Empty schema\n");
                } else {
                    for (prop_name, prop_schema_ref) in &obj.properties {
                        let is_required = obj.required.contains(prop_name);
                        let field_name = prop_name.to_snake_case();

                        let type_hint = match prop_schema_ref {
                            ReferenceOr::Item(prop_schema) => Self::schema_to_ruby_type(prop_schema, !is_required),
                            ReferenceOr::Reference { reference } => {
                                let ref_name = reference.split('/').next_back().unwrap();
                                if is_required {
                                    ref_name.to_pascal_case()
                                } else {
                                    format!("Types.Instance({}).optional", ref_name.to_pascal_case())
                                }
                            }
                        };

                        output.push_str(&format!("  attribute :{field_name}, {type_hint}\n"));
                    }
                }
            }
            _ => {
                output.push_str("  # Unsupported schema type\n");
            }
        }

        output.push_str("end\n");

        Ok(output)
    }

    /// Extract type name from a schema reference or inline schema
    fn extract_type_from_schema_ref(&self, schema_ref: &ReferenceOr<Schema>) -> String {
        match schema_ref {
            ReferenceOr::Reference { reference } => {
                let ref_name = reference.split('/').next_back().unwrap();
                ref_name.to_pascal_case()
            }
            ReferenceOr::Item(schema) => Self::schema_to_ruby_return_type(schema),
        }
    }

    /// Extract request body type from operation
    fn extract_request_body_type(&self, operation: &Operation) -> Option<String> {
        operation.request_body.as_ref().and_then(|body_ref| match body_ref {
            ReferenceOr::Item(request_body) => request_body.content.get("application/json").and_then(|media_type| {
                media_type
                    .schema
                    .as_ref()
                    .map(|schema_ref| self.extract_type_from_schema_ref(schema_ref))
            }),
            ReferenceOr::Reference { reference } => {
                let ref_name = reference.split('/').next_back().unwrap();
                Some(ref_name.to_pascal_case())
            }
        })
    }

    /// Extract response type from operation (looks for 200/201 responses)
    fn extract_response_type(&self, operation: &Operation) -> String {
        use openapiv3::StatusCode;

        let response = operation
            .responses
            .responses
            .get(&StatusCode::Code(200))
            .or_else(|| operation.responses.responses.get(&StatusCode::Code(201)))
            .or_else(|| operation.responses.responses.get(&StatusCode::Range(2)));

        if let Some(response_ref) = response {
            match response_ref {
                ReferenceOr::Item(response) => {
                    if let Some(content) = response.content.get("application/json")
                        && let Some(schema_ref) = &content.schema
                    {
                        return self.extract_type_from_schema_ref(schema_ref);
                    }
                }
                ReferenceOr::Reference { reference } => {
                    let ref_name = reference.split('/').next_back().unwrap();
                    return ref_name.to_pascal_case();
                }
            }
        }

        "Hash".to_string()
    }

    fn schema_to_ruby_type(schema: &Schema, optional: bool) -> String {
        let base_type = match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "Types::Strict::String".to_string(),
            SchemaKind::Type(Type::Number(_)) => "Types::Strict::Float".to_string(),
            SchemaKind::Type(Type::Integer(_)) => "Types::Strict::Integer".to_string(),
            SchemaKind::Type(Type::Boolean(_)) => "Types::Strict::Bool".to_string(),
            SchemaKind::Type(Type::Array(arr)) => {
                let item_type = match &arr.items {
                    Some(ReferenceOr::Item(item_schema)) => Self::schema_to_ruby_type(item_schema, false),
                    Some(ReferenceOr::Reference { reference }) => {
                        let ref_name = reference.split('/').next_back().unwrap();
                        format!("Types.Instance({})", ref_name.to_pascal_case())
                    }
                    None => "Types::Any".to_string(),
                };
                format!("Types::Strict::Array.of({item_type})")
            }
            SchemaKind::Type(Type::Object(_)) => "Types::Strict::Hash".to_string(),
            _ => "Types::Any".to_string(),
        };

        if optional {
            format!("{base_type}.optional")
        } else {
            base_type
        }
    }

    fn schema_to_ruby_return_type(schema: &Schema) -> String {
        match &schema.schema_kind {
            SchemaKind::Type(Type::String(_)) => "String".to_string(),
            SchemaKind::Type(Type::Number(_)) => "Float".to_string(),
            SchemaKind::Type(Type::Integer(_)) => "Integer".to_string(),
            SchemaKind::Type(Type::Boolean(_)) => "Boolean".to_string(),
            SchemaKind::Type(Type::Array(arr)) => {
                let item_type = match &arr.items {
                    Some(ReferenceOr::Item(item_schema)) => Self::schema_to_ruby_return_type(item_schema),
                    Some(ReferenceOr::Reference { reference }) => {
                        let ref_name = reference.split('/').next_back().unwrap();
                        ref_name.to_pascal_case()
                    }
                    None => "Object".to_string(),
                };
                format!("Array<{item_type}>")
            }
            SchemaKind::Type(Type::Object(_)) => "Hash".to_string(),
            _ => "Object".to_string(),
        }
    }

    fn generate_routes(&self) -> Result<String> {
        let mut output = String::new();
        output.push_str("# API Application\n");
        output.push_str("class API < Sinatra::Base\n");
        output.push_str("  # Configure JSON content type by default\n");
        output.push_str("  before do\n");
        output.push_str("    content_type :json\n");
        output.push_str("  end\n\n");

        for (path, path_item_ref) in &self.spec.paths.paths {
            let path_item = match path_item_ref {
                ReferenceOr::Item(item) => item,
                ReferenceOr::Reference { .. } => continue,
            };

            if let Some(op) = &path_item.get {
                output.push_str(&self.generate_route_handler(path, "get", op)?);
            }
            if let Some(op) = &path_item.post {
                output.push_str(&self.generate_route_handler(path, "post", op)?);
            }
            if let Some(op) = &path_item.put {
                output.push_str(&self.generate_route_handler(path, "put", op)?);
            }
            if let Some(op) = &path_item.delete {
                output.push_str(&self.generate_route_handler(path, "delete", op)?);
            }
            if let Some(op) = &path_item.patch {
                output.push_str(&self.generate_route_handler(path, "patch", op)?);
            }
        }

        output.push_str("end\n");

        Ok(output)
    }

    fn generate_route_handler(&self, path: &str, method: &str, operation: &Operation) -> Result<String> {
        let mut output = String::new();

        let sinatra_path = path.replace('{', ":").replace('}', "");

        if let Some(summary) = &operation.summary {
            output.push_str(&format!("  # {summary}\n"));
        } else {
            output.push_str(&format!("  # {} {}\n", method.to_uppercase(), path));
        }

        if let Some(description) = &operation.description {
            for line in description.lines() {
                output.push_str(&format!("  # {line}\n"));
            }
        }

        let mut has_path_params = false;
        let mut has_query_params = false;

        for param_ref in &operation.parameters {
            if let ReferenceOr::Item(param) = param_ref {
                match param {
                    Parameter::Path { parameter_data, .. } => {
                        has_path_params = true;
                        output.push_str(&format!(
                            "  # @param {} [String] Path parameter\n",
                            parameter_data.name.to_snake_case()
                        ));
                    }
                    Parameter::Query { parameter_data, .. } => {
                        has_query_params = true;
                        let required = if parameter_data.required {
                            "required"
                        } else {
                            "optional"
                        };
                        output.push_str(&format!(
                            "  # @param {} [String] Query parameter ({})\n",
                            parameter_data.name.to_snake_case(),
                            required
                        ));
                    }
                    _ => {}
                }
            }
        }

        let body_type = self.extract_request_body_type(operation);
        if body_type.is_some() {
            output.push_str("  # @param body [Hash] Request body\n");
        }

        let return_type = self.extract_response_type(operation);
        output.push_str(&format!("  # @return [{return_type}] Response body\n"));

        output.push_str(&format!("  {method} '{sinatra_path}' do\n"));

        if has_path_params {
            output.push_str("    # Path parameters available in params hash\n");
        }

        if has_query_params {
            output.push_str("    # Query parameters available in params hash\n");
        }

        if let Some(bt) = body_type {
            output.push_str("    # Parse and validate request body\n");
            output.push_str("    # TODO: body_data = JSON.parse(request.body.read)\n");
            output.push_str("    # TODO: body = ");
            output.push_str(&bt);
            output.push_str(".new(body_data)\n\n");
        }

        // Generate TODO implementation
        output.push_str("    # TODO: Implement this endpoint\n");

        match method {
            "get" => {
                if return_type.starts_with("Array") {
                    output.push_str("    [].to_json\n");
                } else {
                    output.push_str("    {}.to_json\n");
                }
            }
            "post" | "put" | "patch" => {
                output.push_str("    status 201\n");
                output.push_str("    {}.to_json\n");
            }
            "delete" => {
                output.push_str("    status 204\n");
                output.push_str("    ''\n");
            }
            _ => {
                output.push_str("    {}.to_json\n");
            }
        }

        output.push_str("  end\n");

        Ok(output)
    }

    fn generate_main(&self) -> String {
        r"
# Run the application
# Usage: ruby generated_api.rb
# Or use with config.ru for Rack-based deployment
API.run!(host: '0.0.0.0', port: 4567) if __FILE__ == $PROGRAM_NAME

# For Rack-based deployment (config.ru):
# run API
"
        .to_string()
    }
}
