//! Ruby GraphQL code generator using graphql-ruby.
//!
//! This generator produces idiomatic Ruby code for GraphQL resolver implementations
//! using the graphql-ruby gem. Generated code follows Ruby 3.2+ standards with proper
//! type annotations via RBS (Ruby Signature files) for integration with Steep type checker.
//!
//! Generated code includes:
//! - GraphQL::Schema::Object/InputObject classes for types
//! - GraphQL::Schema::Enum for enumerations
//! - Resolver methods with keyword arguments
//! - RBS type signatures in comments for optional type checking

use super::GraphQLGenerator;
use crate::codegen::common::case_conversion::to_snake_case;
use crate::codegen::graphql::sdl::{SdlBuilder, TargetLanguage, TypeMapper};
use crate::codegen::graphql::spec_parser::{GraphQLSchema, TypeKind};
use anyhow::Result;

#[cfg(test)]
use crate::codegen::graphql::spec_parser::GraphQLField;

#[derive(Default, Debug, Clone, Copy)]
pub struct RubyGenerator;

impl RubyGenerator {
    /// Generate RBS (Ruby Signature) type definitions for Steep type checking
    ///
    /// Produces `.rbs` files with type signatures for all GraphQL types, enabling
    /// full type safety with Steep static type checker.
    ///
    /// RBS syntax:
    /// - Classes: `class User < GraphQL::Schema::Object`
    /// - Fields: `def name: () -> String`
    /// - Nullable types: `String | nil`
    /// - Lists: `Array[String]` or `Array[String | nil]`
    /// - Modules: `module Types` for type grouping
    fn generate_rbs_signatures(&self, schema: &GraphQLSchema) -> Result<String> {
        let mut rbs = String::new();

        rbs.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        rbs.push_str("# RBS type signatures for GraphQL types\n");
        rbs.push_str("# Generated from GraphQL schema for Steep type checking\n\n");

        rbs.push_str("module Types\n");

        // Create type mapper for Ruby
        let mapper = TypeMapper::new(TargetLanguage::Ruby, Some(schema));

        // Generate RBS for each type (skip built-in scalars)
        for (type_name, type_def) in &schema.types {
            if matches!(
                type_name.as_str(),
                "String" | "Int" | "Float" | "Boolean" | "ID" | "DateTime" | "Date" | "Time" | "JSON" | "Upload"
            ) {
                continue;
            }

            match type_def.kind {
                TypeKind::Object => {
                    rbs.push_str(&format!("  class {}\n", type_def.name));
                    rbs.push_str("    < GraphQL::Schema::Object\n\n");

                    for field in &type_def.fields {
                        if field.name.is_empty() {
                            continue;
                        }

                        let field_type = mapper.map_type_with_list_nullability(
                            &field.type_name,
                            field.is_nullable,
                            field.is_list,
                            field.list_item_nullable,
                        );

                        rbs.push_str(&format!("    def {}: () -> {}\n", field.name, field_type));
                    }

                    rbs.push_str("  end\n\n");
                }
                TypeKind::InputObject => {
                    rbs.push_str(&format!("  class {}\n", type_def.name));
                    rbs.push_str("    < GraphQL::Schema::InputObject\n\n");

                    for field in &type_def.input_fields {
                        if field.name.is_empty() {
                            continue;
                        }

                        let field_type = mapper.map_type_with_list_nullability(
                            &field.type_name,
                            field.is_nullable,
                            field.is_list,
                            field.list_item_nullable,
                        );

                        rbs.push_str(&format!("    def {}: () -> {}\n", field.name, field_type));
                    }

                    rbs.push_str("  end\n\n");
                }
                TypeKind::Enum => {
                    rbs.push_str(&format!("  class {}\n", type_def.name));
                    rbs.push_str("    < GraphQL::Schema::Enum\n\n");

                    for value in &type_def.enum_values {
                        rbs.push_str(&format!("    VALUE_{}: ::\n", value.name.to_uppercase()));
                    }

                    rbs.push_str("  end\n\n");
                }
                TypeKind::Scalar => {
                    rbs.push_str(&format!("  class {}\n", type_def.name));
                    rbs.push_str("    < GraphQL::Types::Relay::Node\n");
                    rbs.push_str("  end\n\n");
                }
                TypeKind::Union => {
                    rbs.push_str(&format!("  class {}\n", type_def.name));
                    rbs.push_str("    < GraphQL::Schema::Union\n\n");

                    if !type_def.possible_types.is_empty() {
                        rbs.push_str("    def self.resolve_type(obj: untyped, ctx: untyped): String\n");
                    }

                    rbs.push_str("  end\n\n");
                }
                TypeKind::Interface => {
                    rbs.push_str(&format!("  module {}\n", type_def.name));
                    rbs.push_str("    < GraphQL::Schema::Interface\n\n");

                    for field in &type_def.fields {
                        if field.name.is_empty() {
                            continue;
                        }

                        let field_type = mapper.map_type_with_list_nullability(
                            &field.type_name,
                            field.is_nullable,
                            field.is_list,
                            field.list_item_nullable,
                        );

                        rbs.push_str(&format!("    def {}: () -> {}\n", field.name, field_type));
                    }

                    rbs.push_str("  end\n\n");
                }
                _ => {}
            }
        }

        // Add resolver type signatures
        rbs.push_str("  # Query resolver\n");
        rbs.push_str("  class QueryType\n");
        rbs.push_str("    < GraphQL::Schema::Object\n\n");

        for field in &schema.queries {
            let field_type = mapper.map_type_with_list_nullability(
                &field.type_name,
                field.is_nullable,
                field.is_list,
                field.list_item_nullable,
            );

            let method_name = to_snake_case(&field.name);
            if field.arguments.is_empty() {
                rbs.push_str(&format!("    def {}: () -> {}\n", method_name, field_type));
            } else {
                let mut arg_types = Vec::new();
                for arg in &field.arguments {
                    let arg_type = mapper.map_type_with_list_nullability(
                        &arg.type_name,
                        arg.is_nullable,
                        arg.is_list,
                        arg.list_item_nullable,
                    );
                    arg_types.push(format!("{}: {}", to_snake_case(&arg.name), arg_type));
                }

                rbs.push_str(&format!(
                    "    def {}: ({}) -> {}\n",
                    method_name,
                    arg_types.join(", "),
                    field_type
                ));
            }
        }

        rbs.push_str("  end\n\n");

        // Add Mutation resolver if present
        if !schema.mutations.is_empty() {
            rbs.push_str("  # Mutation resolver\n");
            rbs.push_str("  class MutationType\n");
            rbs.push_str("    < GraphQL::Schema::Object\n\n");

            for field in &schema.mutations {
                let field_type = mapper.map_type_with_list_nullability(
                    &field.type_name,
                    field.is_nullable,
                    field.is_list,
                    field.list_item_nullable,
                );

                let method_name = to_snake_case(&field.name);
                if field.arguments.is_empty() {
                    rbs.push_str(&format!("    def {}: () -> {}\n", method_name, field_type));
                } else {
                    let mut arg_types = Vec::new();
                    for arg in &field.arguments {
                        let arg_type = mapper.map_type_with_list_nullability(
                            &arg.type_name,
                            arg.is_nullable,
                            arg.is_list,
                            arg.list_item_nullable,
                        );
                        arg_types.push(format!("{}: {}", to_snake_case(&arg.name), arg_type));
                    }

                    rbs.push_str(&format!(
                        "    def {}: ({}) -> {}\n",
                        method_name,
                        arg_types.join(", "),
                        field_type
                    ));
                }
            }

            rbs.push_str("  end\n\n");
        }

        // Add Subscription resolver if present
        if !schema.subscriptions.is_empty() {
            rbs.push_str("  # Subscription resolver\n");
            rbs.push_str("  class SubscriptionType\n");
            rbs.push_str("    < GraphQL::Schema::Object\n\n");

            for field in &schema.subscriptions {
                let field_type = mapper.map_type_with_list_nullability(
                    &field.type_name,
                    field.is_nullable,
                    field.is_list,
                    field.list_item_nullable,
                );

                let method_name = to_snake_case(&field.name);
                if field.arguments.is_empty() {
                    rbs.push_str(&format!("    def {}: () -> {}\n", method_name, field_type));
                } else {
                    let mut arg_types = Vec::new();
                    for arg in &field.arguments {
                        let arg_type = mapper.map_type_with_list_nullability(
                            &arg.type_name,
                            arg.is_nullable,
                            arg.is_list,
                            arg.list_item_nullable,
                        );
                        arg_types.push(format!("{}: {}", to_snake_case(&arg.name), arg_type));
                    }

                    rbs.push_str(&format!(
                        "    def {}: ({}) -> {}\n",
                        method_name,
                        arg_types.join(", "),
                        field_type
                    ));
                }
            }

            rbs.push_str("  end\n\n");
        }

        rbs.push_str("  # Schema definition\n");
        rbs.push_str("  class AppSchema\n");
        rbs.push_str("    < GraphQL::Schema\n\n");
        rbs.push_str("    def self.query: Class\n");
        if !schema.mutations.is_empty() {
            rbs.push_str("    def self.mutation: Class\n");
        }
        if !schema.subscriptions.is_empty() {
            rbs.push_str("    def self.subscription: Class\n");
        }
        rbs.push_str("  end\n");

        rbs.push_str("end\n");

        Ok(rbs)
    }
}

impl GraphQLGenerator for RubyGenerator {
    fn generate_types(&self, schema: &GraphQLSchema) -> Result<String> {
        let mut code = String::new();

        code.push_str("# frozen_string_literal: true\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your GraphQL schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n\n");
        code.push_str("module Types\n");

        // Generate all type definitions (skip built-in scalars)
        for (type_name, type_def) in &schema.types {
            if matches!(type_name.as_str(), "String" | "Int" | "Float" | "Boolean" | "ID") {
                continue;
            }

            // Add description as comment
            if let Some(desc) = &type_def.description {
                code.push_str(&format!("  # {}\n", desc));
            }

            // Generate type based on kind
            match type_def.kind {
                TypeKind::Object => {
                    code.push_str(&format!("  class {} < GraphQL::Schema::Object\n", type_def.name));

                    for field in &type_def.fields {
                        if field.name.is_empty() {
                            continue; // Skip invalid field names
                        }

                        if let Some(field_desc) = &field.description {
                            code.push_str(&format!("    # {}\n", field_desc));
                        }

                        if field.arguments.is_empty() {
                            code.push_str("    ");
                            // Generate proper RBS type syntax for graphql-ruby
                            let base_type = field.type_name.trim_matches(|c| c == '!' || c == '[' || c == ']');
                            let field_type = if field.is_list {
                                if field.list_item_nullable {
                                    format!("[Types::{}, null: true]", base_type)
                                } else {
                                    format!("[Types::{}]", base_type)
                                }
                            } else {
                                format!("Types::{}", base_type)
                            };

                            let null_option = if field.is_nullable { "null: true" } else { "null: false" };
                            code.push_str(&format!("field :{}, {}, {}\n", field.name, field_type, null_option));

                            if let Some(reason) = &field.deprecation_reason {
                                let safe_reason = reason.replace('"', "\\\"").replace('\n', " ");
                                code.push_str(&format!("    deprecation_reason \"{}\"\n", safe_reason));
                            }
                        } else {
                            code.push_str(&format!("    field :{} do\n", field.name));

                            for arg in &field.arguments {
                                if arg.name.is_empty() {
                                    continue; // Skip invalid argument names
                                }

                                let base_type = arg.type_name.trim_matches(|c| c == '!' || c == '[' || c == ']');
                                let arg_type = if arg.is_list {
                                    if arg.list_item_nullable {
                                        format!("[Types::{}, null: true]", base_type)
                                    } else {
                                        format!("[Types::{}]", base_type)
                                    }
                                } else {
                                    format!("Types::{}", base_type)
                                };

                                let required = if arg.is_nullable { "" } else { ", required: true" };
                                code.push_str(&format!("      argument :{}, {}{}\n", arg.name, arg_type, required));
                            }

                            code.push_str("    end\n");
                        }
                    }

                    code.push_str("  end\n\n");
                }
                TypeKind::InputObject => {
                    code.push_str(&format!("  class {} < GraphQL::Schema::InputObject\n", type_def.name));

                    for field in &type_def.input_fields {
                        if field.name.is_empty() {
                            continue; // Skip invalid field names
                        }

                        if let Some(field_desc) = &field.description {
                            code.push_str(&format!("    # {}\n", field_desc));
                        }

                        let base_type = field.type_name.trim_matches(|c| c == '!' || c == '[' || c == ']');
                        let field_type = if field.is_list {
                            if field.list_item_nullable {
                                format!("[Types::{}, null: true]", base_type)
                            } else {
                                format!("[Types::{}]", base_type)
                            }
                        } else {
                            format!("Types::{}", base_type)
                        };

                        let required = if field.is_nullable { "" } else { ", required: true" };
                        code.push_str(&format!("    argument :{}, {}{}\n", field.name, field_type, required));
                    }

                    code.push_str("  end\n\n");
                }
                TypeKind::Enum => {
                    code.push_str(&format!("  class {} < GraphQL::Schema::Enum\n", type_def.name));

                    for value in &type_def.enum_values {
                        if let Some(desc) = &value.description {
                            code.push_str(&format!("    # {}\n", desc));
                        }

                        code.push_str(&format!("    value :{}\n", value.name));

                        if value.is_deprecated
                            && let Some(reason) = &value.deprecation_reason
                        {
                            code.push_str(&format!("    deprecation_reason \"{}\"\n", reason.replace('"', "\\\"")));
                        }
                    }

                    code.push_str("  end\n\n");
                }
                TypeKind::Scalar => {
                    code.push_str(&format!("  class {} < GraphQL::Types::Relay::Node\n", type_def.name));
                    code.push_str("  end\n\n");
                }
                TypeKind::Union => {
                    code.push_str(&format!("  class {} < GraphQL::Schema::Union\n", type_def.name));

                    for possible_type in &type_def.possible_types {
                        code.push_str(&format!("    possible_type Types::{}\n", possible_type));
                    }

                    code.push_str("  end\n\n");
                }
                TypeKind::Interface => {
                    code.push_str(&format!("  class {} < GraphQL::Schema::Interface\n", type_def.name));

                    for field in &type_def.fields {
                        if field.name.is_empty() {
                            continue; // Skip invalid field names
                        }

                        if let Some(field_desc) = &field.description {
                            code.push_str(&format!("    # {}\n", field_desc));
                        }

                        let base_type = field.type_name.trim_matches(|c| c == '!' || c == '[' || c == ']');
                        let field_type = if field.is_list {
                            if field.list_item_nullable {
                                format!("[Types::{}, null: true]", base_type)
                            } else {
                                format!("[Types::{}]", base_type)
                            }
                        } else {
                            format!("Types::{}", base_type)
                        };

                        let null_option = if field.is_nullable { "null: true" } else { "null: false" };
                        code.push_str(&format!("    field :{}, {}, {}\n", field.name, field_type, null_option));
                    }

                    code.push_str("  end\n\n");
                }
                _ => {}
            }
        }

        code.push_str("end\n");

        Ok(code)
    }

    fn generate_resolvers(&self, schema: &GraphQLSchema) -> Result<String> {
        let mut code = String::new();

        code.push_str("# frozen_string_literal: true\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your GraphQL schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n\n");

        // Generate QueryType
        code.push_str("class QueryType < GraphQL::Schema::Object\n");
        if schema.queries.is_empty() {
            code.push_str("  # No queries defined\n");
        } else {
            for field in &schema.queries {
                if let Some(desc) = &field.description {
                    code.push_str(&format!("  # {}\n", desc));
                }

                let method_name = to_snake_case(&field.name);
                if field.arguments.is_empty() {
                    code.push_str(&format!("  def {}\n", method_name));
                    code.push_str(&format!(
                        "    raise NotImplementedError, \"TODO: Implement QueryType#{}\"\n",
                        method_name
                    ));
                    code.push_str("  end\n\n");
                } else {
                    let mut args = String::new();
                    for (i, arg) in field.arguments.iter().enumerate() {
                        if i > 0 {
                            args.push_str(", ");
                        }
                        let arg_name = to_snake_case(&arg.name);
                        args.push_str(&format!("{}:", arg_name));
                    }
                    code.push_str(&format!("  def {}({})\n", method_name, args));
                    code.push_str(&format!(
                        "    raise NotImplementedError, \"TODO: Implement QueryType#{}\"\n",
                        method_name
                    ));
                    code.push_str("  end\n\n");
                }
            }
        }
        code.push_str("end\n\n");

        // Generate MutationType
        code.push_str("class MutationType < GraphQL::Schema::Object\n");
        if schema.mutations.is_empty() {
            code.push_str("  # No mutations defined\n");
        } else {
            for field in &schema.mutations {
                if let Some(desc) = &field.description {
                    code.push_str(&format!("  # {}\n", desc));
                }

                let method_name = to_snake_case(&field.name);
                if field.arguments.is_empty() {
                    code.push_str(&format!("  def {}\n", method_name));
                    code.push_str(&format!(
                        "    raise NotImplementedError, \"TODO: Implement MutationType#{}\"\n",
                        method_name
                    ));
                    code.push_str("  end\n\n");
                } else {
                    let mut args = String::new();
                    for (i, arg) in field.arguments.iter().enumerate() {
                        if i > 0 {
                            args.push_str(", ");
                        }
                        let arg_name = to_snake_case(&arg.name);
                        args.push_str(&format!("{}:", arg_name));
                    }
                    code.push_str(&format!("  def {}({})\n", method_name, args));
                    code.push_str(&format!(
                        "    raise NotImplementedError, \"TODO: Implement MutationType#{}\"\n",
                        method_name
                    ));
                    code.push_str("  end\n\n");
                }
            }
        }
        code.push_str("end\n\n");

        // Generate SubscriptionType if needed
        if !schema.subscriptions.is_empty() {
            code.push_str("class SubscriptionType < GraphQL::Schema::Object\n");
            for field in &schema.subscriptions {
                if let Some(desc) = &field.description {
                    code.push_str(&format!("  # {}\n", desc));
                }

                let method_name = to_snake_case(&field.name);
                if field.arguments.is_empty() {
                    code.push_str(&format!("  def {}\n", method_name));
                    code.push_str(&format!(
                        "    raise NotImplementedError, \"TODO: Implement SubscriptionType#{}\"\n",
                        method_name
                    ));
                    code.push_str("  end\n\n");
                } else {
                    let mut args = String::new();
                    for (i, arg) in field.arguments.iter().enumerate() {
                        if i > 0 {
                            args.push_str(", ");
                        }
                        let arg_name = to_snake_case(&arg.name);
                        args.push_str(&format!("{}:", arg_name));
                    }
                    code.push_str(&format!("  def {}({})\n", method_name, args));
                    code.push_str(&format!(
                        "    raise NotImplementedError, \"TODO: Implement SubscriptionType#{}\"\n",
                        method_name
                    ));
                    code.push_str("  end\n\n");
                }
            }
            code.push_str("end\n\n");
        }

        Ok(code)
    }

    fn generate_schema_definition(&self, schema: &GraphQLSchema) -> Result<String> {
        let mut code = String::new();

        code.push_str("# frozen_string_literal: true\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your GraphQL schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n\n");

        // Use shared SDL builder
        let builder = SdlBuilder::new(schema);
        let sdl = builder.build();

        // Add schema class
        code.push_str("class AppSchema < GraphQL::Schema\n");
        code.push_str("  query QueryType\n");
        if !schema.mutations.is_empty() {
            code.push_str("  mutation MutationType\n");
        }
        if !schema.subscriptions.is_empty() {
            code.push_str("  subscription SubscriptionType\n");
        }
        code.push_str("end\n\n");

        // Add SDL as constant for reference/debugging
        code.push_str("# GraphQL Schema Definition Language (SDL)\n");
        code.push_str("SCHEMA_SDL = <<~SDL\n");
        for line in sdl.lines() {
            code.push_str("  ");
            code.push_str(line);
            code.push('\n');
        }
        code.push_str("SDL\n");

        Ok(code)
    }

    /// Generate RBS (Ruby Signature) type definitions for Steep type checking
    /// Implements the optional trait method for Ruby-specific type signatures
    fn generate_type_signatures(&self, schema: &GraphQLSchema) -> Result<String> {
        self.generate_rbs_signatures(schema)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::graphql::spec_parser::GraphQLArgument;
    use std::collections::HashMap;

    #[test]
    fn test_to_snake_case_via_shared_utility() {
        // Tests that shared to_snake_case function works correctly
        assert_eq!(to_snake_case("getUser"), "get_user");
        assert_eq!(to_snake_case("createUserProfile"), "create_user_profile");
        assert_eq!(to_snake_case("user"), "user");
        assert_eq!(to_snake_case("HTTPServer"), "http_server");
    }

    #[test]
    fn test_type_mapper_ruby_scalars() {
        let mapper = TypeMapper::new(TargetLanguage::Ruby, None);
        assert_eq!(mapper.map_scalar("String"), "String");
        assert_eq!(mapper.map_scalar("Int"), "Integer");
        assert_eq!(mapper.map_scalar("Float"), "Float");
        assert_eq!(mapper.map_scalar("Boolean"), "true | false");
        assert_eq!(mapper.map_scalar("ID"), "String");
        assert_eq!(mapper.map_scalar("CustomType"), "CustomType");
    }

    #[test]
    fn test_type_mapper_ruby_nullability() {
        let mapper = TypeMapper::new(TargetLanguage::Ruby, None);
        assert_eq!(mapper.map_type("String", false, false), "String");
        assert_eq!(mapper.map_type("String", true, false), "String | nil");
        assert_eq!(mapper.map_type("Integer", false, false), "Integer");
        assert_eq!(mapper.map_type("Integer", true, false), "Integer | nil");
    }

    #[test]
    fn test_type_mapper_ruby_lists() {
        let mapper = TypeMapper::new(TargetLanguage::Ruby, None);
        assert_eq!(mapper.map_type("String", false, true), "Array[String | nil]");
        assert_eq!(
            mapper.map_type_with_list_nullability("String", false, true, false),
            "Array[String]"
        );
        assert_eq!(mapper.map_type("String", true, true), "Array[String | nil] | nil");
        assert_eq!(
            mapper.map_type_with_list_nullability("String", true, true, false),
            "Array[String] | nil"
        );
    }

    #[test]
    fn test_sdl_builder_generates_schema() {
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let builder = SdlBuilder::new(&schema);
        let sdl = builder.build();
        // Just verify it doesn't panic and returns empty/minimal SDL
        assert_eq!(sdl.trim(), "");
    }

    #[test]
    fn test_generate_types_empty_schema() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_types(&schema).unwrap();
        assert!(result.contains("module Types"));
        assert!(result.contains("end"));
        assert!(result.contains("DO NOT EDIT - Auto-generated by Spikard CLI"));
    }

    #[test]
    fn test_generate_resolvers_with_query() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![GraphQLField {
                name: "hello".to_string(),
                type_name: "String".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: true,
                arguments: vec![],
                description: None,
                deprecation_reason: None,
            }],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_resolvers(&schema).unwrap();
        assert!(result.contains("class QueryType"));
        assert!(result.contains("def hello"));
        assert!(result.contains("NotImplementedError"));
        assert!(result.contains("TODO"));
    }

    #[test]
    fn test_generate_resolvers_with_arguments() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![GraphQLField {
                name: "user".to_string(),
                type_name: "User".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: true,
                arguments: vec![GraphQLArgument {
                    name: "id".to_string(),
                    type_name: "String".to_string(),
                    is_nullable: false,
                    is_list: false,
                    list_item_nullable: false,
                    default_value: None,
                    description: None,
                }],
                description: None,
                deprecation_reason: None,
            }],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_resolvers(&schema).unwrap();
        assert!(result.contains("def user(id:)"));
        assert!(result.contains("NotImplementedError"));
    }

    #[test]
    fn test_generate_schema_definition() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![GraphQLField {
                name: "hello".to_string(),
                type_name: "String".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: true,
                arguments: vec![],
                description: None,
                deprecation_reason: None,
            }],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_schema_definition(&schema).unwrap();
        assert!(result.contains("class AppSchema < GraphQL::Schema"));
        assert!(result.contains("query QueryType"));
        assert!(result.contains("SCHEMA_SDL"));
    }

    #[test]
    fn test_generate_rbs_signatures_empty_schema() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_rbs_signatures(&schema).unwrap();
        assert!(result.contains("# RBS type signatures for GraphQL types"));
        assert!(result.contains("module Types"));
        assert!(result.contains("class QueryType"));
        assert!(result.contains("< GraphQL::Schema::Object"));
        assert!(result.contains("class AppSchema"));
        assert!(result.contains("< GraphQL::Schema"));
        assert!(result.contains("def self.query: Class"));
    }

    #[test]
    fn test_generate_rbs_signatures_with_query() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![GraphQLField {
                name: "hello".to_string(),
                type_name: "String".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: true,
                arguments: vec![],
                description: None,
                deprecation_reason: None,
            }],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_rbs_signatures(&schema).unwrap();
        assert!(result.contains("def hello: () -> String | nil"));
    }

    #[test]
    fn test_generate_rbs_signatures_with_arguments() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![GraphQLField {
                name: "user".to_string(),
                type_name: "User".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: true,
                arguments: vec![GraphQLArgument {
                    name: "id".to_string(),
                    type_name: "String".to_string(),
                    is_nullable: false,
                    is_list: false,
                    list_item_nullable: false,
                    default_value: None,
                    description: None,
                }],
                description: None,
                deprecation_reason: None,
            }],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_rbs_signatures(&schema).unwrap();
        assert!(result.contains("def user: (id: String) -> User | nil"));
    }

    #[test]
    fn test_generate_rbs_signatures_with_mutation() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![],
            mutations: vec![GraphQLField {
                name: "createUser".to_string(),
                type_name: "User".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: true,
                arguments: vec![GraphQLArgument {
                    name: "name".to_string(),
                    type_name: "String".to_string(),
                    is_nullable: false,
                    is_list: false,
                    list_item_nullable: false,
                    default_value: None,
                    description: None,
                }],
                description: None,
                deprecation_reason: None,
            }],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_rbs_signatures(&schema).unwrap();
        assert!(result.contains("class MutationType"));
        assert!(result.contains("def create_user: (name: String) -> User | nil"));
        assert!(result.contains("def self.mutation: Class"));
    }

    #[test]
    fn test_generate_rbs_signatures_with_subscription() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![],
            mutations: vec![],
            subscriptions: vec![GraphQLField {
                name: "userUpdated".to_string(),
                type_name: "User".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: false,
                arguments: vec![],
                description: None,
                deprecation_reason: None,
            }],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_rbs_signatures(&schema).unwrap();
        assert!(result.contains("class SubscriptionType"));
        assert!(result.contains("def user_updated: () -> User"));
        assert!(result.contains("def self.subscription: Class"));
    }

    #[test]
    fn test_generate_rbs_signatures_with_list_type() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![GraphQLField {
                name: "users".to_string(),
                type_name: "User".to_string(),
                is_list: true,
                list_item_nullable: true,
                is_nullable: false,
                arguments: vec![],
                description: None,
                deprecation_reason: None,
            }],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        let result = generator.generate_rbs_signatures(&schema).unwrap();
        assert!(result.contains("def users: () -> Array[User | nil]"));
    }

    #[test]
    fn test_generate_type_signatures_trait_method() {
        let generator = RubyGenerator;
        let schema = GraphQLSchema {
            types: HashMap::new(),
            queries: vec![GraphQLField {
                name: "hello".to_string(),
                type_name: "String".to_string(),
                is_list: false,
                list_item_nullable: false,
                is_nullable: true,
                arguments: vec![],
                description: None,
                deprecation_reason: None,
            }],
            mutations: vec![],
            subscriptions: vec![],
            directives: vec![],
            description: None,
        };

        // Test that the trait method delegates to generate_rbs_signatures
        let result = generator.generate_type_signatures(&schema).unwrap();
        assert!(result.contains("# RBS type signatures"));
        assert!(result.contains("def hello: () -> String | nil"));
    }
}
