//! Python GraphQL code generator.
//!
//! This generator produces type-safe Python code for GraphQL resolver implementations.
//! Generated code uses type hints compatible with Python 3.10+, msgspec for serialization,
//! and Ariadne for GraphQL schema binding.

use super::GraphQLGenerator;
use crate::codegen::common::case_conversion::to_snake_case;
use crate::codegen::common::escaping::{escape_for_docstring, EscapeContext};
use crate::codegen::graphql::sdl::{SdlBuilder, TargetLanguage, TypeMapper};
use crate::codegen::graphql::spec_parser::GraphQLSchema;
use anyhow::Result;

#[derive(Default, Debug, Clone, Copy)]
pub struct PythonGenerator;

impl GraphQLGenerator for PythonGenerator {
    fn generate_types(&self, schema: &GraphQLSchema) -> Result<String> {
        use crate::codegen::graphql::spec_parser::TypeKind;

        let mut code = String::new();
        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("# ruff: noqa: EXE001, I001\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your GraphQL schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n");
        code.push_str("\"\"\"GraphQL types generated from schema.\"\"\"\n\n");

        // Check if we need to import Enum
        let has_enums = schema.types.values().any(|t| t.kind == TypeKind::Enum);
        // Check if we need to import Struct
        let has_structs = schema.types.values().any(|t| {
            matches!(t.kind, TypeKind::InputObject | TypeKind::Object)
                && t.name != "Query"
                && t.name != "Mutation"
                && t.name != "Subscription"
        });
        // Check if we need to import TypeAlias
        let has_unions = schema.types.values().any(|t| t.kind == TypeKind::Union);

        code.push_str("from __future__ import annotations\n");

        if has_enums {
            code.push_str("from enum import Enum\n");
        }
        if has_structs {
            code.push_str("from msgspec import Struct\n");
        }
        if has_unions {
            code.push_str("from typing import TypeAlias\n");
        }

        code.push_str("\n");

        // Create type mapper for Python
        let mapper = TypeMapper::new(TargetLanguage::Python, Some(schema));

        // Generate enums first
        for (_, type_def) in &schema.types {
            if type_def.kind == TypeKind::Enum {
                code.push_str(&format!("class {}(str, Enum):\n", type_def.name));
                if let Some(desc) = &type_def.description {
                    code.push_str(&format!(
                        "    \"\"\"{}\"\"\"\n",
                        escape_for_docstring(desc, EscapeContext::Python)
                    ));
                }
                for value in &type_def.enum_values {
                    if let Some(desc) = &value.description {
                        code.push_str(&format!("    # {}\n", desc));
                    }
                    code.push_str(&format!("    {} = \"{}\"\n", value.name, value.name));
                }
                code.push_str("\n\n");
            }
        }

        // Generate input objects and types
        for (_, type_def) in &schema.types {
            if type_def.kind == TypeKind::InputObject {
                code.push_str(&format!(
                    "class {}(Struct, frozen=True, kw_only=True):\n",
                    type_def.name
                ));
                if let Some(desc) = &type_def.description {
                    code.push_str(&format!(
                        "    \"\"\"{}\"\"\"\n",
                        escape_for_docstring(desc, EscapeContext::Python)
                    ));
                } else {
                    code.push_str(&format!(
                        "    \"\"\"GraphQL input type {}.\"\"\"\n",
                        type_def.name
                    ));
                }
                if type_def.input_fields.is_empty() {
                    code.push_str("    pass\n");
                } else {
                    for field in &type_def.input_fields {
                        if let Some(desc) = &field.description {
                            code.push_str(&format!("    # {}\n", desc));
                        }
                        let py_type = mapper.map_type_with_list_nullability(
                            &field.type_name,
                            field.is_nullable,
                            field.is_list,
                            field.list_item_nullable,
                        );
                        code.push_str(&format!("    {}: {}\n", field.name, py_type));
                    }
                }
                code.push_str("\n\n");
            } else if type_def.kind == TypeKind::Object
                && type_def.name != "Query"
                && type_def.name != "Mutation"
                && type_def.name != "Subscription"
            {
                code.push_str(&format!(
                    "class {}(Struct, frozen=True, kw_only=True):\n",
                    type_def.name
                ));
                if let Some(desc) = &type_def.description {
                    code.push_str(&format!(
                        "    \"\"\"{}\"\"\"\n",
                        escape_for_docstring(desc, EscapeContext::Python)
                    ));
                } else {
                    code.push_str(&format!(
                        "    \"\"\"GraphQL object type {}.\"\"\"\n",
                        type_def.name
                    ));
                }
                if type_def.fields.is_empty() {
                    code.push_str("    pass\n");
                } else {
                    for field in &type_def.fields {
                        if let Some(desc) = &field.description {
                            code.push_str(&format!("    # {}\n", desc));
                        }
                        let py_type = mapper.map_type_with_list_nullability(
                            &field.type_name,
                            field.is_nullable,
                            field.is_list,
                            field.list_item_nullable,
                        );
                        code.push_str(&format!("    {}: {}\n", field.name, py_type));
                    }
                }
                code.push_str("\n\n");
            } else if type_def.kind == TypeKind::Union {
                // Union types: use TypeAlias with quoted string for forward references
                // Quote the value to avoid "used before definition" errors in mypy --strict
                // The TypeAlias annotation tells mypy this is a type alias, not a string variable
                let members = type_def.possible_types.join(" | ");
                code.push_str(&format!("{}: TypeAlias = \"{}\"\n", type_def.name, members));
                code.push_str("\n");
            }
        }

        Ok(code)
    }

    fn generate_resolvers(&self, schema: &GraphQLSchema) -> Result<String> {
        let mut code = String::new();
        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("# ruff: noqa: EXE001, TC002, A002\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your GraphQL schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n");
        code.push_str("\"\"\"GraphQL resolver functions.\"\"\"\n\n");
        code.push_str("from __future__ import annotations\n\n");
        code.push_str("from graphql import GraphQLResolveInfo\n");

        // Collect all type names used in resolver return types and arguments
        let mut used_types: std::collections::HashSet<String> =
            std::collections::HashSet::new();

        for query in &schema.queries {
            // Add return type
            if let Some(type_name) = extract_base_type_name(&query.type_name) {
                if is_custom_type(&type_name, schema) {
                    used_types.insert(type_name);
                }
            }
            // Add argument types
            for arg in &query.arguments {
                if let Some(type_name) = extract_base_type_name(&arg.type_name) {
                    if is_custom_type(&type_name, schema) {
                        used_types.insert(type_name);
                    }
                }
            }
        }

        for mutation in &schema.mutations {
            // Add return type
            if let Some(type_name) = extract_base_type_name(&mutation.type_name) {
                if is_custom_type(&type_name, schema) {
                    used_types.insert(type_name);
                }
            }
            // Add argument types
            for arg in &mutation.arguments {
                if let Some(type_name) = extract_base_type_name(&arg.type_name) {
                    if is_custom_type(&type_name, schema) {
                        used_types.insert(type_name);
                    }
                }
            }
        }

        // Add imports for all used types
        if !used_types.is_empty() {
            let mut sorted_types: Vec<_> = used_types.iter().collect();
            sorted_types.sort();
            let types_list = sorted_types
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(", ");
            code.push_str(&format!("from .types import {}\n", types_list));
        }

        code.push_str("\n");

        // Create type mapper for Python
        let mapper = TypeMapper::new(TargetLanguage::Python, Some(schema));

        // Helper closure to format resolver signature
        let format_resolver = |name: &str,
                               field: &crate::codegen::graphql::spec_parser::GraphQLField,
                               schema: &GraphQLSchema| {
            let mut sig = format!(
                "async def resolve_{}(parent: dict[str, object], info: GraphQLResolveInfo",
                to_snake_case(name)
            );

            let mapper = TypeMapper::new(TargetLanguage::Python, Some(schema));
            for arg in &field.arguments {
                let arg_type = mapper.map_type_with_list_nullability(
                    &arg.type_name,
                    arg.is_nullable,
                    arg.is_list,
                    arg.list_item_nullable,
                );
                sig.push_str(&format!(", {}: {}", arg.name, arg_type));
            }

            let py_type = mapper.map_type_with_list_nullability(
                &field.type_name,
                field.is_nullable,
                field.is_list,
                field.list_item_nullable,
            );
            sig.push_str(&format!(") -> {}:", py_type));
            sig
        };

        // Query resolvers
        if !schema.queries.is_empty() {
            code.push_str("# Query resolvers\n\n");
            for field in &schema.queries {
                code.push_str(&format_resolver(&field.name, field, schema));
                code.push_str("\n");
                code.push_str("    \"\"\"Resolve query field.\"\"\"\n");
                code.push_str(&format!(
                    "    raise NotImplementedError(\"TODO: Implement resolve_{}\")\n\n",
                    to_snake_case(&field.name)
                ));
            }
            code.push_str("\n");
        }

        // Mutation resolvers
        if !schema.mutations.is_empty() {
            code.push_str("# Mutation resolvers\n\n");
            for field in &schema.mutations {
                code.push_str(&format_resolver(&field.name, field, schema));
                code.push_str("\n");
                code.push_str("    \"\"\"Resolve mutation field.\"\"\"\n");
                code.push_str(&format!(
                    "    raise NotImplementedError(\"TODO: Implement resolve_{}\")\n\n",
                    to_snake_case(&field.name)
                ));
            }
        }

        Ok(code)
    }

    fn generate_schema_definition(&self, schema: &GraphQLSchema) -> Result<String> {
        let mut code = String::new();

        // Header with generation info
        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your GraphQL schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n");
        code.push_str("\"\"\"GraphQL Schema Definition.\"\"\"\n\n");

        // Build imports based on what's in the schema
        code.push_str("from ariadne import make_executable_schema, QueryType, MutationType");
        if !schema.subscriptions.is_empty() {
            code.push_str(", SubscriptionType");
        }
        code.push_str("\n\n");

        // Reconstruct and embed the SDL using SdlBuilder
        let sdl = SdlBuilder::new(schema).build();
        code.push_str("# GraphQL Schema Definition Language (SDL)\n");
        code.push_str("#\n");
        code.push_str("# Defines all types, queries, mutations, and subscriptions\n");
        code.push_str("# in the GraphQL schema.\n");
        code.push_str("type_defs = \"\"\"\n");

        // Embed the SDL in triple-quoted string with proper indentation
        for line in sdl.lines() {
            code.push_str("    ");
            code.push_str(line);
            code.push_str("\n");
        }

        code.push_str("\"\"\"\n\n");

        // Create QueryType instance and document resolver setup
        code.push_str("# Query resolvers\n");
        code.push_str("query = QueryType()\n\n");

        if !schema.queries.is_empty() {
            for field in &schema.queries {
                code.push_str(&format!("# @query.field(\"{}\")\n", field.name));
                code.push_str(&format!(
                    "# async def resolve_{}(obj, info, **args):\n",
                    to_snake_case(&field.name)
                ));
                code.push_str(&format!(
                    "#     \"\"\"Resolver for Query.{}\"\"\"\n",
                    field.name
                ));
                code.push_str(&format!(
                    "#     raise NotImplementedError(\"Query.{} not implemented\")\n\n",
                    field.name
                ));
            }
        }

        // Create MutationType instance (if mutations exist)
        if !schema.mutations.is_empty() {
            code.push_str("# Mutation resolvers\n");
            code.push_str("mutation = MutationType()\n\n");

            for field in &schema.mutations {
                code.push_str(&format!("# @mutation.field(\"{}\")\n", field.name));
                code.push_str(&format!(
                    "# async def resolve_{}(obj, info, **args):\n",
                    to_snake_case(&field.name)
                ));
                code.push_str(&format!(
                    "#     \"\"\"Resolver for Mutation.{}\"\"\"\n",
                    field.name
                ));
                code.push_str(&format!(
                    "#     raise NotImplementedError(\"Mutation.{} not implemented\")\n\n",
                    field.name
                ));
            }
        } else {
            code.push_str("# mutation = MutationType()\n\n");
        }

        // Create SubscriptionType instance (if subscriptions exist)
        if !schema.subscriptions.is_empty() {
            code.push_str("# Subscription resolvers\n");
            code.push_str("subscription = SubscriptionType()\n\n");

            for field in &schema.subscriptions {
                code.push_str(&format!("# @subscription.source(\"{}\")\n", field.name));
                code.push_str(&format!(
                    "# async def subscribe_{}(obj, info, **args):\n",
                    to_snake_case(&field.name)
                ));
                code.push_str(&format!(
                    "#     \"\"\"Subscription source for Subscription.{}\"\"\"\n",
                    field.name
                ));
                code.push_str(&format!(
                    "#     raise NotImplementedError(\"Subscription.{} not implemented\")\n\n",
                    field.name
                ));
                code.push_str(&format!("# @subscription.field(\"{}\")\n", field.name));
                code.push_str(&format!(
                    "# async def resolve_{}(value, info, **args):\n",
                    to_snake_case(&field.name)
                ));
                code.push_str(&format!(
                    "#     \"\"\"Subscription resolver for Subscription.{}\"\"\"\n",
                    field.name
                ));
                code.push_str(&format!(
                    "#     raise NotImplementedError(\"Subscription.{} not implemented\")\n\n",
                    field.name
                ));
            }
        }

        // Build the executable schema
        code.push_str("# Executable GraphQL Schema\n");
        code.push_str("#\n");
        code.push_str("# Combines the type definitions with resolvers to create\n");
        code.push_str("# a fully functional GraphQL schema ready for use with\n");
        code.push_str("# Ariadne GraphQL or similar frameworks.\n");

        // Determine which resolvers to pass
        let mut resolvers = vec!["query".to_string()];
        if !schema.mutations.is_empty() {
            resolvers.push("mutation".to_string());
        }
        if !schema.subscriptions.is_empty() {
            resolvers.push("subscription".to_string());
        }

        code.push_str("schema = make_executable_schema(type_defs, [");
        code.push_str(&resolvers.join(", "));
        code.push_str("])\n\n");

        // Export type_defs for advanced use cases
        code.push_str("# Exported for advanced use cases where the SDL\n");
        code.push_str("# string might be needed directly.\n");
        code.push_str("__all__ = ['schema', 'type_defs']\n");

        Ok(code)
    }

    /// Override generate_complete to merge sections without duplicate headers
    ///
    /// When generating a complete file, each section has its own header (shebang,
    /// comments, docstrings). This reorganizes the code to have:
    /// 1. types header + imports from types section
    /// 2. external imports from resolvers/schema
    /// 3. all code from all sections
    fn generate_complete(&self, schema: &GraphQLSchema) -> Result<String> {
        let types = self.generate_types(schema)?;
        let resolvers = self.generate_resolvers(schema)?;
        let schema_def = self.generate_schema_definition(schema)?;

        // Extract imports and code, separately tracking what was in types section
        fn extract_header_imports_and_code(s: &str) -> (Vec<String>, Vec<String>, Vec<String>) {
            let mut header_lines: Vec<String> = Vec::new(); // shebang, comments, docstring
            let mut imports: Vec<String> = Vec::new();
            let mut code: Vec<String> = Vec::new();
            let mut in_header_docstring = false;
            let mut past_header = false;
            let mut found_import_section = false;

            for line in s.lines() {
                let trimmed = line.trim();

                // Skip header section before code starts
                if !past_header {
                    // Handle header docstrings (module-level docstrings at top)
                    if trimmed.starts_with("\"\"\"") {
                        // One-line docstring: starts and ends with """
                        if trimmed.len() >= 6 && trimmed.ends_with("\"\"\"") && !trimmed.starts_with("\"\"\"\"") {
                            // Skip one-line docstring entirely
                            header_lines.push(line.to_string());
                            continue;
                        } else {
                            // Multi-line docstring: toggle state
                            header_lines.push(line.to_string());
                            in_header_docstring = !in_header_docstring;
                            continue;
                        }
                    }

                    // Lines inside multi-line docstring
                    if in_header_docstring {
                        header_lines.push(line.to_string());
                        continue;
                    }

                    // Lines in preamble (shebang, DO NOT EDIT, etc.)
                    if trimmed.starts_with("#!/")
                        || trimmed.starts_with("# ruff:")
                        || trimmed.starts_with("# DO NOT EDIT")
                        || trimmed == "#"
                        || (trimmed.starts_with("# This file") && trimmed.contains("generated"))
                        || (trimmed.starts_with("# Any manual"))
                    {
                        header_lines.push(line.to_string());
                        continue;
                    }

                    // Skip empty lines in header
                    if trimmed.is_empty() {
                        continue;
                    }

                    // We've hit actual content; mark header as passed
                    past_header = true;
                }

                // Now past header - categorize the rest
                // Skip __future__ imports - only keep in types section
                if trimmed.starts_with("from __future__") {
                    if !found_import_section {
                        imports.push(line.to_string());
                        found_import_section = true;
                    }
                    continue;
                }

                // Categorize: imports vs. code
                if trimmed.starts_with("import ") || trimmed.starts_with("from ") {
                    imports.push(line.to_string());
                    found_import_section = true;
                } else {
                    if trimmed.is_empty() && !found_import_section && imports.is_empty() {
                        // Skip empty lines before imports start
                        continue;
                    }
                    code.push(line.to_string());
                }
            }

            (header_lines, imports, code)
        }

        let (types_header, types_imports, types_code) =
            extract_header_imports_and_code(&types);
        let (_resolvers_header, resolvers_imports, resolvers_code) =
            extract_header_imports_and_code(&resolvers);
        let (_schema_def_header, schema_def_imports, schema_def_code) =
            extract_header_imports_and_code(&schema_def);

        // Collect all external imports (skip "from .types" imports)
        let mut all_imports: Vec<String> = types_imports;
        for imp in resolvers_imports
            .iter()
            .chain(schema_def_imports.iter())
        {
            let trimmed = imp.trim();
            // Skip imports from .types (relative imports from types module)
            if trimmed.starts_with("from .types") {
                continue;
            }
            if !all_imports.contains(imp) {
                all_imports.push(imp.clone());
            }
        }

        // Build final result with proper Python import structure:
        // 1. Header (shebang, comments)
        // 2. All imports
        // 3. All code (type definitions + resolvers + schema)
        let mut result = String::new();

        // Add header
        for header_line in types_header {
            result.push_str(&header_line);
            result.push('\n');
        }

        // Add all imports
        for imp in &all_imports {
            result.push_str(imp);
            result.push('\n');
        }

        // Add types code
        if !types_code.is_empty() {
            result.push('\n');
            for line in types_code {
                result.push_str(&line);
                result.push('\n');
            }
        }

        // Add resolvers code
        if !resolvers_code.is_empty() {
            result.push('\n');
            for line in resolvers_code {
                result.push_str(&line);
                result.push('\n');
            }
        }

        // Add schema definition code
        if !schema_def_code.is_empty() {
            result.push('\n');
            for line in schema_def_code {
                result.push_str(&line);
                result.push('\n');
            }
        }

        // Trim excess trailing newlines and add single newline
        result = result.trim_end().to_string();
        result.push('\n');

        Ok(result)
    }
}

/// Extract the base type name from a GraphQL type string.
///
/// Removes wrappers like !, [, ] to get the raw type name.
/// Examples: "String!" → "String", "[User]" → "User", "Post!" → "Post"
fn extract_base_type_name(type_name: &str) -> Option<String> {
    let clean = type_name.trim_matches(|c| c == '!' || c == '[' || c == ']');
    if clean.is_empty() {
        None
    } else {
        Some(clean.to_string())
    }
}

/// Check if a type is a custom type (not a built-in scalar).
///
/// Built-in scalars: String, Int, Float, Boolean, ID, DateTime, Date, Time, JSON, Upload
fn is_custom_type(type_name: &str, schema: &GraphQLSchema) -> bool {
    let built_ins = [
        "String", "Int", "Float", "Boolean", "ID", "DateTime", "Date", "Time", "JSON",
        "Upload",
    ];

    if built_ins.contains(&type_name) {
        return false;
    }

    // Check if it's defined in the schema
    schema.types.contains_key(type_name)
}
