//! TypeScript/JavaScript code formatter.
//!
//! Implements the `Formatter` trait for TypeScript code generation, ensuring output
//! adheres to modern TypeScript standards, Biome formatting rules, and follows spikard's
//! performance patterns.
//!
//! # Features
//!
//! - **Headers**: Auto-generation notices, `JSDoc` file-level comments with metadata
//! - **Imports**: Grouped and sorted (type imports first, then external, then local)
//! - **Docstrings**: `JSDoc` format with proper escaping of special sequences
//! - **Spacing**: Single blank line between top-level declarations

use super::{Formatter, HeaderMetadata, Import, Section};
use std::collections::BTreeMap;

/// TypeScript code formatter implementing language-specific conventions
///
/// Formats generated TypeScript code to comply with:
/// - Biome formatting rules (single quotes, semicolons, 2-space indentation)
/// - `JSDoc` documentation standards
/// - TypeScript strict mode conventions
/// - Module organization (imports → exports → implementations)
///
/// # Example
///
/// ```
/// use spikard_cli::codegen::formatters::{Formatter, TypeScriptFormatter, HeaderMetadata, Import};
///
/// let formatter = TypeScriptFormatter::new();
/// let metadata = HeaderMetadata {
///     auto_generated: true,
///     schema_file: Some("api.openapi.json".to_string()),
///     generator_version: Some("0.6.2".to_string()),
/// };
///
/// let header = formatter.format_header(&metadata);
/// assert!(header.contains("DO NOT EDIT"));
/// assert!(header.contains("api.openapi.json"));
/// ```
#[derive(Debug, Clone)]
pub struct TypeScriptFormatter;

impl TypeScriptFormatter {
    /// Create a new TypeScript code formatter
    #[must_use] 
    pub const fn new() -> Self {
        Self
    }

    /// Determine if an import source is external (npm package).
    fn is_external_import(source: &str) -> bool {
        !source.starts_with('.') && !source.starts_with('/')
    }

    /// Escape `JSDoc` delimiters in content.
    fn escape_jsdoc_content(content: &str) -> String {
        content.replace("*/", "*&#47;").replace("/*", "&#47;*")
    }
}

impl Default for TypeScriptFormatter {
    fn default() -> Self {
        Self::new()
    }
}

impl Formatter for TypeScriptFormatter {
    fn format_header(&self, metadata: &HeaderMetadata) -> String {
        let mut header = String::new();

        // Auto-generation notice
        header.push_str("// DO NOT EDIT - Auto-generated by Spikard CLI\n");

        // Optional schema file and version comments
        if let Some(schema) = &metadata.schema_file {
            header.push_str(&format!("// Source: {schema}\n"));
        }
        if let Some(version) = &metadata.generator_version {
            header.push_str(&format!("// Generator: Spikard {version}\n"));
        }

        // JSDoc file-level comment
        header.push_str("/**\n");
        header.push_str(" * Auto-generated TypeScript code from API schema\n");
        if metadata.schema_file.is_some() || metadata.generator_version.is_some() {
            header.push_str(" *\n");
        }
        if let Some(schema) = &metadata.schema_file {
            header.push_str(&format!(" * @source {schema}\n"));
        }
        if let Some(version) = &metadata.generator_version {
            header.push_str(&format!(" * @generator Spikard {version}\n"));
        }
        header.push_str(" */");

        header
    }

    fn format_imports(&self, imports: &[Import]) -> String {
        if imports.is_empty() {
            return String::new();
        }

        // Separate imports by category
        let mut external_type_imports = BTreeMap::new();
        let mut internal_type_imports = BTreeMap::new();
        let mut external_imports = BTreeMap::new();
        let mut internal_imports = BTreeMap::new();

        for import in imports {
            let is_external = Self::is_external_import(&import.module);

            if import.is_type_only {
                if is_external {
                    external_type_imports
                        .entry(import.module.clone())
                        .or_insert_with(Vec::new)
                        .extend(import.items.iter().cloned());
                } else {
                    internal_type_imports
                        .entry(import.module.clone())
                        .or_insert_with(Vec::new)
                        .extend(import.items.iter().cloned());
                }
            } else if is_external {
                external_imports
                    .entry(import.module.clone())
                    .or_insert_with(Vec::new)
                    .extend(import.items.iter().cloned());
            } else {
                internal_imports
                    .entry(import.module.clone())
                    .or_insert_with(Vec::new)
                    .extend(import.items.iter().cloned());
            }
        }

        let mut result = String::new();

        // Write type imports first (external then internal)
        for (module, items) in &external_type_imports {
            if items.is_empty() {
                result.push_str(&format!("import type '{module}';"));
            } else {
                let sorted_items: Vec<_> = items.clone();
                let joined = sorted_items.join(", ");
                result.push_str(&format!("import type {{ {joined} }} from '{module}';"));
            }
            result.push('\n');
        }

        for (module, items) in &internal_type_imports {
            if items.is_empty() {
                result.push_str(&format!("import type '{module}';"));
            } else {
                let sorted_items: Vec<_> = items.clone();
                let joined = sorted_items.join(", ");
                result.push_str(&format!("import type {{ {joined} }} from '{module}';"));
            }
            result.push('\n');
        }

        // Add blank line between type and regular imports if both exist
        if !external_type_imports.is_empty() && !internal_type_imports.is_empty() {
            result.push('\n');
        }
        if (!external_type_imports.is_empty() || !internal_type_imports.is_empty())
            && (!external_imports.is_empty() || !internal_imports.is_empty())
        {
            result.push('\n');
        }

        // Write regular imports (external then internal)
        for (module, items) in &external_imports {
            if items.is_empty() {
                result.push_str(&format!("import '{module}';"));
            } else {
                let sorted_items: Vec<_> = items.clone();
                let joined = sorted_items.join(", ");
                result.push_str(&format!("import {{ {joined} }} from '{module}';"));
            }
            result.push('\n');
        }

        for (module, items) in &internal_imports {
            if items.is_empty() {
                result.push_str(&format!("import '{module}';"));
            } else {
                let sorted_items: Vec<_> = items.clone();
                let joined = sorted_items.join(", ");
                result.push_str(&format!("import {{ {joined} }} from '{module}';"));
            }
            result.push('\n');
        }

        // Remove trailing newline (will be added during merge)
        if result.ends_with('\n') {
            result.pop();
        }

        result
    }

    fn format_docstring(&self, content: &str) -> String {
        let escaped = Self::escape_jsdoc_content(content);
        let lines: Vec<&str> = escaped.lines().collect();

        if lines.is_empty() {
            return String::new();
        }

        let mut result = String::new();

        if lines.len() == 1 {
            // Single-line JSDoc
            result.push_str(&format!("/** {} */", lines[0]));
        } else {
            // Multi-line JSDoc with proper alignment
            result.push_str("/**\n");
            for line in lines {
                if line.trim().is_empty() {
                    result.push_str(" *\n");
                } else {
                    result.push_str(&format!(" * {line}\n"));
                }
            }
            result.push_str(" */");
        }

        result
    }

    fn merge_sections(&self, sections: &[Section]) -> String {
        let mut parts = Vec::new();

        // Extract and organize sections
        let mut header = String::new();
        let mut imports = String::new();
        let mut body = String::new();

        for section in sections {
            match section {
                Section::Header(h) => header = h.clone(),
                Section::Imports(i) => imports = i.clone(),
                Section::Body(b) => body = b.clone(),
            }
        }

        // Build final output
        if !header.is_empty() {
            parts.push(header);
        }

        if !imports.is_empty() {
            parts.push(imports);
        }

        if !body.is_empty() {
            parts.push(body);
        }

        // Join with single blank line between sections
        let result = parts.join("\n\n");

        // Ensure trailing newline
        if result.is_empty() {
            String::new()
        } else if result.ends_with('\n') {
            result
        } else {
            format!("{result}\n")
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_header_with_metadata() {
        let formatter = TypeScriptFormatter::new();
        let metadata = HeaderMetadata {
            auto_generated: true,
            schema_file: Some("api.openapi.json".to_string()),
            generator_version: Some("0.6.2".to_string()),
        };
        let header = formatter.format_header(&metadata);
        assert!(header.contains("DO NOT EDIT"));
        assert!(header.contains("api.openapi.json"));
        assert!(header.contains("0.6.2"));
        assert!(header.contains("/**"));
    }

    #[test]
    fn test_format_header_minimal() {
        let formatter = TypeScriptFormatter::new();
        let metadata = HeaderMetadata {
            auto_generated: true,
            schema_file: None,
            generator_version: None,
        };
        let header = formatter.format_header(&metadata);
        assert!(header.contains("DO NOT EDIT"));
        assert!(header.contains("/**"));
    }

    #[test]
    fn test_format_imports_type_first() {
        let formatter = TypeScriptFormatter::new();
        let imports = vec![
            Import {
                module: "express".to_string(),
                items: vec!["Application".to_string()],
                is_type_only: false,
            },
            Import {
                module: "express".to_string(),
                items: vec!["RequestHandler".to_string()],
                is_type_only: true,
            },
        ];

        let result = formatter.format_imports(&imports);
        let type_pos = result.find("import type").expect("type import");
        let regular_pos = result.find("import {").expect("regular import");
        assert!(type_pos < regular_pos, "Type imports should come first");
    }

    #[test]
    fn test_format_imports_external_before_internal() {
        let formatter = TypeScriptFormatter::new();
        let imports = vec![
            Import {
                module: "./handlers".to_string(),
                items: vec!["handler".to_string()],
                is_type_only: false,
            },
            Import {
                module: "express".to_string(),
                items: vec!["Application".to_string()],
                is_type_only: false,
            },
        ];

        let result = formatter.format_imports(&imports);
        let express_pos = result.find("express").expect("express import");
        let handlers_pos = result.find("./handlers").expect("local import");
        assert!(express_pos < handlers_pos, "External imports should come before local");
    }

    #[test]
    fn test_format_docstring_single_line() {
        let formatter = TypeScriptFormatter::new();
        let doc = formatter.format_docstring("User API handler");
        assert!(doc.starts_with("/** "));
        assert!(doc.ends_with(" */"));
        assert!(doc.contains("User API handler"));
    }

    #[test]
    fn test_format_docstring_multiline() {
        let formatter = TypeScriptFormatter::new();
        let content = "User API handler\nHandles user CRUD\nOperations";
        let doc = formatter.format_docstring(content);
        assert!(doc.starts_with("/**\n"));
        assert!(doc.ends_with("*/"));
        assert!(doc.contains("User API handler"));
        assert!(doc.contains("Handles user CRUD"));
    }

    #[test]
    fn test_format_docstring_escapes_delimiters() {
        let formatter = TypeScriptFormatter::new();
        let content = "This has */ and /* in it";
        let doc = formatter.format_docstring(content);
        assert!(doc.contains("&#47;"));
    }

    #[test]
    fn test_merge_sections() {
        let formatter = TypeScriptFormatter::new();
        let sections = vec![
            Section::Header("// Header".to_string()),
            Section::Imports("import { x } from 'y';".to_string()),
            Section::Body("export const handler = () => {};".to_string()),
        ];

        let result = formatter.merge_sections(&sections);
        assert!(result.contains("// Header"));
        assert!(result.contains("import"));
        assert!(result.contains("export"));
        assert!(result.ends_with('\n'));
    }
}
