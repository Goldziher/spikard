//! TypeScript Protobuf code generator.
//!
//! This generator produces type-safe TypeScript code for Protobuf message and service definitions.
//! Generated code uses async/await patterns with protobufjs library for runtime type support.

use super::ProtobufGenerator;
use super::base::{escape_string, map_proto_type_to_language, sanitize_identifier};
use crate::codegen::protobuf::spec_parser::{ProtobufSchema, FieldLabel, MessageDef, ServiceDef};
use anyhow::Result;

/// TypeScript Protobuf code generator
#[derive(Default, Debug, Clone, Copy)]
#[allow(dead_code)]
pub struct TypeScriptProtobufGenerator;

impl ProtobufGenerator for TypeScriptProtobufGenerator {
    fn generate_messages(&self, schema: &ProtobufSchema) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("// DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("//\n");
        code.push_str("// This file was automatically generated from your Protobuf schema.\n");
        code.push_str("// Any manual changes will be overwritten on the next generation.\n");
        code.push('\n');

        // Imports
        code.push_str("import * as $protobuf from \"protobufjs\";\n\n");

        // Package comment
        if let Some(package) = &schema.package {
            code.push_str(&format!("// Package: {}\n\n", package));
        }

        // Generate message definitions
        for message in schema.messages.values() {
            code.push_str(&self.generate_message_interface(message));
            code.push_str("\n\n");
        }

        // Generate enum definitions
        for enum_def in schema.enums.values() {
            code.push_str(&self.generate_enum_type(enum_def));
            code.push_str("\n\n");
        }

        Ok(code.trim_end().to_string() + "\n")
    }

    fn generate_services(&self, schema: &ProtobufSchema) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("// DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("//\n");
        code.push_str("// This file was automatically generated from your Protobuf schema.\n");
        code.push_str("// Any manual changes will be overwritten on the next generation.\n");
        code.push('\n');

        // Imports
        code.push_str("import * as $protobuf from \"protobufjs\";\n\n");

        // Package comment
        if let Some(package) = &schema.package {
            code.push_str(&format!("// Package: {}\n\n", package));
        }

        // Generate service definitions
        if schema.services.is_empty() {
            code.push_str("// No services defined in this schema.\n");
        } else {
            for service in schema.services.values() {
                code.push_str(&self.generate_service_class(service));
                code.push_str("\n\n");
            }
        }

        Ok(code.trim_end().to_string() + "\n")
    }
}

impl TypeScriptProtobufGenerator {
    /// Generate a message interface definition
    #[allow(dead_code)]
    fn generate_message_interface(&self, message: &MessageDef) -> String {
        let mut code = String::new();

        // JSDoc comment
        if let Some(desc) = &message.description {
            code.push_str("/**\n");
            code.push_str(&format!(" * {}\n", escape_string(desc, "typescript")));
            code.push_str(" */\n");
        }

        // Interface definition
        code.push_str(&format!("export interface {} {{\n", message.name));

        if message.fields.is_empty() {
            code.push_str("}\n");
        } else {
            // Add field properties
            for field in &message.fields {
                // Field comment if available
                if let Some(desc) = &field.description {
                    code.push_str(&format!("  /** {} */\n", desc));
                }

                let field_name = sanitize_identifier(&field.name, "typescript");
                let is_optional = field.label == FieldLabel::Optional;
                let is_repeated = field.label == FieldLabel::Repeated;

                let field_type =
                    map_proto_type_to_language(&field.field_type, "typescript", is_optional, is_repeated);

                // Optional fields use ? suffix in TypeScript
                if is_optional || is_repeated {
                    code.push_str(&format!("  {}?: {};\n", field_name, field_type));
                } else {
                    code.push_str(&format!("  {}: {};\n", field_name, field_type));
                }
            }

            code.push_str("}\n");
        }

        code
    }

    /// Generate an enum type definition
    #[allow(dead_code)]
    fn generate_enum_type(&self, enum_def: &crate::codegen::protobuf::spec_parser::EnumDef) -> String {
        let mut code = String::new();

        // JSDoc comment
        if let Some(desc) = &enum_def.description {
            code.push_str("/**\n");
            code.push_str(&format!(" * {}\n", escape_string(desc, "typescript")));
            code.push_str(" */\n");
        }

        code.push_str(&format!("export enum {} {{\n", enum_def.name));

        if enum_def.values.is_empty() {
            code.push_str("}\n");
        } else {
            for (idx, value) in enum_def.values.iter().enumerate() {
                if let Some(desc) = &value.description {
                    code.push_str(&format!("  /** {} */\n", desc));
                }

                let comma = if idx < enum_def.values.len() - 1 { "," } else { "" };
                code.push_str(&format!("  {} = {}{}\n", value.name, value.number, comma));
            }
            code.push_str("}\n");
        }

        code
    }

    /// Generate a service class definition (server interface)
    #[allow(dead_code)]
    fn generate_service_class(&self, service: &ServiceDef) -> String {
        let mut code = String::new();

        // JSDoc comment
        if let Some(desc) = &service.description {
            code.push_str("/**\n");
            code.push_str(&format!(" * Server handler interface for {}.\n", service.name));
            code.push_str(&format!(" * {}\n", escape_string(desc, "typescript")));
            code.push_str(" */\n");
        } else {
            code.push_str("/**\n");
            code.push_str(&format!(" * Server handler interface for {}.\n", service.name));
            code.push_str(" */\n");
        }

        code.push_str(&format!("export class {}Service {{\n", service.name));

        if service.methods.is_empty() {
            code.push_str("}\n");
        } else {
            for method in &service.methods {
                code.push('\n');

                // Method JSDoc comment
                if let Some(desc) = &method.description {
                    code.push_str(&format!("  /** {} */\n", desc));
                }

                // Build method signature
                let method_name = sanitize_identifier(&method.name, "typescript");
                let request_type = &method.input_type;
                let response_type = &method.output_type;

                // Determine return type based on streaming
                let return_type = if method.output_streaming {
                    format!("AsyncIterable<{}>", response_type)
                } else {
                    format!("Promise<{}>", response_type)
                };

                code.push_str(&format!(
                    "  async {}(request: {}): {} {{\n",
                    method_name, request_type, return_type
                ));

                code.push_str("    throw new Error(\"Not implemented\");\n");
                code.push_str("  }\n");
            }
            code.push_str("}\n");
        }

        code
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::protobuf::spec_parser::{MessageDef, FieldDef, ProtoType, FieldLabel, EnumDef, EnumValue};

    #[test]
    fn test_generate_simple_message() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "id".to_string(),
                    number: 1,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
                FieldDef {
                    name: "name".to_string(),
                    number: 2,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: Some("User's full name".to_string()),
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: Some("Represents a user".to_string()),
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("export interface User"));
        assert!(code.contains("Represents a user"));
        assert!(code.contains("id: string"));
        assert!(code.contains("name: string"));
        assert!(code.contains("User's full name"));
    }

    #[test]
    fn test_generate_message_with_optional_field() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "email".to_string(),
                    number: 3,
                    field_type: ProtoType::String,
                    label: FieldLabel::Optional,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("email?: string"));
    }

    #[test]
    fn test_generate_message_with_repeated_field() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "tags".to_string(),
                    number: 4,
                    field_type: ProtoType::String,
                    label: FieldLabel::Repeated,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("tags?: string[]"));
    }

    #[test]
    fn test_generate_enum_type() {
        let enum_def = EnumDef {
            name: "Status".to_string(),
            values: vec![
                EnumValue {
                    name: "UNKNOWN".to_string(),
                    number: 0,
                    description: None,
                },
                EnumValue {
                    name: "ACTIVE".to_string(),
                    number: 1,
                    description: Some("Status is active".to_string()),
                },
                EnumValue {
                    name: "INACTIVE".to_string(),
                    number: 2,
                    description: None,
                },
            ],
            description: Some("User status enumeration".to_string()),
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_enum_type(&enum_def);

        assert!(code.contains("export enum Status"));
        assert!(code.contains("User status enumeration"));
        assert!(code.contains("UNKNOWN = 0"));
        assert!(code.contains("ACTIVE = 1,"));
        assert!(code.contains("Status is active"));
        assert!(code.contains("INACTIVE = 2"));
    }

    #[test]
    fn test_generate_message_with_number_field() {
        let message = MessageDef {
            name: "Order".to_string(),
            fields: vec![
                FieldDef {
                    name: "amount".to_string(),
                    number: 1,
                    field_type: ProtoType::Int32,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("amount: number"));
    }

    #[test]
    fn test_generate_message_with_bigint_field() {
        let message = MessageDef {
            name: "LargeNumber".to_string(),
            fields: vec![
                FieldDef {
                    name: "big_id".to_string(),
                    number: 1,
                    field_type: ProtoType::Int64,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("bigId: bigint"));
    }

    #[test]
    fn test_generate_message_with_boolean_field() {
        let message = MessageDef {
            name: "Settings".to_string(),
            fields: vec![
                FieldDef {
                    name: "is_enabled".to_string(),
                    number: 1,
                    field_type: ProtoType::Bool,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("isEnabled: boolean"));
    }

    #[test]
    fn test_generate_message_with_bytes_field() {
        let message = MessageDef {
            name: "Data".to_string(),
            fields: vec![
                FieldDef {
                    name: "content".to_string(),
                    number: 1,
                    field_type: ProtoType::Bytes,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("content: Buffer | Uint8Array"));
    }

    #[test]
    fn test_generate_service_with_async_method() {
        use crate::codegen::protobuf::spec_parser::{ServiceDef, MethodDef};

        let service = ServiceDef {
            name: "User".to_string(),
            methods: vec![
                MethodDef {
                    name: "get_user".to_string(),
                    input_type: "GetUserRequest".to_string(),
                    output_type: "User".to_string(),
                    input_streaming: false,
                    output_streaming: false,
                    description: Some("Get a user by ID".to_string()),
                },
            ],
            description: Some("User service".to_string()),
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_service_class(&service);

        assert!(code.contains("export class UserService"));
        assert!(code.contains("User service"));
        assert!(code.contains("async getUser(request: GetUserRequest): Promise<User>"));
        assert!(code.contains("Get a user by ID"));
        assert!(code.contains("throw new Error(\"Not implemented\")"));
    }

    #[test]
    fn test_generate_service_with_streaming_method() {
        use crate::codegen::protobuf::spec_parser::{ServiceDef, MethodDef};

        let service = ServiceDef {
            name: "Stream".to_string(),
            methods: vec![
                MethodDef {
                    name: "get_items".to_string(),
                    input_type: "Query".to_string(),
                    output_type: "Item".to_string(),
                    input_streaming: false,
                    output_streaming: true,
                    description: None,
                },
            ],
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_service_class(&service);

        assert!(code.contains("export class StreamService"));
        assert!(code.contains("async getItems(request: Query): AsyncIterable<Item>"));
    }

    #[test]
    fn test_generate_complete_messages_file() {
        let mut messages = std::collections::HashMap::new();
        messages.insert(
            "User".to_string(),
            MessageDef {
                name: "User".to_string(),
                fields: vec![
                    FieldDef {
                        name: "id".to_string(),
                        number: 1,
                        field_type: ProtoType::String,
                        label: FieldLabel::None,
                        default_value: None,
                        description: None,
                    },
                ],
                nested_messages: std::collections::HashMap::new(),
                nested_enums: std::collections::HashMap::new(),
                description: None,
            },
        );

        let schema = ProtobufSchema {
            package: Some("example".to_string()),
            messages,
            services: std::collections::HashMap::new(),
            enums: std::collections::HashMap::new(),
            imports: vec![],
            syntax: "proto3".to_string(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_messages(&schema).expect("Failed to generate messages");

        assert!(code.contains("// DO NOT EDIT - Auto-generated by Spikard CLI"));
        assert!(code.contains("import * as $protobuf from \"protobufjs\""));
        assert!(code.contains("// Package: example"));
        assert!(code.contains("export interface User"));
    }

    #[test]
    fn test_generate_complete_services_file() {
        use crate::codegen::protobuf::spec_parser::{ServiceDef, MethodDef};

        let mut services = std::collections::HashMap::new();
        services.insert(
            "UserService".to_string(),
            ServiceDef {
                name: "User".to_string(),
                methods: vec![
                    MethodDef {
                        name: "get_user".to_string(),
                        input_type: "GetUserRequest".to_string(),
                        output_type: "User".to_string(),
                        input_streaming: false,
                        output_streaming: false,
                        description: None,
                    },
                ],
                description: None,
            },
        );

        let schema = ProtobufSchema {
            package: Some("example".to_string()),
            messages: std::collections::HashMap::new(),
            services,
            enums: std::collections::HashMap::new(),
            imports: vec![],
            syntax: "proto3".to_string(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_services(&schema).expect("Failed to generate services");

        assert!(code.contains("// DO NOT EDIT - Auto-generated by Spikard CLI"));
        assert!(code.contains("import * as $protobuf from \"protobufjs\""));
        assert!(code.contains("// Package: example"));
        assert!(code.contains("export class UserService"));
    }

    #[test]
    fn test_sanitize_snake_case_to_camel_case() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "first_name".to_string(),
                    number: 1,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
                FieldDef {
                    name: "last_name".to_string(),
                    number: 2,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = TypeScriptProtobufGenerator;
        let code = generator.generate_message_interface(&message);

        assert!(code.contains("firstName: string"));
        assert!(code.contains("lastName: string"));
    }
}
