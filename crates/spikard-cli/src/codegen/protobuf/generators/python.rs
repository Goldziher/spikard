//! Python Protobuf code generator.
//!
//! This generator produces type-safe Python code for Protobuf message and service definitions.
//! Generated code uses type hints compatible with Python 3.10+ and the google.protobuf library.

use super::ProtobufGenerator;
use super::base::{escape_string, map_proto_type_to_language, sanitize_identifier};
use crate::codegen::protobuf::spec_parser::{ProtobufSchema, FieldLabel, MessageDef, ServiceDef};
use anyhow::Result;

/// Python Protobuf code generator
#[derive(Default, Debug, Clone, Copy)]
#[allow(dead_code)]
pub struct PythonProtobufGenerator;

impl ProtobufGenerator for PythonProtobufGenerator {
    fn generate_messages(&self, schema: &ProtobufSchema) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your Protobuf schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n");
        code.push_str("\"\"\"Protocol Buffer message definitions.\"\"\"\n\n");

        // Imports
        code.push_str("from __future__ import annotations\n\n");
        code.push_str("from google.protobuf import message as _message\n");
        code.push_str("from google.protobuf import descriptor as _descriptor\n");
        code.push_str("from typing import Optional\n\n");

        // Package comment
        if let Some(package) = &schema.package {
            code.push_str(&format!("# Package: {}\n\n", package));
        }

        // Generate message definitions
        for message in schema.messages.values() {
            code.push_str(&self.generate_message_class(message));
            code.push_str("\n\n");
        }

        // Generate enum definitions
        for enum_def in schema.enums.values() {
            code.push_str(&self.generate_enum_class(enum_def));
            code.push_str("\n\n");
        }

        Ok(code.trim_end().to_string() + "\n")
    }

    fn generate_services(&self, schema: &ProtobufSchema) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your Protobuf schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n");
        code.push_str("\"\"\"Protocol Buffer service definitions.\"\"\"\n\n");

        // Imports
        code.push_str("from __future__ import annotations\n\n");
        code.push_str("import grpc\n");
        code.push_str("from typing import AsyncIterator\n\n");

        // Package comment
        if let Some(package) = &schema.package {
            code.push_str(&format!("# Package: {}\n\n", package));
        }

        // Generate service definitions
        if schema.services.is_empty() {
            code.push_str("# No services defined in this schema.\n");
        } else {
            for service in schema.services.values() {
                code.push_str(&self.generate_service_class(service));
                code.push_str("\n\n");
            }
        }

        Ok(code.trim_end().to_string() + "\n")
    }
}

impl PythonProtobufGenerator {
    /// Generate a message class definition
    #[allow(dead_code)]
    fn generate_message_class(&self, message: &MessageDef) -> String {
        let mut code = String::new();

        // Class definition
        code.push_str(&format!("class {}(_message.Message):\n", message.name));

        // Docstring
        if let Some(desc) = &message.description {
            code.push_str(&format!("    \"\"\"{}.\"\"\"\n", escape_string(desc, "python")));
        } else {
            code.push_str("    \"\"\"Generated protocol buffer message.\"\"\"\n");
        }

        if message.fields.is_empty() {
            code.push_str("    pass\n");
        } else {
            // Add field type hints
            for field in &message.fields {
                // Field comment if available
                if let Some(desc) = &field.description {
                    code.push_str(&format!("    # {}\n", desc));
                }

                let field_name = sanitize_identifier(&field.name, "python");
                let is_optional = field.label == FieldLabel::Optional;
                let is_repeated = field.label == FieldLabel::Repeated;

                let field_type =
                    map_proto_type_to_language(&field.field_type, "python", is_optional, is_repeated);
                code.push_str(&format!("    {}: {}\n", field_name, field_type));
            }

            // Constructor
            code.push('\n');
            code.push_str("    def __init__(self");

            // Constructor parameters
            for field in &message.fields {
                let field_name = sanitize_identifier(&field.name, "python");
                let is_optional = field.label == FieldLabel::Optional;
                let is_repeated = field.label == FieldLabel::Repeated;

                let field_type =
                    map_proto_type_to_language(&field.field_type, "python", is_optional, is_repeated);

                // Default value based on type
                let default_val = if is_repeated || is_optional {
                    "None".to_string()
                } else if matches!(field.field_type, crate::codegen::protobuf::spec_parser::ProtoType::String) {
                    "\"\"".to_string()
                } else if matches!(field.field_type, crate::codegen::protobuf::spec_parser::ProtoType::Bytes) {
                    "b\"\"".to_string()
                } else if matches!(field.field_type, crate::codegen::protobuf::spec_parser::ProtoType::Bool) {
                    "False".to_string()
                } else {
                    "0".to_string()
                };

                code.push_str(&format!(", {}: {} = {}", field_name, field_type, default_val));
            }

            code.push_str(") -> None: ...\n");
        }

        code
    }

    /// Generate an enum class definition
    #[allow(dead_code)]
    fn generate_enum_class(&self, enum_def: &crate::codegen::protobuf::spec_parser::EnumDef) -> String {
        let mut code = String::new();

        code.push_str(&format!("class {}(int):\n", enum_def.name));

        // Docstring
        if let Some(desc) = &enum_def.description {
            code.push_str(&format!("    \"\"\"{}.\"\"\"\n", escape_string(desc, "python")));
        } else {
            code.push_str("    \"\"\"Protobuf enum type.\"\"\"\n");
        }

        if enum_def.values.is_empty() {
            code.push_str("    pass\n");
        } else {
            for value in &enum_def.values {
                if let Some(desc) = &value.description {
                    code.push_str(&format!("    # {}\n", desc));
                }
                code.push_str(&format!("    {} = {}\n", value.name, value.number));
            }
        }

        code
    }

    /// Generate a service class definition (server interface)
    #[allow(dead_code)]
    fn generate_service_class(&self, service: &ServiceDef) -> String {
        let mut code = String::new();

        // Service class
        code.push_str(&format!("class {}Servicer:\n", service.name));

        // Docstring
        if let Some(desc) = &service.description {
            code.push_str(&format!(
                "    \"\"\"Server handler interface for {}. {}.\"\"\"\n",
                service.name,
                escape_string(desc, "python")
            ));
        } else {
            code.push_str(&format!(
                "    \"\"\"Server handler interface for {}.\"\"\"\n",
                service.name
            ));
        }

        if service.methods.is_empty() {
            code.push_str("    pass\n");
        } else {
            for method in &service.methods {
                code.push('\n');

                // Method docstring
                if let Some(desc) = &method.description {
                    code.push_str(&format!("    # {}\n", desc));
                }

                // Build method signature
                let method_name = sanitize_identifier(&method.name, "python");
                let request_type = &method.input_type;
                let response_type = &method.output_type;

                // Determine if async is needed and return type
                let (async_keyword, return_type) = if method.output_streaming {
                    ("async ".to_string(), format!("AsyncIterator[{}]", response_type))
                } else {
                    ("async ".to_string(), response_type.clone())
                };

                code.push_str(&format!(
                    "    {}def {}(self, request: {}, context: grpc.aio.ServicerContext) -> {}:\n",
                    async_keyword, method_name, request_type, return_type
                ));

                code.push_str("        \"\"\"Implement this method.\"\"\"\n");
                code.push_str("        raise NotImplementedError()\n");
            }
        }

        code
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::protobuf::spec_parser::{MessageDef, FieldDef, ProtoType, FieldLabel};

    #[test]
    fn test_generate_simple_message() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "id".to_string(),
                    number: 1,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
                FieldDef {
                    name: "name".to_string(),
                    number: 2,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: Some("User's full name".to_string()),
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: Some("Represents a user".to_string()),
        };

        let generator = PythonProtobufGenerator;
        let code = generator.generate_message_class(&message);

        assert!(code.contains("class User(_message.Message):"));
        assert!(code.contains("Represents a user"));
        assert!(code.contains("id: str"));
        assert!(code.contains("name: str"));
        assert!(code.contains("def __init__"));
    }

    #[test]
    fn test_generate_message_with_optional_field() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "email".to_string(),
                    number: 3,
                    field_type: ProtoType::String,
                    label: FieldLabel::Optional,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = PythonProtobufGenerator;
        let code = generator.generate_message_class(&message);

        assert!(code.contains("email: Optional[str]"));
    }

    #[test]
    fn test_generate_message_with_repeated_field() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "tags".to_string(),
                    number: 4,
                    field_type: ProtoType::String,
                    label: FieldLabel::Repeated,
                    default_value: None,
                    description: None,
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = PythonProtobufGenerator;
        let code = generator.generate_message_class(&message);

        assert!(code.contains("tags: list[str]"));
    }
}
