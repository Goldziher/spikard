//! Ruby Protobuf code generator.
//!
//! This generator produces type-safe Ruby code for Protobuf message and service definitions.
//! Generated code uses google-protobuf gem with RBS type signatures in comments.

use super::ProtobufGenerator;
use super::base::{escape_string, map_proto_type_to_language, sanitize_identifier, to_pascal_case};
use crate::codegen::protobuf::spec_parser::{FieldLabel, MessageDef, ProtobufSchema, ServiceDef};
use anyhow::Result;

/// Ruby Protobuf code generator
#[derive(Default, Debug, Clone, Copy)]
#[allow(dead_code)]
pub struct RubyProtobufGenerator;

impl ProtobufGenerator for RubyProtobufGenerator {
    fn generate_messages(&self, schema: &ProtobufSchema) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("# frozen_string_literal: true\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your Protobuf schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n\n");

        // Imports
        code.push_str("require 'google/protobuf'\n\n");

        // Package comment
        if let Some(package) = &schema.package {
            code.push_str(&format!("# Package: {}\n\n", package));
        }

        // Generate module namespace if package exists
        let modules = if let Some(package) = &schema.package {
            let parts: Vec<&str> = package.split('.').collect();
            for (i, part) in parts.iter().enumerate() {
                code.push_str(&format!("{}module {}\n", "  ".repeat(i), to_pascal_case(part)));
            }
            code.push('\n');
            parts.len()
        } else {
            0
        };

        // Generate message definitions
        for message in schema.messages.values() {
            code.push_str(&self.generate_message_class(message, modules));
            code.push_str("\n\n");
        }

        // Generate enum definitions
        for enum_def in schema.enums.values() {
            code.push_str(&self.generate_enum_class(enum_def, modules));
            code.push_str("\n\n");
        }

        // Close module namespaces
        if let Some(package) = &schema.package {
            let parts: Vec<&str> = package.split('.').collect();
            for i in (0..parts.len()).rev() {
                code.push_str(&format!("{}end\n", "  ".repeat(i)));
            }
        }

        Ok(code.trim_end().to_string() + "\n")
    }

    fn generate_services(&self, schema: &ProtobufSchema) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str("# frozen_string_literal: true\n");
        code.push_str("# DO NOT EDIT - Auto-generated by Spikard CLI\n");
        code.push_str("#\n");
        code.push_str("# This file was automatically generated from your Protobuf schema.\n");
        code.push_str("# Any manual changes will be overwritten on the next generation.\n\n");

        // Imports
        code.push_str("require 'google/protobuf'\n\n");

        // Package comment
        if let Some(package) = &schema.package {
            code.push_str(&format!("# Package: {}\n\n", package));
        }

        // Generate module namespace if package exists
        let modules = if let Some(package) = &schema.package {
            let parts: Vec<&str> = package.split('.').collect();
            for (i, part) in parts.iter().enumerate() {
                code.push_str(&format!("{}module {}\n", "  ".repeat(i), to_pascal_case(part)));
            }
            code.push('\n');
            parts.len()
        } else {
            0
        };

        // Generate service definitions
        if schema.services.is_empty() {
            code.push_str("# No services defined in this schema.\n");
        } else {
            for service in schema.services.values() {
                code.push_str(&self.generate_service_class(service, modules));
                code.push_str("\n\n");
            }
        }

        // Close module namespaces
        if let Some(package) = &schema.package {
            let parts: Vec<&str> = package.split('.').collect();
            for i in (0..parts.len()).rev() {
                code.push_str(&format!("{}end\n", "  ".repeat(i)));
            }
        }

        Ok(code.trim_end().to_string() + "\n")
    }
}

impl RubyProtobufGenerator {
    /// Generate a message class definition
    #[allow(dead_code)]
    fn generate_message_class(&self, message: &MessageDef, module_depth: usize) -> String {
        let indent = "  ".repeat(module_depth);
        let mut code = String::new();

        // Class definition
        code.push_str(&format!("{}class {}\n", indent, message.name));
        code.push_str(&format!("{}  include Google::Protobuf::MessageExts\n", indent));
        code.push_str(&format!(
            "{}  extend Google::Protobuf::MessageExts::ClassMethods\n",
            indent
        ));

        // Docstring
        if let Some(desc) = &message.description {
            code.push_str(&format!("{}\n{}  # {}\n", indent, indent, escape_string(desc, "ruby")));
        }

        if message.fields.is_empty() {
            code.push_str(&format!("{}}}\n", indent));
        } else {
            // Add field type hints as RBS comments
            for field in &message.fields {
                // Field comment if available
                if let Some(desc) = &field.description {
                    code.push_str(&format!("{}\n", indent));
                    code.push_str(&format!("{}  # {}\n", indent, desc));
                }

                let field_name = sanitize_identifier(&field.name, "ruby");
                let is_optional = field.label == FieldLabel::Optional;
                let is_repeated = field.label == FieldLabel::Repeated;

                let field_type = map_proto_type_to_language(&field.field_type, "ruby", is_optional, is_repeated);
                code.push_str(&format!(
                    "{}  # @!attribute [rw] {}\n{}  #   @return [{}]\n",
                    indent, field_name, indent, field_type
                ));
            }

            code.push_str(&format!("{}}}\n", indent));
        }

        code
    }

    /// Generate an enum class definition
    #[allow(dead_code)]
    fn generate_enum_class(
        &self,
        enum_def: &crate::codegen::protobuf::spec_parser::EnumDef,
        module_depth: usize,
    ) -> String {
        let indent = "  ".repeat(module_depth);
        let mut code = String::new();

        code.push_str(&format!("{}module {}\n", indent, enum_def.name));

        // Docstring
        if let Some(desc) = &enum_def.description {
            code.push_str(&format!("{}\n{}  # {}\n", indent, indent, escape_string(desc, "ruby")));
        }

        if enum_def.values.is_empty() {
            code.push_str(&format!("{}}}\n", indent));
        } else {
            for value in &enum_def.values {
                if let Some(desc) = &value.description {
                    code.push_str(&format!("{}  # {}\n", indent, desc));
                }
                code.push_str(&format!("{}  {} = {}\n", indent, value.name, value.number));
            }
            code.push_str(&format!("{}}}\n", indent));
        }

        code
    }

    /// Generate a service class definition (server interface)
    #[allow(dead_code)]
    fn generate_service_class(&self, service: &ServiceDef, module_depth: usize) -> String {
        let indent = "  ".repeat(module_depth);
        let mut code = String::new();

        // Service class
        code.push_str(&format!("{}class {}\n", indent, service.name));

        // Docstring
        if let Some(desc) = &service.description {
            code.push_str(&format!(
                "{}  # Server handler interface for {}. {}\n",
                indent,
                service.name,
                escape_string(desc, "ruby")
            ));
        } else {
            code.push_str(&format!(
                "{}  # Server handler interface for {}.\n",
                indent, service.name
            ));
        }

        if service.methods.is_empty() {
            code.push_str(&format!("{}}}\n", indent));
        } else {
            for method in &service.methods {
                code.push('\n');

                // Method docstring
                if let Some(desc) = &method.description {
                    code.push_str(&format!("{}  # {}\n", indent, desc));
                }

                // Build method signature
                let method_name = sanitize_identifier(&method.name, "ruby");
                let request_type = &method.input_type;
                let response_type = &method.output_type;

                // Add RBS type hint comment
                if method.output_streaming {
                    code.push_str(&format!(
                        "{}  # @param request [{}]\n{}  # @return [Enumerator<{}>]\n",
                        indent, request_type, indent, response_type
                    ));
                } else {
                    code.push_str(&format!(
                        "{}  # @param request [{}]\n{}  # @return [{}]\n",
                        indent, request_type, indent, response_type
                    ));
                }

                code.push_str(&format!(
                    "{}  def {}(request)\n{}    raise NotImplementedError\n{}  end\n",
                    indent, method_name, indent, indent
                ));
            }

            code.push_str(&format!("{}}}\n", indent));
        }

        code
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::protobuf::spec_parser::{FieldDef, FieldLabel, MessageDef, ProtoType};

    #[test]
    fn test_generate_simple_message() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![
                FieldDef {
                    name: "id".to_string(),
                    number: 1,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                },
                FieldDef {
                    name: "name".to_string(),
                    number: 2,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: Some("User's full name".to_string()),
                },
            ],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: Some("Represents a user".to_string()),
        };

        let generator = RubyProtobufGenerator;
        let code = generator.generate_message_class(&message, 0);

        assert!(code.contains("class User"));
        assert!(code.contains("include Google::Protobuf::MessageExts"));
        assert!(code.contains("Represents a user"));
        assert!(code.contains("@!attribute [rw] id"));
        assert!(code.contains("@return [String]"));
    }

    #[test]
    fn test_generate_message_with_optional_field() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![FieldDef {
                name: "email".to_string(),
                number: 3,
                field_type: ProtoType::String,
                label: FieldLabel::Optional,
                default_value: None,
                description: None,
            }],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = RubyProtobufGenerator;
        let code = generator.generate_message_class(&message, 0);

        assert!(code.contains("@return [String?]"));
    }

    #[test]
    fn test_generate_message_with_repeated_field() {
        let message = MessageDef {
            name: "User".to_string(),
            fields: vec![FieldDef {
                name: "tags".to_string(),
                number: 4,
                field_type: ProtoType::String,
                label: FieldLabel::Repeated,
                default_value: None,
                description: None,
            }],
            nested_messages: std::collections::HashMap::new(),
            nested_enums: std::collections::HashMap::new(),
            description: None,
        };

        let generator = RubyProtobufGenerator;
        let code = generator.generate_message_class(&message, 0);

        assert!(code.contains("@return [Array<String>]"));
    }

    #[test]
    fn test_generate_messages_with_package() {
        let mut schema = ProtobufSchema {
            package: Some("example.user".to_string()),
            messages: std::collections::HashMap::new(),
            services: std::collections::HashMap::new(),
            enums: std::collections::HashMap::new(),
            imports: vec![],
            syntax: "proto3".to_string(),
            description: None,
        };

        schema.messages.insert(
            "User".to_string(),
            MessageDef {
                name: "User".to_string(),
                fields: vec![FieldDef {
                    name: "id".to_string(),
                    number: 1,
                    field_type: ProtoType::String,
                    label: FieldLabel::None,
                    default_value: None,
                    description: None,
                }],
                nested_messages: std::collections::HashMap::new(),
                nested_enums: std::collections::HashMap::new(),
                description: None,
            },
        );

        let generator = RubyProtobufGenerator;
        let code = generator
            .generate_messages(&schema)
            .expect("Failed to generate messages");

        assert!(code.contains("module Example"));
        assert!(code.contains("module User"));
        assert!(code.contains("class User"));
        assert!(code.contains("Package: example.user"));
    }

    #[test]
    fn test_generate_service_class() {
        use crate::codegen::protobuf::spec_parser::{MethodDef, ServiceDef};

        let service = ServiceDef {
            name: "UserService".to_string(),
            methods: vec![MethodDef {
                name: "get_user".to_string(),
                input_type: "GetUserRequest".to_string(),
                output_type: "User".to_string(),
                input_streaming: false,
                output_streaming: false,
                description: None,
            }],
            description: None,
        };

        let generator = RubyProtobufGenerator;
        let code = generator.generate_service_class(&service, 0);

        assert!(code.contains("class UserService"));
        assert!(code.contains("def get_user(request)"));
        assert!(code.contains("@param request [GetUserRequest]"));
        assert!(code.contains("@return [User]"));
        assert!(code.contains("raise NotImplementedError"));
    }

    #[test]
    fn test_to_pascal_case_integration() {
        use crate::codegen::protobuf::generators::base::to_pascal_case;
        assert_eq!(to_pascal_case("example"), "Example");
        assert_eq!(to_pascal_case("user_service"), "UserService");
        assert_eq!(to_pascal_case("api_v1"), "ApiV1");
    }

    #[test]
    fn test_generate_enum_class() {
        use crate::codegen::protobuf::spec_parser::{EnumDef, EnumValue};

        let enum_def = EnumDef {
            name: "Status".to_string(),
            values: vec![
                EnumValue {
                    name: "UNKNOWN".to_string(),
                    number: 0,
                    description: None,
                },
                EnumValue {
                    name: "ACTIVE".to_string(),
                    number: 1,
                    description: Some("User is active".to_string()),
                },
            ],
            description: Some("User status enum".to_string()),
        };

        let generator = RubyProtobufGenerator;
        let code = generator.generate_enum_class(&enum_def, 0);

        assert!(code.contains("module Status"));
        assert!(code.contains("User status enum"));
        assert!(code.contains("UNKNOWN = 0"));
        assert!(code.contains("ACTIVE = 1"));
        assert!(code.contains("User is active"));
    }

    #[test]
    fn test_generate_service_with_streaming() {
        use crate::codegen::protobuf::spec_parser::{MethodDef, ServiceDef};

        let service = ServiceDef {
            name: "UserService".to_string(),
            methods: vec![MethodDef {
                name: "stream_users".to_string(),
                input_type: "StreamRequest".to_string(),
                output_type: "User".to_string(),
                input_streaming: false,
                output_streaming: true,
                description: Some("Stream all users".to_string()),
            }],
            description: None,
        };

        let generator = RubyProtobufGenerator;
        let code = generator.generate_service_class(&service, 0);

        assert!(code.contains("def stream_users(request)"));
        assert!(code.contains("@return [Enumerator<User>]"));
        assert!(code.contains("Stream all users"));
    }
}
