//! Python AsyncAPI code generation.

use anyhow::{Result, bail};

use super::base::sanitize_identifier;
use super::{AsyncApiGenerator, ChannelInfo, Message};

/// Python AsyncAPI code generator
pub struct PythonAsyncApiGenerator;

impl AsyncApiGenerator for PythonAsyncApiGenerator {
    fn generate_test_app(&self, channels: &[ChannelInfo], _messages: &[Message], protocol: &str) -> Result<String> {
        let mut code = String::new();

        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("\"\"\"Test application generated from AsyncAPI specification\"\"\"\n\n");
        code.push_str("import asyncio\n");
        code.push_str("import json\n");
        code.push_str("from pathlib import Path\n");
        code.push_str("from typing import Any, Dict\n\n");

        match protocol {
            "websocket" => {
                code.push_str("import websockets\n");
                code.push_str("from websockets.client import WebSocketClientProtocol\n\n");
            }
            "sse" => {
                code.push_str("import aiohttp\n\n");
            }
            _ => {
                return Err(anyhow::anyhow!(
                    "Unsupported protocol for Python test app: {}",
                    protocol
                ));
            }
        }

        code.push_str("# Load test fixtures\n");
        code.push_str("FIXTURES_DIR = Path(__file__).parent.parent / \"testing_data\" / \"");
        code.push_str(match protocol {
            "websocket" => "websockets",
            "sse" => "sse",
            _ => "asyncapi",
        });
        code.push_str("\"\n\n");

        code.push_str("def load_fixture(name: str) -> Dict[str, Any]:\n");
        code.push_str("    \"\"\"Load a test fixture by name\"\"\"\n");
        code.push_str("    fixture_path = FIXTURES_DIR / f\"{name}.json\"\n");
        code.push_str("    if not fixture_path.exists():\n");
        code.push_str("        raise FileNotFoundError(f\"Fixture not found: {fixture_path}\")\n");
        code.push_str("    with open(fixture_path) as f:\n");
        code.push_str("        return json.load(f)\n\n\n");

        if protocol == "websocket" {
            code.push_str("async def handle_websocket(websocket: WebSocketClientProtocol) -> None:\n");
            code.push_str("    \"\"\"Handle WebSocket connection\"\"\"\n");
            code.push_str("    async for message in websocket:\n");
            code.push_str("        data = json.loads(message)\n");
            code.push_str("        print(f\"Received: {data}\")\n\n\n");
        }

        code.push_str("async def main() -> None:\n");
        code.push_str("    \"\"\"Main entry point\"\"\"\n");
        code.push_str("    # Default URI - override with environment variable\n");
        code.push_str("    import os\n");
        code.push_str("    uri = os.getenv('URI', 'ws://localhost:8000");

        if let Some(first_channel) = channels.first() {
            code.push_str(&first_channel.path);
        }

        code.push_str("')\n");
        code.push_str("    print(f\"Connecting to {uri}...\")\n");

        code.push_str("\n\nif __name__ == \"__main__\":\n");
        code.push_str("    asyncio.run(main())\n");

        Ok(code)
    }

    fn generate_handler_app(&self, channels: &[ChannelInfo], _messages: &[Message], protocol: &str) -> Result<String> {
        if channels.is_empty() {
            bail!("AsyncAPI spec does not define any channels");
        }

        match protocol {
            "websocket" | "sse" => {}
            other => {
                bail!("Protocol {} is not supported for Python handler generation", other);
            }
        }

        let mut code = String::new();
        code.push_str("#!/usr/bin/env python3\n");
        code.push_str("\"\"\"AsyncAPI handler skeleton generated by Spikard.\"\"\"\n\n");
        code.push_str("from typing import Any\n");
        if protocol == "sse" {
            code.push_str("import asyncio\n");
        }
        match protocol {
            "websocket" => code.push_str("from spikard import Spikard, websocket\n"),
            "sse" => code.push_str("from spikard import Spikard, sse\n"),
            _ => {}
        }
        code.push_str("\napp = Spikard()\n\n");

        for channel in channels {
            let handler_name = format!("{}_handler", sanitize_identifier(&channel.name));
            let message_description = if channel.messages.is_empty() {
                "messages".to_string()
            } else {
                channel.messages.join(", ")
            };

            match protocol {
                "websocket" => {
                    code.push_str(&format!("@websocket(\"{}\")\n", channel.path));
                    code.push_str(&format!(
                        "async def {}(message: dict[str, Any]) -> dict[str, Any]:\n",
                        handler_name
                    ));
                    code.push_str(&format!(
                        "    \"\"\"Handles {} on {}.\"\"\"\n",
                        message_description, channel.path
                    ));
                    code.push_str("    raise NotImplementedError(\"Implement WebSocket message handling logic\")\n\n");
                }
                "sse" => {
                    code.push_str(&format!("@sse(\"{}\")\n", channel.path));
                    code.push_str(&format!("async def {}() -> Any:\n", handler_name));
                    code.push_str(&format!(
                        "    \"\"\"Streams events for {} on {}.\"\"\"\n",
                        message_description, channel.path
                    ));
                    code.push_str("    yield {\"message\": \"replace with real event\"}\n\n");
                }
                _ => {}
            }
        }

        code.push_str("if __name__ == \"__main__\":\n");
        code.push_str("    app.run()\n");

        Ok(code)
    }

    fn language_name(&self) -> &'static str {
        "python"
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_python_generator_test_app_websocket() {
        let generator = PythonAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator.generate_test_app(&channels, &messages, "websocket").unwrap();
        assert!(code.contains("import websockets"));
        assert!(code.contains("#!/usr/bin/env python3"));
        assert!(code.contains("/chat"));
    }

    #[test]
    fn test_python_generator_handler_app() {
        let generator = PythonAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator
            .generate_handler_app(&channels, &messages, "websocket")
            .unwrap();
        assert!(code.contains("@websocket"));
        assert!(code.contains("async def"));
    }

    #[test]
    fn test_sanitize_identifier() {
        assert_eq!(sanitize_identifier("hello-world"), "hello_world");
        assert_eq!(sanitize_identifier("123start"), "_123start");
        assert_eq!(sanitize_identifier("__double__"), "double");
        assert_eq!(sanitize_identifier("CAPS"), "caps");
    }
}
