//! PHP AsyncAPI code generation.

use anyhow::{bail, Result};

use super::{AsyncApiGenerator, ChannelInfo, Message};

/// PHP AsyncAPI code generator
pub struct PhpAsyncApiGenerator;

impl AsyncApiGenerator for PhpAsyncApiGenerator {
    fn generate_test_app(
        &self,
        channels: &[ChannelInfo],
        _messages: &[Message],
        protocol: &str,
    ) -> Result<String> {
        let mut code = String::new();

        // PHP header with strict types
        code.push_str("<?php\n");
        code.push_str("declare(strict_types=1);\n\n");
        code.push_str("/**\n");
        code.push_str(" * Test application generated from AsyncAPI specification\n");
        code.push_str(&format!(" * Protocol: {}\n", protocol));
        code.push_str(" * Generated by Spikard CLI\n");
        code.push_str(" */\n\n");

        // Fixture loading helper
        code.push_str("/**\n");
        code.push_str(" * Load a JSON fixture file\n");
        code.push_str(" * @param string $name Fixture name (without .json extension)\n");
        code.push_str(" * @return array<string, mixed>\n");
        code.push_str(" */\n");
        code.push_str("function loadFixture(string $name): array\n");
        code.push_str("{\n");
        code.push_str("    $path = __DIR__ . \"/../fixtures/{$name}.json\";\n");
        code.push_str("    if (!file_exists($path)) {\n");
        code.push_str("        throw new RuntimeException(\"Fixture not found: {$path}\");\n");
        code.push_str("    }\n");
        code.push_str("    $content = file_get_contents($path);\n");
        code.push_str("    if ($content === false) {\n");
        code.push_str("        throw new RuntimeException(\"Failed to read fixture: {$path}\");\n");
        code.push_str("    }\n");
        code.push_str("    /** @var array<string, mixed> $data */\n");
        code.push_str("    $data = json_decode($content, true, 512, JSON_THROW_ON_ERROR);\n");
        code.push_str("    return $data;\n");
        code.push_str("}\n\n");

        // Get base URI from environment
        code.push_str("$baseUri = getenv('URI') ?: 'http://localhost:8000';\n\n");

        // Generate test code based on protocol
        match protocol {
            "websocket" | "ws" => {
                code.push_str("// WebSocket test client\n");
                code.push_str("echo \"Testing WebSocket endpoints...\\n\";\n\n");

                for channel in channels {
                    let fixture_name = sanitize_identifier(&channel.name);
                    code.push_str(&format!("// Test channel: {}\n", channel.path));
                    code.push_str(&format!("$wsUri = str_replace('http://', 'ws://', $baseUri) . '{}';\n", channel.path));
                    code.push_str("echo \"Connecting to {$wsUri}...\\n\";\n\n");

                    code.push_str("// TODO: Add WebSocket client library (e.g., ratchet/pawl)\n");
                    code.push_str("// \\Ratchet\\Client\\connect($wsUri)->then(\n");
                    code.push_str("//     function($conn) {\n");
                    code.push_str(&format!("//         $fixture = loadFixture('{}');\n", fixture_name));
                    code.push_str("//         $conn->send(json_encode($fixture, JSON_THROW_ON_ERROR));\n");
                    code.push_str("//         $conn->on('message', function($msg) use ($conn) {\n");
                    code.push_str("//             echo \"Received: {$msg}\\n\";\n");
                    code.push_str("//             $conn->close();\n");
                    code.push_str("//         });\n");
                    code.push_str("//     },\n");
                    code.push_str("//     function($e) {\n");
                    code.push_str("//         echo \"Could not connect: {$e->getMessage()}\\n\";\n");
                    code.push_str("//     }\n");
                    code.push_str("// );\n\n");
                }

                code.push_str("echo \"WebSocket tests complete\\n\";\n");
            }
            "sse" => {
                code.push_str("// SSE test client\n");
                code.push_str("echo \"Testing SSE endpoints...\\n\";\n\n");

                for channel in channels {
                    let fixture_name = sanitize_identifier(&channel.name);
                    code.push_str(&format!("// Test channel: {}\n", channel.path));
                    code.push_str(&format!("$sseUri = $baseUri . '{}';\n", channel.path));
                    code.push_str("echo \"Connecting to {$sseUri}...\\n\";\n\n");

                    code.push_str("// Open SSE stream\n");
                    code.push_str("$context = stream_context_create([\n");
                    code.push_str("    'http' => [\n");
                    code.push_str("        'method' => 'GET',\n");
                    code.push_str("        'header' => 'Accept: text/event-stream',\n");
                    code.push_str("    ],\n");
                    code.push_str("]);\n");
                    code.push_str("$stream = fopen($sseUri, 'r', false, $context);\n");
                    code.push_str("if ($stream === false) {\n");
                    code.push_str("    throw new RuntimeException(\"Failed to open SSE stream\");\n");
                    code.push_str("}\n\n");

                    code.push_str("// Read first 5 events\n");
                    code.push_str("$events = [];\n");
                    code.push_str("while (count($events) < 5 && !feof($stream)) {\n");
                    code.push_str("    $line = fgets($stream);\n");
                    code.push_str("    if ($line !== false && str_starts_with($line, 'data:')) {\n");
                    code.push_str("        $data = trim(substr($line, 5));\n");
                    code.push_str("        $events[] = json_decode($data, true, 512, JSON_THROW_ON_ERROR);\n");
                    code.push_str("        echo \"Received event: {$data}\\n\";\n");
                    code.push_str("    }\n");
                    code.push_str("}\n");
                    code.push_str("fclose($stream);\n\n");

                    code.push_str(&format!("// Load expected fixture for validation\n"));
                    code.push_str(&format!("$expectedFixture = loadFixture('{}');\n", fixture_name));
                    code.push_str("echo \"Collected \" . count($events) . \" events\\n\\n\";\n");
                }

                code.push_str("echo \"SSE tests complete\\n\";\n");
            }
            _ => {
                code.push_str(&format!("// Unsupported protocol: {}\n", protocol));
                code.push_str("throw new RuntimeException('Protocol not implemented');\n");
            }
        }

        Ok(code)
    }

    fn generate_handler_app(
        &self,
        channels: &[ChannelInfo],
        _messages: &[Message],
        protocol: &str,
    ) -> Result<String> {
        if channels.is_empty() {
            bail!("AsyncAPI spec does not define any channels");
        }

        match protocol {
            "websocket" | "ws" | "sse" => {}
            other => bail!("Protocol {} is not supported for PHP handler generation", other),
        }

        let mut code = String::new();

        // PHP header with strict types
        code.push_str("<?php\n");
        code.push_str("declare(strict_types=1);\n\n");
        code.push_str("/**\n");
        code.push_str(" * AsyncAPI handler skeleton generated by Spikard CLI\n");
        code.push_str(&format!(" * Protocol: {}\n", protocol));
        code.push_str(" * Generated handler classes for each channel\n");
        code.push_str(" */\n\n");

        // Generate handler classes based on protocol
        match protocol {
            "websocket" | "ws" => {
                code.push_str("use Spikard\\WebSocketHandlerInterface;\n\n");

                // Generate individual handler classes for each channel
                for channel in channels {
                    let class_name = camel_identifier(&channel.name);
                    let message_description = if channel.messages.is_empty() {
                        "messages".to_string()
                    } else {
                        channel.messages.join(", ")
                    };

                    code.push_str(&format!("/**\n * WebSocket handler for {}\n", channel.path));
                    code.push_str(&format!(" * Handles: {}\n */\n", message_description));
                    code.push_str(&format!("final class {}Handler implements WebSocketHandlerInterface\n", class_name));
                    code.push_str("{\n");

                    // onConnect method
                    code.push_str("    /**\n");
                    code.push_str("     * Called when WebSocket connection is established\n");
                    code.push_str("     */\n");
                    code.push_str("    public function onConnect(): void\n");
                    code.push_str("    {\n");
                    code.push_str("        // TODO: Initialize connection state\n");
                    code.push_str("        error_log(\"WebSocket connection established\");\n");
                    code.push_str("    }\n\n");

                    // onMessage method
                    code.push_str("    /**\n");
                    code.push_str("     * Handle incoming WebSocket message\n");
                    code.push_str("     * @param array<string, mixed> $message\n");
                    code.push_str("     * @return array<string, mixed>\n");
                    code.push_str("     */\n");
                    code.push_str("    public function onMessage(array $message): array\n");
                    code.push_str("    {\n");
                    code.push_str(&format!("        // TODO: Handle {} received on {}\n", message_description, channel.path));
                    code.push_str("        // Example: Echo back with timestamp\n");
                    code.push_str("        return [\n");
                    code.push_str("            'echo' => $message,\n");
                    code.push_str("            'timestamp' => time(),\n");
                    code.push_str("            'channel' => '{}',\n".replace("{}", &channel.path));
                    code.push_str("        ];\n");
                    code.push_str("    }\n\n");

                    // onClose method
                    code.push_str("    /**\n");
                    code.push_str("     * Called when WebSocket connection closes\n");
                    code.push_str("     */\n");
                    code.push_str("    public function onClose(): void\n");
                    code.push_str("    {\n");
                    code.push_str("        // TODO: Clean up connection resources\n");
                    code.push_str("        error_log(\"WebSocket connection closed\");\n");
                    code.push_str("    }\n");
                    code.push_str("}\n\n");
                }
            }
            "sse" => {
                code.push_str("use Spikard\\SseEventProducerInterface;\n\n");

                // Generate individual producer classes for each channel
                for channel in channels {
                    let class_name = camel_identifier(&channel.name);
                    let message_description = if channel.messages.is_empty() {
                        "events".to_string()
                    } else {
                        channel.messages.join(", ")
                    };

                    code.push_str(&format!("/**\n * SSE event producer for {}\n", channel.path));
                    code.push_str(&format!(" * Produces: {}\n */\n", message_description));
                    code.push_str(&format!("final class {}Producer implements SseEventProducerInterface\n", class_name));
                    code.push_str("{\n");

                    // produce method
                    code.push_str("    /**\n");
                    code.push_str("     * Produce SSE events\n");
                    code.push_str("     * @return Generator<array{event: string, data: mixed}>\n");
                    code.push_str("     */\n");
                    code.push_str("    public function produce(): Generator\n");
                    code.push_str("    {\n");
                    code.push_str(&format!("        // TODO: Implement event generation logic for {}\n", channel.path));
                    code.push_str("        // Example: Generate 10 events with 1 second interval\n");
                    code.push_str("        for ($i = 0; $i < 10; $i++) {\n");
                    code.push_str("            yield [\n");
                    code.push_str("                'event' => 'message',\n");
                    code.push_str("                'data' => [\n");
                    code.push_str("                    'sequence' => $i,\n");
                    code.push_str("                    'timestamp' => time(),\n");
                    code.push_str("                    'channel' => '{}',\n".replace("{}", &channel.path));
                    code.push_str(&format!("                    'type' => '{}',\n", message_description));
                    code.push_str("                ],\n");
                    code.push_str("            ];\n");
                    code.push_str("            sleep(1);\n");
                    code.push_str("        }\n");
                    code.push_str("    }\n");
                    code.push_str("}\n\n");
                }
            }
            _ => {}
        }

        // Generate registration helper class
        code.push_str("/**\n");
        code.push_str(" * Helper class to register all AsyncAPI handlers with the application\n");
        code.push_str(" */\n");
        code.push_str("final class AsyncApiHandlers\n{\n");
        code.push_str("    /**\n");
        code.push_str("     * Register all AsyncAPI handlers with the Spikard application\n");
        code.push_str("     * @param object $app Spikard\\App instance\n");
        code.push_str("     */\n");
        code.push_str("    public static function register(object $app): void\n");
        code.push_str("    {\n");

        // Generate route registration code
        for channel in channels {
            let class_name = camel_identifier(&channel.name);
            match protocol {
                "websocket" | "ws" => {
                    code.push_str(&format!(
                        "        $app->websocket('{}', new {}Handler());\n",
                        channel.path, class_name
                    ));
                }
                "sse" => {
                    code.push_str(&format!(
                        "        $app->sse('{}', new {}Producer());\n",
                        channel.path, class_name
                    ));
                }
                _ => {}
            }
        }

        code.push_str("    }\n");
        code.push_str("}\n\n");

        // Entry point
        code.push_str("// Application entry point\n");
        code.push_str("if (PHP_SAPI === 'cli' && __FILE__ === realpath($_SERVER['SCRIPT_FILENAME'])) {\n");
        code.push_str("    // Uncomment to run the server:\n");
        code.push_str("    // $app = new Spikard\\App();\n");
        code.push_str("    // AsyncApiHandlers::register($app);\n");
        code.push_str("    // $app->listen(3000);\n");
        code.push_str("    // echo \"Server listening on http://localhost:3000\\n\";\n");
        code.push_str("}\n");

        Ok(code)
    }

    fn language_name(&self) -> &'static str {
        "php"
    }
}

fn camel_identifier(name: &str) -> String {
    let base = sanitize_identifier(name);
    let mut result = String::new();
    for part in base.split('_').filter(|segment| !segment.is_empty()) {
        let mut chars = part.chars();
        if let Some(first) = chars.next() {
            result.push(first.to_ascii_uppercase());
            result.push_str(chars.as_str());
        }
    }
    if result.is_empty() {
        "Handler".to_string()
    } else {
        result
    }
}

fn sanitize_identifier(name: &str) -> String {
    let mut ident: String = name
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect();

    while ident.contains("__") {
        ident = ident.replace("__", "_");
    }

    ident = ident.trim_matches('_').to_string();

    if ident.is_empty() {
        return "handler".to_string();
    }

    if ident.chars().next().unwrap().is_ascii_digit() {
        ident.insert(0, '_');
    }

    ident
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_php_generator_test_app() {
        let generator = PhpAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator.generate_test_app(&channels, &messages, "websocket").unwrap();
        assert!(code.contains("<?php"));
        assert!(code.contains("getenv"));
        assert!(code.contains("/chat"));
    }

    #[test]
    fn test_php_generator_handler_app() {
        let generator = PhpAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator.generate_handler_app(&channels, &messages, "websocket").unwrap();
        assert!(code.contains("AsyncApiHandlers"));
        assert!(code.contains("public static function"));
    }
}
