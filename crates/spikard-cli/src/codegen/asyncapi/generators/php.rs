//! PHP `AsyncAPI` code generation.

use anyhow::{Result, bail};

use super::base::sanitize_identifier;
use super::{AsyncApiGenerator, ChannelInfo};

/// PHP `AsyncAPI` code generator
pub struct PhpAsyncApiGenerator;

impl AsyncApiGenerator for PhpAsyncApiGenerator {
    fn generate_test_app(&self, channels: &[ChannelInfo], protocol: &str) -> Result<String> {
        let mut code = String::new();

        code.push_str("<?php\n");
        code.push_str("declare(strict_types=1);\n\n");
        code.push_str("/**\n");
        code.push_str(" * Test application generated from AsyncAPI specification\n");
        code.push_str(&format!(" * Protocol: {protocol}\n"));
        code.push_str(" * Generated by Spikard CLI\n");
        code.push_str(" */\n\n");

        code.push_str("/**\n");
        code.push_str(" * Load a JSON fixture file\n");
        code.push_str(" * @param string $name Fixture name (without .json extension)\n");
        code.push_str(" * @return array<string, mixed>\n");
        code.push_str(" */\n");
        code.push_str("function loadFixture(string $name): array\n");
        code.push_str("{\n");
        code.push_str("    $path = __DIR__ . \"/../fixtures/{$name}.json\";\n");
        code.push_str("    if (!file_exists($path)) {\n");
        code.push_str("        throw new RuntimeException(\"Fixture not found: {$path}\");\n");
        code.push_str("    }\n");
        code.push_str("    $content = file_get_contents($path);\n");
        code.push_str("    if ($content === false) {\n");
        code.push_str("        throw new RuntimeException(\"Failed to read fixture: {$path}\");\n");
        code.push_str("    }\n");
        code.push_str("    /** @var array<string, mixed> $data */\n");
        code.push_str("    $data = json_decode($content, true, 512, JSON_THROW_ON_ERROR);\n");
        code.push_str("    return $data;\n");
        code.push_str("}\n\n");

        code.push_str("$baseUri = getenv('URI') ?: 'http://localhost:8000';\n\n");

        match protocol {
            "websocket" | "ws" => {
                code.push_str("// WebSocket test client\n");
                code.push_str("echo \"Testing WebSocket endpoints...\\n\";\n\n");

                for channel in channels {
                    let fixture_name = sanitize_identifier(&channel.name);
                    code.push_str(&format!("// Test channel: {}\n", channel.path));
                    code.push_str(&format!(
                        "$wsUri = str_replace('http://', 'ws://', $baseUri) . '{}';\n",
                        channel.path
                    ));
                    code.push_str("echo \"Connecting to {$wsUri}...\\n\";\n\n");

                    code.push_str("// TODO: Add WebSocket client library (e.g., ratchet/pawl)\n");
                    code.push_str("// \\Ratchet\\Client\\connect($wsUri)->then(\n");
                    code.push_str("//     function($conn) {\n");
                    code.push_str(&format!("//         $fixture = loadFixture('{fixture_name}');\n"));
                    code.push_str("//         $conn->send(json_encode($fixture, JSON_THROW_ON_ERROR));\n");
                    code.push_str("//         $conn->on('message', function($msg) use ($conn) {\n");
                    code.push_str("//             echo \"Received: {$msg}\\n\";\n");
                    code.push_str("//             $conn->close();\n");
                    code.push_str("//         });\n");
                    code.push_str("//     },\n");
                    code.push_str("//     function($e) {\n");
                    code.push_str("//         echo \"Could not connect: {$e->getMessage()}\\n\";\n");
                    code.push_str("//     }\n");
                    code.push_str("// );\n\n");
                }

                code.push_str("echo \"WebSocket tests complete\\n\";\n");
            }
            "sse" => {
                code.push_str("// SSE test client\n");
                code.push_str("echo \"Testing SSE endpoints...\\n\";\n\n");

                for channel in channels {
                    let fixture_name = sanitize_identifier(&channel.name);
                    code.push_str(&format!("// Test channel: {}\n", channel.path));
                    code.push_str(&format!("$sseUri = $baseUri . '{}';\n", channel.path));
                    code.push_str("echo \"Connecting to {$sseUri}...\\n\";\n\n");

                    code.push_str("// Open SSE stream\n");
                    code.push_str("$context = stream_context_create([\n");
                    code.push_str("    'http' => [\n");
                    code.push_str("        'method' => 'GET',\n");
                    code.push_str("        'header' => 'Accept: text/event-stream',\n");
                    code.push_str("    ],\n");
                    code.push_str("]);\n");
                    code.push_str("$stream = fopen($sseUri, 'r', false, $context);\n");
                    code.push_str("if ($stream === false) {\n");
                    code.push_str("    throw new RuntimeException(\"Failed to open SSE stream\");\n");
                    code.push_str("}\n\n");

                    code.push_str("// Read first 5 events\n");
                    code.push_str("$events = [];\n");
                    code.push_str("while (count($events) < 5 && !feof($stream)) {\n");
                    code.push_str("    $line = fgets($stream);\n");
                    code.push_str("    if ($line !== false && str_starts_with($line, 'data:')) {\n");
                    code.push_str("        $data = trim(substr($line, 5));\n");
                    code.push_str("        $events[] = json_decode($data, true, 512, JSON_THROW_ON_ERROR);\n");
                    code.push_str("        echo \"Received event: {$data}\\n\";\n");
                    code.push_str("    }\n");
                    code.push_str("}\n");
                    code.push_str("fclose($stream);\n\n");

                    code.push_str("// Load expected fixture for validation\n");
                    code.push_str(&format!("$expectedFixture = loadFixture('{fixture_name}');\n"));
                    code.push_str("echo \"Collected \" . count($events) . \" events\\n\\n\";\n");
                }

                code.push_str("echo \"SSE tests complete\\n\";\n");
            }
            _ => {
                code.push_str(&format!("// Unsupported protocol: {protocol}\n"));
                code.push_str("throw new RuntimeException('Protocol not implemented');\n");
            }
        }

        Ok(code)
    }

    fn generate_handler_app(&self, channels: &[ChannelInfo], protocol: &str) -> Result<String> {
        if channels.is_empty() {
            bail!("AsyncAPI spec does not define any channels");
        }

        match protocol {
            "websocket" | "ws" | "sse" => {}
            other => bail!("Protocol {other} is not supported for PHP handler generation"),
        }

        let mut code = String::new();

        code.push_str("<?php\n");
        code.push_str("declare(strict_types=1);\n\n");
        code.push_str("/**\n");
        code.push_str(" * AsyncAPI handler skeleton generated by Spikard CLI\n");
        code.push_str(&format!(" * Protocol: {protocol}\n"));
        code.push_str(" * Generated handler classes for each channel\n");
        code.push_str(" */\n\n");

        match protocol {
            "websocket" | "ws" => {
                code.push_str("use Spikard\\WebSocketHandlerInterface;\n\n");

                for channel in channels {
                    let class_name = camel_identifier(&channel.name);
                    let message_description = if channel.messages.is_empty() {
                        "messages".to_string()
                    } else {
                        channel.messages.join(", ")
                    };

                    code.push_str(&format!("/**\n * WebSocket handler for {}\n", channel.path));
                    code.push_str(&format!(" * Handles: {message_description}\n */\n"));
                    code.push_str(&format!(
                        "final class {class_name}Handler implements WebSocketHandlerInterface\n"
                    ));
                    code.push_str("{\n");

                    code.push_str("    /**\n");
                    code.push_str("     * Called when WebSocket connection is established\n");
                    code.push_str("     */\n");
                    code.push_str("    public function onConnect(): void\n");
                    code.push_str("    {\n");
                    code.push_str("        // TODO: Initialize connection state\n");
                    code.push_str("        error_log(\"WebSocket connection established\");\n");
                    code.push_str("    }\n\n");

                    code.push_str("    /**\n");
                    code.push_str("     * Handle incoming WebSocket message\n");
                    code.push_str("     * @param array<string, mixed> $message\n");
                    code.push_str("     * @return array<string, mixed>\n");
                    code.push_str("     */\n");
                    code.push_str("    public function onMessage(array $message): array\n");
                    code.push_str("    {\n");
                    code.push_str(&format!(
                        "        // TODO: Handle {} received on {}\n",
                        message_description, channel.path
                    ));
                    code.push_str("        // Example: Echo back with timestamp\n");
                    code.push_str("        return [\n");
                    code.push_str("            'echo' => $message,\n");
                    code.push_str("            'timestamp' => time(),\n");
                    code.push_str(&format!("            'channel' => '{}',\n", &channel.path));
                    code.push_str("        ];\n");
                    code.push_str("    }\n\n");

                    code.push_str("    /**\n");
                    code.push_str("     * Called when WebSocket connection closes\n");
                    code.push_str("     */\n");
                    code.push_str("    public function onClose(): void\n");
                    code.push_str("    {\n");
                    code.push_str("        // TODO: Clean up connection resources\n");
                    code.push_str("        error_log(\"WebSocket connection closed\");\n");
                    code.push_str("    }\n");
                    code.push_str("}\n\n");
                }
            }
            "sse" => {
                code.push_str("use Spikard\\SseEventProducerInterface;\n\n");

                for channel in channels {
                    let class_name = camel_identifier(&channel.name);
                    let message_description = if channel.messages.is_empty() {
                        "events".to_string()
                    } else {
                        channel.messages.join(", ")
                    };

                    code.push_str(&format!("/**\n * SSE event producer for {}\n", channel.path));
                    code.push_str(&format!(" * Produces: {message_description}\n */\n"));
                    code.push_str(&format!(
                        "final class {class_name}Producer implements SseEventProducerInterface\n"
                    ));
                    code.push_str("{\n");

                    code.push_str("    /**\n");
                    code.push_str("     * Produce SSE events\n");
                    code.push_str("     * @return Generator<array{event: string, data: mixed}>\n");
                    code.push_str("     */\n");
                    code.push_str("    public function produce(): Generator\n");
                    code.push_str("    {\n");
                    code.push_str(&format!(
                        "        // TODO: Implement event generation logic for {}\n",
                        channel.path
                    ));
                    code.push_str("        // Example: Generate 10 events with 1 second interval\n");
                    code.push_str("        for ($i = 0; $i < 10; $i++) {\n");
                    code.push_str("            yield [\n");
                    code.push_str("                'event' => 'message',\n");
                    code.push_str("                'data' => [\n");
                    code.push_str("                    'sequence' => $i,\n");
                    code.push_str("                    'timestamp' => time(),\n");
                    code.push_str(&format!("                    'channel' => '{}',\n", &channel.path));
                    code.push_str(&format!("                    'type' => '{message_description}',\n"));
                    code.push_str("                ],\n");
                    code.push_str("            ];\n");
                    code.push_str("            sleep(1);\n");
                    code.push_str("        }\n");
                    code.push_str("    }\n");
                    code.push_str("}\n\n");
                }
            }
            _ => {}
        }

        code.push_str("/**\n");
        code.push_str(" * Helper class to register all AsyncAPI handlers with the application\n");
        code.push_str(" */\n");
        code.push_str("final class AsyncApiHandlers\n{\n");
        code.push_str("    /**\n");
        code.push_str("     * Register all AsyncAPI handlers with the Spikard application\n");
        code.push_str("     * @param object $app Spikard\\App instance\n");
        code.push_str("     */\n");
        code.push_str("    public static function register(object $app): void\n");
        code.push_str("    {\n");

        for channel in channels {
            let class_name = camel_identifier(&channel.name);
            match protocol {
                "websocket" | "ws" => {
                    code.push_str(&format!(
                        "        $app->websocket('{}', new {}Handler());\n",
                        channel.path, class_name
                    ));
                }
                "sse" => {
                    code.push_str(&format!(
                        "        $app->sse('{}', new {}Producer());\n",
                        channel.path, class_name
                    ));
                }
                _ => {}
            }
        }

        code.push_str("    }\n");
        code.push_str("}\n\n");

        code.push_str("// Application entry point\n");
        code.push_str("if (PHP_SAPI === 'cli' && __FILE__ === realpath($_SERVER['SCRIPT_FILENAME'])) {\n");
        code.push_str("    // Uncomment to run the server:\n");
        code.push_str("    // $app = new Spikard\\App();\n");
        code.push_str("    // AsyncApiHandlers::register($app);\n");
        code.push_str("    // $app->listen(3000);\n");
        code.push_str("    // echo \"Server listening on http://localhost:3000\\n\";\n");
        code.push_str("}\n");

        Ok(code)
    }
}

fn camel_identifier(name: &str) -> String {
    let base = sanitize_identifier(name);
    let mut result = String::new();
    for part in base.split('_').filter(|segment| !segment.is_empty()) {
        let mut chars = part.chars();
        if let Some(first) = chars.next() {
            result.push(first.to_ascii_uppercase());
            result.push_str(chars.as_str());
        }
    }
    if result.is_empty() {
        "Handler".to_string()
    } else {
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_php_generator_test_app() {
        let generator = PhpAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];

        let code = generator.generate_test_app(&channels, "websocket").unwrap();
        assert!(code.contains("<?php"));
        assert!(code.contains("getenv"));
        assert!(code.contains("/chat"));
    }

    #[test]
    fn test_php_generator_handler_app() {
        let generator = PhpAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];

        let code = generator.generate_handler_app(&channels, "websocket").unwrap();
        assert!(code.contains("AsyncApiHandlers"));
        assert!(code.contains("public static function"));
    }
}
