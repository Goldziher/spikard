//! PHP AsyncAPI code generation.

use anyhow::{bail, Result};

use super::{AsyncApiGenerator, ChannelInfo, Message};

/// PHP AsyncAPI code generator
pub struct PhpAsyncApiGenerator;

impl AsyncApiGenerator for PhpAsyncApiGenerator {
    fn generate_test_app(
        &self,
        channels: &[ChannelInfo],
        _messages: &[Message],
        _protocol: &str,
    ) -> Result<String> {
        let mut code = String::new();

        code.push_str("<?php\n");
        code.push_str("declare(strict_types=1);\n\n");
        code.push_str("// Test application generated from AsyncAPI specification\n\n");
        code.push_str("$uri = getenv('URI') ?: 'ws://localhost:8000");

        if let Some(first_channel) = channels.first() {
            code.push_str(&first_channel.path);
        }

        code.push_str("';\n\n");
        code.push_str("echo \"Connecting to {$uri}...\\n\";\n");

        Ok(code)
    }

    fn generate_handler_app(
        &self,
        channels: &[ChannelInfo],
        _messages: &[Message],
        protocol: &str,
    ) -> Result<String> {
        if channels.is_empty() {
            bail!("AsyncAPI spec does not define any channels");
        }

        match protocol {
            "websocket" | "sse" => {}
            other => bail!("Protocol {} is not supported for PHP handler generation", other),
        }

        let mut code = String::new();
        code.push_str("<?php\n");
        code.push_str("declare(strict_types=1);\n\n");
        code.push_str("// AsyncAPI handler skeleton generated by Spikard CLI.\n\n");
        code.push_str("final class AsyncApiHandlers\n{\n");
        code.push_str("    public static function register(object $app): void\n    {\n");

        for channel in channels {
            match protocol {
                "websocket" => code.push_str(&format!(
                    "        // TODO: register WebSocket route \"{}\"\n",
                    channel.path
                )),
                "sse" => code.push_str(&format!("        // TODO: register SSE route \"{}\"\n", channel.path)),
                _ => {}
            }
        }

        code.push_str("    }\n\n");

        for channel in channels {
            let suffix = camel_identifier(&channel.name);
            let message_description = if channel.messages.is_empty() {
                "messages".to_string()
            } else {
                channel.messages.join(", ")
            };

            match protocol {
                "websocket" => {
                    code.push_str(&format!(
                        "    public static function handle{}(array $message): array\n    {{\n",
                        suffix
                    ));
                    code.push_str(&format!(
                        "        // TODO: Handle {} received on {}\n",
                        message_description, channel.path
                    ));
                    code.push_str("        return $message;\n");
                    code.push_str("    }\n\n");
                }
                "sse" => {
                    code.push_str(&format!(
                        "    public static function stream{}(): iterable\n    {{\n",
                        suffix
                    ));
                    code.push_str(&format!(
                        "        // TODO: Emit SSE events for {}\n        yield \"data: {{\\\\\"message\\\\\": \\\\\"replace with event\\\\\"}}\\\\n\\\\n\";\n",
                        channel.path
                    ));
                    code.push_str("    }\n\n");
                }
                _ => {}
            }
        }

        code.push_str("}\n\n");
        code.push_str("if (PHP_SAPI === 'cli' && __FILE__ === realpath($_SERVER['SCRIPT_FILENAME'])) {\n");
        code.push_str("    // $app = new Spikard\\\\App();\n");
        code.push_str("    // AsyncApiHandlers::register($app);\n");
        code.push_str("    // $app->run();\n");
        code.push_str("}\n");

        Ok(code)
    }

    fn language_name(&self) -> &'static str {
        "php"
    }
}

fn camel_identifier(name: &str) -> String {
    let base = sanitize_identifier(name);
    let mut result = String::new();
    for part in base.split('_').filter(|segment| !segment.is_empty()) {
        let mut chars = part.chars();
        if let Some(first) = chars.next() {
            result.push(first.to_ascii_uppercase());
            result.push_str(chars.as_str());
        }
    }
    if result.is_empty() {
        "Handler".to_string()
    } else {
        result
    }
}

fn sanitize_identifier(name: &str) -> String {
    let mut ident: String = name
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect();

    while ident.contains("__") {
        ident = ident.replace("__", "_");
    }

    ident = ident.trim_matches('_').to_string();

    if ident.is_empty() {
        return "handler".to_string();
    }

    if ident.chars().next().unwrap().is_ascii_digit() {
        ident.insert(0, '_');
    }

    ident
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_php_generator_test_app() {
        let generator = PhpAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator.generate_test_app(&channels, &messages, "websocket").unwrap();
        assert!(code.contains("<?php"));
        assert!(code.contains("getenv"));
        assert!(code.contains("/chat"));
    }

    #[test]
    fn test_php_generator_handler_app() {
        let generator = PhpAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator.generate_handler_app(&channels, &messages, "websocket").unwrap();
        assert!(code.contains("AsyncApiHandlers"));
        assert!(code.contains("public static function"));
    }
}
