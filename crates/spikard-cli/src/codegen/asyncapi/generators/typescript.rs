//! TypeScript AsyncAPI code generation.

use anyhow::{Result, bail};

use super::base::sanitize_typescript_identifier;
use super::{AsyncApiGenerator, ChannelInfo};

/// TypeScript AsyncAPI code generator
pub struct TypeScriptAsyncApiGenerator;

impl AsyncApiGenerator for TypeScriptAsyncApiGenerator {
    fn generate_test_app(&self, channels: &[ChannelInfo], protocol: &str) -> Result<String> {
        let mut code = String::new();

        code.push_str("#!/usr/bin/env node\n");
        code.push_str("/**\n");
        code.push_str(" * Test application generated from AsyncAPI specification\n");
        code.push_str(" */\n\n");

        match protocol {
            "websocket" => {
                code.push_str("import WebSocket from 'ws';\n");
            }
            "sse" => {
                code.push_str("import fetch from 'node-fetch';\n");
            }
            _ => {
                return Err(anyhow::anyhow!(
                    "Unsupported protocol for TypeScript test app: {}",
                    protocol
                ));
            }
        }

        code.push_str("import { fileURLToPath } from 'node:url';\n\n");

        code.push_str("const __filename = fileURLToPath(import.meta.url);\n\n");

        if protocol == "websocket" {
            code.push_str("async function handleWebSocket(ws: WebSocket): Promise<void> {\n");
            code.push_str("  // Handle WebSocket messages\n");
            code.push_str("  ws.on('message', (data: string) => {\n");
            code.push_str("    const parsed = JSON.parse(data);\n");
            code.push_str("    console.log('Received:', parsed);\n");
            code.push_str("  });\n");
            code.push_str("}\n\n");
        }

        code.push_str("async function main(): Promise<void> {\n");
        code.push_str("  const uri = process.env.URI || 'ws://localhost:8000");

        if let Some(first_channel) = channels.first() {
            code.push_str(&first_channel.path);
        }

        code.push_str("';\n");
        code.push_str("  console.log(`Connecting to ${uri}...`);\n");
        code.push_str("}\n\n");
        code.push_str("main().catch(console.error);\n");

        Ok(code)
    }

    fn generate_handler_app(&self, channels: &[ChannelInfo], protocol: &str) -> Result<String> {
        if channels.is_empty() {
            bail!("AsyncAPI spec does not define any channels");
        }

        match protocol {
            "websocket" | "sse" => {}
            other => bail!("Protocol {} is not supported for TypeScript handler generation", other),
        }

        let mut code = String::new();
        code.push_str("/**\n * AsyncAPI handler skeleton generated by Spikard CLI.\n */\n\n");
        code.push_str("import type { RouteMetadata, SpikardApp } from \"spikard\";\n");
        if protocol == "sse" {
            code.push_str("import { StreamingResponse } from \"spikard\";\n");
        }
        code.push_str("import { z } from \"zod\";\n");
        code.push('\n');

        let mut handler_entries = Vec::new();
        let mut route_entries = Vec::new();

        for channel in channels {
            let handler_name = format!("handle{}", camel_identifier(&channel.name));
            let message_description = if channel.messages.is_empty() {
                "messages".to_string()
            } else {
                channel.messages.join(", ")
            };

            match protocol {
                "websocket" => {
                    code.push_str(&format!(
                        "async function {}(message: unknown): Promise<string> {{\n",
                        handler_name
                    ));
                    code.push_str(&format!(
                        "  // TODO: Handle {} for {}\n",
                        message_description, channel.path
                    ));
                    code.push_str("  return JSON.stringify(message);\n");
                    code.push_str("}\n\n");
                }
                "sse" => {
                    code.push_str(&format!(
                        "async function {}(): Promise<StreamingResponse> {{\n",
                        handler_name
                    ));
                    code.push_str("  async function* eventStream() {\n");
                    code.push_str("    yield \"data: {\\\"message\\\": \\\"replace with event\\\"}\\n\\n\";\n");
                    code.push_str("  }\n");
                    code.push_str(
                        "  return new StreamingResponse(eventStream(), { statusCode: 200, headers: { \"content-type\": \"text/event-stream\" } });\n",
                    );
                    code.push_str("}\n\n");
                }
                _ => {}
            }

            route_entries.push(format!(
                "{{ method: \"GET\", path: \"{}\", handler_name: \"{}\", is_async: true }}",
                channel.path, handler_name
            ));
            handler_entries.push(format!("{}: {}", handler_name, handler_name));
        }

        code.push_str("const routes: RouteMetadata[] = [\n    ");
        code.push_str(&route_entries.join(",\n    "));
        code.push_str("\n];\n\n");
        code.push_str("const handlers = {\n    ");
        code.push_str(&handler_entries.join(",\n    "));
        code.push_str("\n};\n\n");
        code.push_str("export function createAsyncApiHandlers(): SpikardApp {\n");
        code.push_str("  return { routes, handlers };\n");
        code.push_str("}\n");

        Ok(code)
    }
}

fn camel_identifier(name: &str) -> String {
    sanitize_typescript_identifier(name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_typescript_generator_test_app_websocket() {
        let generator = TypeScriptAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];

        let code = generator.generate_test_app(&channels, "websocket").unwrap();
        assert!(code.contains("import WebSocket from 'ws'"));
        assert!(code.contains("#!/usr/bin/env node"));
        assert!(code.contains("/chat"));
    }

    #[test]
    fn test_typescript_generator_handler_app() {
        let generator = TypeScriptAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];

        let code = generator.generate_handler_app(&channels, "websocket").unwrap();
        assert!(code.contains("async function"));
        assert!(code.contains("routes"));
    }
}
