//! Rust AsyncAPI code generation.

use anyhow::{Result, bail};

use super::base::sanitize_identifier;
use super::{AsyncApiGenerator, ChannelInfo, Message};

/// Rust AsyncAPI code generator
pub struct RustAsyncApiGenerator;

impl AsyncApiGenerator for RustAsyncApiGenerator {
    fn generate_test_app(&self, channels: &[ChannelInfo], _messages: &[Message], protocol: &str) -> Result<String> {
        let mut code = String::new();

        code.push_str("//! Test application generated from AsyncAPI specification\n\n");
        match protocol {
            "websocket" => {
                code.push_str("use tokio::net::TcpStream;\n");
                code.push_str("use tokio_tungstenite::connect_async;\n\n");
            }
            "sse" => {
                code.push_str("use reqwest::Client;\n\n");
            }
            _ => {
                return Err(anyhow::anyhow!("Unsupported protocol for Rust test app: {}", protocol));
            }
        }

        code.push_str("#[tokio::main]\n");
        code.push_str("async fn main() -> Result<(), Box<dyn std::error::Error>> {\n");
        code.push_str("    let uri = std::env::var(\"URI\")\n");
        code.push_str("        .unwrap_or_else(|_| \"ws://localhost:8000");

        if let Some(first_channel) = channels.first() {
            code.push_str(&first_channel.path);
        }

        code.push_str("\".to_string());\n\n");
        code.push_str("    println!(\"Connecting to {}\", uri);\n");
        code.push_str("    Ok(())\n");
        code.push_str("}\n");

        Ok(code)
    }

    fn generate_handler_app(&self, channels: &[ChannelInfo], _messages: &[Message], protocol: &str) -> Result<String> {
        if channels.is_empty() {
            bail!("AsyncAPI spec does not define any channels");
        }

        match protocol {
            "websocket" | "sse" => {}
            other => bail!("Protocol {} is not supported for Rust handler generation", other),
        }

        let mut code = String::new();
        code.push_str("//! AsyncAPI handler skeleton generated by Spikard CLI.\n\n");
        match protocol {
            "websocket" => {
                code.push_str("use serde_json::Value;\n");
                code.push_str("use spikard::{App, AppError, WebSocketHandler};\n\n");
            }
            "sse" => {
                code.push_str("use spikard::{App, AppError, SseEvent, SseEventProducer};\n\n");
            }
            _ => {}
        }

        let mut handler_defs = String::new();
        let mut registrations = String::new();

        for channel in channels {
            let struct_name = format!(
                "{}{}",
                camel_identifier(&channel.name),
                match protocol {
                    "websocket" => "WebSocketHandler",
                    "sse" => "SseProducer",
                    _ => "",
                }
            );
            let path = escape_rust_string(&channel.path);
            match protocol {
                "websocket" => {
                    handler_defs.push_str(&format!("struct {};\n\n", struct_name));
                    handler_defs.push_str(&format!("impl WebSocketHandler for {} {{\n", struct_name));
                    handler_defs.push_str("    fn handle_message(&self, message: Value) -> impl std::future::Future<Output = Option<Value>> + Send {\n");
                    handler_defs.push_str("        async move {\n");
                    handler_defs.push_str("            println!(\"Received message: {:?}\", message);\n");
                    handler_defs.push_str("            None\n");
                    handler_defs.push_str("        }\n");
                    handler_defs.push_str("    }\n");
                    handler_defs.push_str("}\n\n");
                    registrations.push_str(&format!("    app.websocket(\"{}\", {});\n", path, struct_name));
                }
                "sse" => {
                    handler_defs.push_str(&format!("struct {};\n\n", struct_name));
                    handler_defs.push_str(&format!("impl SseEventProducer for {} {{\n", struct_name));
                    handler_defs.push_str(
                        "    fn next_event(&self) -> impl std::future::Future<Output = Option<SseEvent>> + Send {\n",
                    );
                    handler_defs.push_str("        async move {\n");
                    handler_defs.push_str("            println!(\"Streaming SSE event\");\n");
                    handler_defs.push_str("            None\n");
                    handler_defs.push_str("        }\n");
                    handler_defs.push_str("    }\n");
                    handler_defs.push_str("}\n\n");
                    registrations.push_str(&format!("    app.sse(\"{}\", {});\n", path, struct_name));
                }
                _ => {}
            }
        }

        code.push_str(&handler_defs);
        code.push_str("fn build_app() -> Result<App, AppError> {\n");
        code.push_str("    let mut app = App::new();\n");
        code.push_str(&registrations);
        code.push_str("    Ok(app)\n");
        code.push_str("}\n\n");
        code.push_str("#[tokio::main]\n");
        code.push_str("async fn main() -> Result<(), AppError> {\n");
        code.push_str("    let app = build_app()?;\n");
        code.push_str("    app.run().await\n");
        code.push_str("}\n");

        Ok(code)
    }

    fn language_name(&self) -> &'static str {
        "rust"
    }
}

fn camel_identifier(name: &str) -> String {
    let base = sanitize_identifier(name);
    let mut result = String::new();
    for part in base.split('_').filter(|segment| !segment.is_empty()) {
        let mut chars = part.chars();
        if let Some(first) = chars.next() {
            result.push(first.to_ascii_uppercase());
            result.push_str(chars.as_str());
        }
    }
    if result.is_empty() {
        "Handler".to_string()
    } else {
        result
    }
}

fn escape_rust_string(input: &str) -> String {
    input.escape_default().to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rust_generator_test_app_websocket() {
        let generator = RustAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator.generate_test_app(&channels, &messages, "websocket").unwrap();
        assert!(code.contains("tokio_tungstenite"));
        assert!(code.contains("#[tokio::main]"));
        assert!(code.contains("/chat"));
    }

    #[test]
    fn test_rust_generator_handler_app() {
        let generator = RustAsyncApiGenerator;
        let channels = vec![ChannelInfo {
            name: "chat".to_string(),
            path: "/chat".to_string(),
            messages: vec!["message".to_string()],
        }];
        let messages = vec![];

        let code = generator
            .generate_handler_app(&channels, &messages, "websocket")
            .unwrap();
        assert!(code.contains("WebSocketHandler"));
        assert!(code.contains("impl"));
    }

    #[test]
    fn test_camel_identifier() {
        assert_eq!(camel_identifier("hello_world"), "HelloWorld");
        assert_eq!(camel_identifier("chat-room"), "ChatRoom");
    }
}
