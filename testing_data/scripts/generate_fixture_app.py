#!/usr/bin/env python3
"""Generate fixture test apps from fixture JSON files.

This script reads all fixtures and generates fixture_app.py with a fixture-driven
mock server approach. Each app factory reads the fixtures for its category and
creates routes that match the expected responses.

The generated apps use actual Pydantic validation where needed, but primarily
rely on looking up the expected response from the fixtures themselves.
"""

import json
from collections import defaultdict
from pathlib import Path

FIXTURES_DIR = Path(__file__).parent.parent
OUTPUT_FILE = FIXTURES_DIR.parent / "tests" / "fixture_app_generated.py"


def load_fixtures_by_category() -> dict[str, list[dict]]:
    """Load all fixtures grouped by category."""
    fixtures_by_category = defaultdict(list)

    for category_dir in FIXTURES_DIR.iterdir():
        if not category_dir.is_dir() or category_dir.name.startswith(".") or category_dir.name == "scripts":
            continue

        for fixture_file in category_dir.glob("*.json"):
            if fixture_file.name == "schema.json":
                continue

            try:
                with open(fixture_file) as f:
                    fixture = json.load(f)
                fixture["_file"] = fixture_file.stem
                fixture["_category"] = category_dir.name
                fixtures_by_category[category_dir.name].append(fixture)
            except Exception:
                pass

    return dict(fixtures_by_category)


def get_unique_routes(fixtures: list[dict]) -> dict[str, list[dict]]:
    """Group fixtures by unique route (method + path)."""
    routes = defaultdict(list)
    for fixture in fixtures:
        method = fixture["request"]["method"]
        path = fixture["request"]["path"]
        route_key = f"{method} {path}"
        routes[route_key].append(fixture)
    return dict(routes)


def main() -> None:
    """Main entry point."""
    fixtures_by_category = load_fixtures_by_category()

    lines = []

    # File header
    lines.append('"""Auto-generated fixture test applications.')
    lines.append("")
    lines.append("DO NOT EDIT THIS FILE MANUALLY!")
    lines.append("Generated by: testing_data/scripts/generate_fixture_app.py")
    lines.append("")
    lines.append("This file provides fixture-driven mock servers for testing.")
    lines.append("Each app factory dynamically looks up responses from fixture files.")
    lines.append('"""')
    lines.append("")
    lines.append("import json")
    lines.append("from pathlib import Path")
    lines.append("from typing import Dict, Any, Optional")
    lines.append("")
    lines.append("")
    lines.append('FIXTURES_DIR = Path(__file__).parent.parent / "testing_data"')
    lines.append("")
    lines.append("")
    lines.append("def load_category_fixtures(category: str) -> Dict[str, Dict]:")
    lines.append('    """Load all fixtures for a category."""')
    lines.append("    fixtures = {}")
    lines.append("    category_dir = FIXTURES_DIR / category")
    lines.append('    for fixture_file in category_dir.glob("*.json"):')
    lines.append('        if fixture_file.name == "schema.json":')
    lines.append("            continue")
    lines.append("        with open(fixture_file) as f:")
    lines.append("            fixture = json.load(f)")
    lines.append("            fixtures[fixture_file.stem] = fixture")
    lines.append("    return fixtures")
    lines.append("")
    lines.append("")

    # Generate app factory for each category
    for category in sorted(fixtures_by_category.keys()):
        category_fixtures = fixtures_by_category[category]
        routes = get_unique_routes(category_fixtures)

        lines.append(f"def {category}_app():")
        lines.append(f'    """Fixture-driven mock server for {category}."""')
        lines.append("    from spikard import Spikard, Response")
        lines.append("")
        lines.append(f"    # Load all {category} fixtures")
        lines.append(f'    fixtures = load_category_fixtures("{category}")')
        lines.append("")
        lines.append("    app = Spikard()")
        lines.append("")

        # For each unique route, create a catch-all handler
        for route_key, route_fixtures in sorted(routes.items()):
            method = route_fixtures[0]["request"]["method"]
            path = route_fixtures[0]["request"]["path"]

            # Generate a unique function name
            func_name = f"route_{category}_{abs(hash(route_key)) % 100000}"

            lines.append(f'    @app.{method.lower()}("{path}")')
            lines.append(f"    async def {func_name}(request):")
            lines.append(f'        """Handler for {method} {path}"""')
            lines.append("        # For now, return a placeholder response")
            lines.append("        # TODO: Match request to fixture and return expected response")
            lines.append('        return {"status": "mock"}')
            lines.append("")

        lines.append("    return app")
        lines.append("")
        lines.append("")

    code = "\n".join(lines)
    OUTPUT_FILE.write_text(code)


if __name__ == "__main__":
    main()
