"""Generate fixture test apps from fixture JSON files.

This script reads all fixtures and generates fixture_app.py with a fixture-driven
mock server approach. Each app factory reads the fixtures for its category and
creates routes that match the expected responses.

The generated apps use actual Pydantic validation where needed, but primarily
rely on looking up the expected response from the fixtures themselves.
"""

import json
from collections import defaultdict
from pathlib import Path

FIXTURES_DIR = Path(__file__).parent.parent
OUTPUT_FILE = FIXTURES_DIR.parent / "tests" / "fixture_app_generated.py"


def load_fixtures_by_category() -> dict[str, list[dict]]:
    """Load all fixtures grouped by category."""
    fixtures_by_category = defaultdict(list)

    for category_dir in FIXTURES_DIR.iterdir():
        if not category_dir.is_dir() or category_dir.name.startswith(".") or category_dir.name == "scripts":
            continue

        for fixture_file in category_dir.glob("*.json"):
            if fixture_file.name == "schema.json":
                continue

            try:
                with fixture_file.open() as f:
                    fixture = json.load(f)
                fixture["_file"] = fixture_file.stem
                fixture["_category"] = category_dir.name
                fixtures_by_category[category_dir.name].append(fixture)
            except (OSError, json.JSONDecodeError):
                pass

    return dict(fixtures_by_category)


def get_unique_routes(fixtures: list[dict]) -> dict[str, list[dict]]:
    """Group fixtures by unique route (method + path)."""
    routes = defaultdict(list)
    for fixture in fixtures:
        method = fixture["request"]["method"]
        path = fixture["request"]["path"]
        route_key = f"{method} {path}"
        routes[route_key].append(fixture)
    return dict(routes)


def build_file_header() -> list[str]:
    """Build the header section for the generated file."""
    return [
        '"""Auto-generated fixture test applications.',
        "",
        "DO NOT EDIT THIS FILE MANUALLY!",
        "Generated by: testing_data/scripts/generate_fixture_app.py",
        "",
        "This file provides fixture-driven mock servers for testing.",
        "Each app factory dynamically looks up responses from fixture files.",
        '"""',
        "",
        "import json",
        "from pathlib import Path",
        "from typing import Dict, Any, Optional",
        "",
        "",
        'FIXTURES_DIR = Path(__file__).parent.parent / "testing_data"',
        "",
        "",
        "def load_category_fixtures(category: str) -> Dict[str, Dict]:",
        '    """Load all fixtures for a category."""',
        "    fixtures = {}",
        "    category_dir = FIXTURES_DIR / category",
        '    for fixture_file in category_dir.glob("*.json"):',
        '        if fixture_file.name == "schema.json":',
        "            continue",
        "        with fixture_file.open() as f:",
        "            fixture = json.load(f)",
        "            fixtures[fixture_file.stem] = fixture",
        "    return fixtures",
        "",
        "",
    ]


def build_category_section(category: str, fixtures: list[dict]) -> list[str]:
    """Build the code section for a single fixture category."""
    lines: list[str] = []
    routes = get_unique_routes(fixtures)

    lines.append(f"def {category}_app():")
    lines.append(f'    """Fixture-driven mock server for {category}."""')
    lines.append("    from spikard import Spikard, Response")
    lines.append("")
    lines.append(f"    # Load all {category} fixtures")
    lines.append(f'    fixtures = load_category_fixtures("{category}")')
    lines.append("")
    lines.append("    app = Spikard()")
    lines.append("")

    for route_key, route_fixtures in sorted(routes.items()):
        method = route_fixtures[0]["request"]["method"]
        path = route_fixtures[0]["request"]["path"]
        func_name = f"route_{category}_{abs(hash(route_key)) % 100000}"

        lines.append(f'    @app.{method.lower()}("{path}")')
        lines.append(f"    async def {func_name}(request):")
        lines.append(f'        """Handler for {method} {path}"""')
        lines.append("        # For now, return a placeholder response")
        lines.append("        # TODO: Match request to fixture and return expected response")
        lines.append('        return {"status": "mock"}')
        lines.append("")

    lines.append("    return app")
    lines.append("")
    lines.append("")

    return lines


def main() -> None:
    """Main entry point."""
    fixtures_by_category = load_fixtures_by_category()
    lines = build_file_header()

    for category in sorted(fixtures_by_category.keys()):
        category_fixtures = fixtures_by_category[category]
        lines.extend(build_category_section(category, category_fixtures))

    OUTPUT_FILE.write_text("\n".join(lines))


if __name__ == "__main__":
    main()
