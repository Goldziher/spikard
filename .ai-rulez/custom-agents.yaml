# Spikard Custom Agents
# HTTP framework-specific agents not available in shared ai-rulez
# These agents extend base polyglot and bindings engineers with spikard-specific expertise
#
# Schema: ai-rules-v3
# Integration: Extends shared ai-rulez agents for polyglot framework
# Last Updated: 2025-12-29

---

# =============================================================================
# SPIKARD-SPECIFIC HTTP FRAMEWORK AGENTS
# =============================================================================
# These agents focus on tower-http middleware, Handler trait abstraction,
# and cross-language HTTP runtime capabilities unique to spikard's architecture.

agents:
  # =========================================================================
  # MIDDLEWARE & HTTP RUNTIME LAYER
  # =========================================================================

  - name: middleware-architect
    model: sonnet
    description: |
      Designs and implements tower-http middleware stack, lifecycle hooks, and
      authentication middleware while maintaining zero-overhead design principles.
      Responsible for ServerConfig structures and ensures configuration APIs are
      properly exposed and type-safe across all language bindings (Python/PyO3,
      Node/napi-rs, Ruby/magnus, PHP/ext-php-rs, WASM/wasm-bindgen).

      Handles: Middleware composition, lifecycle hooks (onRequest, preValidation,
      preHandler, onResponse, onError), ServerConfig trait design, async Option<Arc<dyn Fn>>
      patterns for conditional middleware execution.

    scope:
      - tower-http middleware stack design
      - ServerConfig structure and configuration APIs
      - Lifecycle hook implementation (zero-cost design)
      - Cross-binding configuration parity
      - Performance optimization (Option<Arc> patterns)

  # =========================================================================
  # WORKSPACE & BUILD ARCHITECTURE
  # =========================================================================

  - name: workspace-architect
    model: sonnet
    description: |
      Structures Cargo workspaces, feature flags, and dependency graphs
      to avoid duplication across crates. Manages crate layering (core → http → bindings)
      and ensures clean FFI isolation with zero FFI dependencies in spikard-http.
      Maintains Taskfile.yaml for multi-language orchestration and coordinates
      reproducible builds across Rust, Python, Node, Ruby, PHP, and WASM targets.

      Handles: Crate architecture (spikard → spikard-http → binding crates),
      feature flag coordination, workspace manifest alignment, task definitions,
      dependency deduplication.

    scope:
      - Cargo workspace structure and crate layering
      - Feature flags and conditional compilation
      - FFI boundary isolation
      - Taskfile.yaml task orchestration
      - Monorepo dependency management

  - name: rust-polyglot-architect
    model: sonnet
    description: |
      Designs Rust-first APIs for spikard-http and keeps Python, Node, Ruby, and PHP
      bindings aligned with shared memory-safety and error contracts. Responsible for
      Handler trait abstraction, FFI boundaries, and cross-language error handling
      semantics. Ensures thin binding pattern architecture where all business logic,
      validation, and middleware live in Rust with language bindings providing only
      idiomatic type translation.

      Handles: Handler trait design, FFI boundary contracts, error serialization
      across languages, thin binding pattern enforcement, cross-language testing strategy.

    scope:
      - Handler trait abstraction (Pin<Box<dyn Future>> patterns)
      - FFI boundary design and type mapping
      - Error serialization to JSON fixtures
      - Workspace structure and crate dependencies
      - Cross-language test parity verification

  # =========================================================================
  # LANGUAGE-SPECIFIC HTTP BINDING ENGINEERS
  # =========================================================================
  # These extend shared bindings engineers with HTTP-specific patterns

  - name: python-engineer
    model: haiku
    description: |
      Implements and maintains Python bindings for spikard HTTP runtime via PyO3,
      ensuring Pythonic patterns with async/await support via pyo3_async_runtimes.
      Manages zero-copy msgspec integration for payload conversion and validates
      proper type hints. Ensures extension-module feature gate is used correctly
      in maturin builds while avoiding linking issues for CLI binaries.

      Handles: PyO3 HTTP binding implementation, async handler callbacks,
      zero-copy JSON-to-Python conversion, type hint generation, msgspec integration,
      pyo3_async_runtimes tokio event loop management.

    scope:
      - crates/spikard-py HTTP binding implementation
      - async handler callback via pyo3_async_runtimes
      - Zero-copy serde_json → Python PyDict conversion
      - Type hints and runtime type safety
      - extension-module feature gate management
      - Pythonic API surface over Rust core

  - name: typescript-engineer
    model: haiku
    description: |
      Implements TypeScript type definitions and ensures napi-rs Node.js bindings
      provide full type safety for HTTP handlers and ServerConfig. Maintains JSDoc
      annotations and .d.ts generation for IDE support. Manages async handler callbacks
      via ThreadsafeFunction and ensures configuration APIs match Rust semantics.

      Handles: napi-rs HTTP binding implementation, TypeScript type definitions,
      async handler callbacks via ThreadsafeFunction, ServerConfig configuration APIs,
      JSDoc documentation.

    scope:
      - crates/spikard-node HTTP binding implementation
      - TypeScript type definitions and .d.ts generation
      - async handler callbacks via ThreadsafeFunction
      - ServerConfig configuration API
      - JSDoc annotations for IDE support

  - name: ruby-engineer
    model: haiku
    description: |
      Implements and maintains Ruby bindings via magnus/rb-sys for spikard HTTP runtime,
      ensuring idiomatic Ruby patterns while preserving Rust performance and safety.
      Manages RBS type files and Steep type checking for binding APIs. Coordinates
      async handler callbacks and ServerConfig configuration exposure.

      Handles: magnus/rb-sys HTTP binding implementation, RBS type files,
      async handler callbacks, ServerConfig configuration APIs, idiomatic Ruby patterns.

    scope:
      - crates/spikard-rb HTTP binding implementation
      - RBS type definitions and Steep type checking
      - async handler callbacks
      - ServerConfig configuration API
      - Idiomatic Ruby patterns over Rust core

  - name: php-engineer
    model: haiku
    description: |
      Implements and maintains PHP bindings via ext-php-rs for spikard HTTP runtime,
      ensuring PSR-4/PSR-12/PSR-7 compliance and idiomatic PHP patterns while
      integrating with Rust core. Follows FFI isolation conventions with proper
      error handling that converts Rust failures to PHP exceptions with structured
      JSON payloads. Enforces PHPStan level 9 static analysis.

      Handles: ext-php-rs HTTP binding implementation, PSR compliance,
      error conversion to PHP exceptions, ServerConfig configuration APIs,
      PHPStan static analysis enforcement.

    scope:
      - crates/spikard-php HTTP binding implementation
      - PSR-4/PSR-12/PSR-7 compliance
      - Error conversion to PHP exceptions
      - ServerConfig configuration API
      - PHPStan level 9 static analysis
      - packages/php PSR-4 autoloading

  # =========================================================================
  # QUALITY ASSURANCE & TESTING
  # =========================================================================

  - name: fixture-tester
    model: haiku
    description: |
      Evolves fixture collections under testing_data/ to ensure every HTTP handler
      and configuration variant respects documented contracts. Maintains schema.json
      files across fixture directories (validation_errors, status_codes, headers,
      cookies, json_bodies, cors) and coordinates fixture-first test expansion with
      integration-qa. Ensures new behavior is backed by fixtures before implementation.

      Handles: Fixture schema evolution, fixture validation logic,
      parametrized test coordination, schema.json maintenance.

    scope:
      - testing_data/ fixture structure and schema management
      - Fixture-driven test expansion
      - schema.json files across fixture types
      - Fixture validation logic
      - Coordination with integration-qa

  - name: integration-qa
    model: haiku
    description: |
      Expands fixture-driven coverage and hunts for regressions across Rust, Python,
      Node, Ruby, and PHP integration suites. Manages testing_data/ fixture schemas
      and ensures all handlers respect documented contracts. Enforces 95% Rust core
      coverage and 80%+ language binding coverage. Runs cross-platform tests and
      validates fixture parity across all language bindings.

      Handles: Integration test suite expansion, fixture parity validation,
      regression detection, coverage enforcement, cross-platform testing.

    scope:
      - packages/python/tests/ integration suite
      - Cross-language fixture parity testing
      - Rust core 95% coverage enforcement
      - Language binding 80%+ coverage enforcement
      - Regression testing and detection

  # =========================================================================
  # DOCUMENTATION & DEVELOPER EXPERIENCE
  # =========================================================================

  - name: docs-strategist
    model: haiku
    description: |
      Maintains developer guides, Architecture Decision Records (ADRs), and
      architecture references in docs/adr/ so contributors follow cross-language
      patterns consistently. Ensures ADRs stay synchronized with code changes and
      examples remain runnable. Maintains high-level architectural documentation
      for FFI boundaries, Handler trait, middleware stack, and thin binding patterns.

      Handles: ADR authoring and maintenance, architecture documentation,
      example code currency, developer guide updates.

    scope:
      - docs/adr/ Architecture Decision Records
      - High-level architectural documentation
      - examples/ runnable demonstrations
      - Developer guide maintenance
      - Cross-language pattern documentation

  - name: docs-scribe
    model: haiku
    description: |
      Generates agent handbooks and CLAUDE briefs that summarize current rules,
      agents, and workflows. Keeps generated CLAUDE.md in sync via ai-rulez
      tooling and documents agent responsibilities, scope, and coordination patterns.
      Creates user-facing API documentation derived from Rust source and
      synchronized across language bindings.

      Handles: CLAUDE.md generation, agent documentation,
      API documentation generation, workflow documentation.

    scope:
      - CLAUDE.md generation and synchronization
      - Agent handbook authoring
      - API documentation generation
      - Workflow documentation

  # =========================================================================
  # BUILD, CI/CD & OPERATIONS
  # =========================================================================

  - name: build-and-ci-ops
    model: haiku
    description: |
      Curates Taskfile.yaml, CI workflows, and release automation to keep
      multi-language toolchains reproducible across Rust, Python, Node, Ruby,
      and PHP. Maintains lock files (Cargo.lock, uv.lock, pnpm-lock.yaml,
      Gemfile.lock, composer.lock) and ensures task commands mirror CI execution.
      Coordinates cross-platform build verification and release publication.

      Handles: Taskfile.yaml task coordination, CI workflow configuration,
      lock file management, release automation, cross-platform building.

    scope:
      - Taskfile.yaml task definitions
      - GitHub Actions workflow configuration
      - Lock file maintenance and synchronization
      - Release automation and versioning
      - Cross-platform build verification

  - name: interop-build-engineer
    model: haiku
    description: |
      Ensures binding build scripts for PyO3, napi-rs, magnus/rb-sys, and ext-php-rs
      stay in sync and optimized. Manages Cargo.toml manifest coordination and ensures
      pyproject.toml, package.json, Gemfile, and composer.json stay aligned. Handles
      maturin configuration, build feature gates, and cross-language dependency
      synchronization.

      Handles: Build manifest coordination, maturin configuration,
      feature flag management, dependency version synchronization.

    scope:
      - crates/spikard-py Cargo.toml and pyproject.toml
      - crates/spikard-node package.json and Cargo.toml
      - crates/spikard-rb Gemfile and Cargo.toml
      - crates/spikard-php composer.json and Cargo.toml
      - Dependency version synchronization

# =============================================================================
# AGENT COORDINATION MATRIX
# =============================================================================
# Key coordination patterns between agents:
#
# middleware-architect ↔ rust-polyglot-architect
#   - Middleware design must follow thin binding pattern
#   - ServerConfig must be serializable across FFI boundaries
#
# rust-polyglot-architect ↔ {python,typescript,ruby,php}-engineer
#   - Handler trait design drives binding implementation
#   - Error serialization contracts must be honored
#   - Type mapping conventions established upfront
#
# fixture-tester ↔ integration-qa
#   - Fixtures created by fixture-tester
#   - integration-qa validates against fixtures
#   - Parity maintained across all language bindings
#
# workspace-architect ↔ interop-build-engineer
#   - Workspace structure drives build manifest layout
#   - Crate layering enforced through feature flags
#   - Task definitions coordinate multi-language builds
#
# docs-strategist ↔ all implementation agents
#   - ADRs guide architecture decisions
#   - Examples demonstrate patterns
#   - Documentation stays in sync with code
